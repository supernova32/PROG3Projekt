/* soapStub.h
   Generated by gSOAP 2.8.9 from AmazonS3.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_ns1	"http://s3.amazonaws.com/doc/2006-03-01/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20809
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__Permission
#define SOAP_TYPE_ns1__Permission (72)
/* ns1:Permission */
enum ns1__Permission {ns1__Permission__READ = 0, ns1__Permission__WRITE = 1, ns1__Permission__READ_USCOREACP = 2, ns1__Permission__WRITE_USCOREACP = 3, ns1__Permission__FULL_USCORECONTROL = 4};
#endif

#ifndef SOAP_TYPE_ns1__StorageClass
#define SOAP_TYPE_ns1__StorageClass (73)
/* ns1:StorageClass */
enum ns1__StorageClass {ns1__StorageClass__STANDARD = 0, ns1__StorageClass__UNKNOWN = 1};
#endif

#ifndef SOAP_TYPE_ns1__MetadataDirective
#define SOAP_TYPE_ns1__MetadataDirective (74)
/* ns1:MetadataDirective */
enum ns1__MetadataDirective {ns1__MetadataDirective__COPY = 0, ns1__MetadataDirective__REPLACE = 1};
#endif

#ifndef SOAP_TYPE_ns1__Payer
#define SOAP_TYPE_ns1__Payer (75)
/* ns1:Payer */
enum ns1__Payer {ns1__Payer__BucketOwner = 0, ns1__Payer__Requester = 1};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (7)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MetadataEntry
#define SOAP_TYPE_ns1__MetadataEntry (13)
/* ns1:MetadataEntry */
class SOAP_CMAC ns1__MetadataEntry
{
public:
	char *Name;	/* required element of type xsd:string */
	char *Value;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__MetadataEntry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MetadataEntry() { ns1__MetadataEntry::soap_default(NULL); }
	virtual ~ns1__MetadataEntry() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Status
#define SOAP_TYPE_ns1__Status (14)
/* ns1:Status */
class SOAP_CMAC ns1__Status
{
public:
	int Code;	/* required element of type xsd:int */
	char *Description;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__Status */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Status() { ns1__Status::soap_default(NULL); }
	virtual ~ns1__Status() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Result
#define SOAP_TYPE_ns1__Result (15)
/* ns1:Result */
class SOAP_CMAC ns1__Result
{
public:
	ns1__Status *Status;	/* required element of type ns1:Status */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__Result */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Result() { ns1__Result::soap_default(NULL); }
	virtual ~ns1__Result() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CreateBucketResult
#define SOAP_TYPE_ns1__CreateBucketResult (16)
/* ns1:CreateBucketResult */
class SOAP_CMAC ns1__CreateBucketResult
{
public:
	char *BucketName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__CreateBucketResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CreateBucketResult() { ns1__CreateBucketResult::soap_default(NULL); }
	virtual ~ns1__CreateBucketResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BucketLoggingStatus
#define SOAP_TYPE_ns1__BucketLoggingStatus (17)
/* ns1:BucketLoggingStatus */
class SOAP_CMAC ns1__BucketLoggingStatus
{
public:
	class ns1__LoggingSettings *LoggingEnabled;	/* optional element of type ns1:LoggingSettings */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__BucketLoggingStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BucketLoggingStatus() { ns1__BucketLoggingStatus::soap_default(NULL); }
	virtual ~ns1__BucketLoggingStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LoggingSettings
#define SOAP_TYPE_ns1__LoggingSettings (18)
/* ns1:LoggingSettings */
class SOAP_CMAC ns1__LoggingSettings
{
public:
	char *TargetBucket;	/* required element of type xsd:string */
	char *TargetPrefix;	/* required element of type xsd:string */
	class ns1__AccessControlList *TargetGrants;	/* optional element of type ns1:AccessControlList */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__LoggingSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LoggingSettings() { ns1__LoggingSettings::soap_default(NULL); }
	virtual ~ns1__LoggingSettings() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Grantee
#define SOAP_TYPE_ns1__Grantee (19)
/* ns1:Grantee */
class SOAP_CMAC ns1__Grantee
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__Grantee */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Grantee() { ns1__Grantee::soap_default(NULL); }
	virtual ~ns1__Grantee() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Grant
#define SOAP_TYPE_ns1__Grant (24)
/* ns1:Grant */
class SOAP_CMAC ns1__Grant
{
public:
	ns1__Grantee *Grantee;	/* required element of type ns1:Grantee */
	enum ns1__Permission Permission;	/* required element of type ns1:Permission */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__Grant */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Grant() { ns1__Grant::soap_default(NULL); }
	virtual ~ns1__Grant() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AccessControlList
#define SOAP_TYPE_ns1__AccessControlList (25)
/* ns1:AccessControlList */
class SOAP_CMAC ns1__AccessControlList
{
public:
	int __sizeGrant;	/* sequence of 0 to 100 elements <Grant> */
	ns1__Grant **Grant;	/* sequence of 0 to 100 elements */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__AccessControlList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AccessControlList() { ns1__AccessControlList::soap_default(NULL); }
	virtual ~ns1__AccessControlList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CreateBucketConfiguration
#define SOAP_TYPE_ns1__CreateBucketConfiguration (26)
/* ns1:CreateBucketConfiguration */
class SOAP_CMAC ns1__CreateBucketConfiguration
{
public:
	class ns1__LocationConstraint *LocationConstraint;	/* required element of type ns1:LocationConstraint */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__CreateBucketConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CreateBucketConfiguration() { ns1__CreateBucketConfiguration::soap_default(NULL); }
	virtual ~ns1__CreateBucketConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AccessControlPolicy
#define SOAP_TYPE_ns1__AccessControlPolicy (28)
/* ns1:AccessControlPolicy */
class SOAP_CMAC ns1__AccessControlPolicy
{
public:
	class ns1__CanonicalUser *Owner;	/* required element of type ns1:CanonicalUser */
	ns1__AccessControlList *AccessControlList;	/* required element of type ns1:AccessControlList */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__AccessControlPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AccessControlPolicy() { ns1__AccessControlPolicy::soap_default(NULL); }
	virtual ~ns1__AccessControlPolicy() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PutObjectResult
#define SOAP_TYPE_ns1__PutObjectResult (30)
/* ns1:PutObjectResult */
class SOAP_CMAC ns1__PutObjectResult
{
public:
	char *ETag;	/* required element of type xsd:string */
	time_t LastModified;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__PutObjectResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PutObjectResult() { ns1__PutObjectResult::soap_default(NULL); }
	virtual ~ns1__PutObjectResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ListEntry
#define SOAP_TYPE_ns1__ListEntry (31)
/* ns1:ListEntry */
class SOAP_CMAC ns1__ListEntry
{
public:
	char *Key;	/* required element of type xsd:string */
	time_t LastModified;	/* required element of type xsd:dateTime */
	char *ETag;	/* required element of type xsd:string */
	LONG64 Size;	/* required element of type xsd:long */
	ns1__CanonicalUser *Owner;	/* optional element of type ns1:CanonicalUser */
	enum ns1__StorageClass StorageClass;	/* required element of type ns1:StorageClass */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__ListEntry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ListEntry() { ns1__ListEntry::soap_default(NULL); }
	virtual ~ns1__ListEntry() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PrefixEntry
#define SOAP_TYPE_ns1__PrefixEntry (32)
/* ns1:PrefixEntry */
class SOAP_CMAC ns1__PrefixEntry
{
public:
	char *Prefix;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__PrefixEntry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PrefixEntry() { ns1__PrefixEntry::soap_default(NULL); }
	virtual ~ns1__PrefixEntry() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ListBucketResult
#define SOAP_TYPE_ns1__ListBucketResult (33)
/* ns1:ListBucketResult */
class SOAP_CMAC ns1__ListBucketResult
{
public:
	int __sizeMetadata;	/* sequence of elements <Metadata> */
	ns1__MetadataEntry **Metadata;	/* optional element of type ns1:MetadataEntry */
	char *Name;	/* required element of type xsd:string */
	char *Prefix;	/* required element of type xsd:string */
	char *Marker;	/* required element of type xsd:string */
	char *NextMarker;	/* optional element of type xsd:string */
	int MaxKeys;	/* required element of type xsd:int */
	char *Delimiter;	/* optional element of type xsd:string */
	bool IsTruncated;	/* required element of type xsd:boolean */
	int __sizeContents;	/* sequence of elements <Contents> */
	ns1__ListEntry **Contents;	/* optional element of type ns1:ListEntry */
	int __sizeCommonPrefixes;	/* sequence of elements <CommonPrefixes> */
	ns1__PrefixEntry **CommonPrefixes;	/* optional element of type ns1:PrefixEntry */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__ListBucketResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ListBucketResult() { ns1__ListBucketResult::soap_default(NULL); }
	virtual ~ns1__ListBucketResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ListAllMyBucketsEntry
#define SOAP_TYPE_ns1__ListAllMyBucketsEntry (34)
/* ns1:ListAllMyBucketsEntry */
class SOAP_CMAC ns1__ListAllMyBucketsEntry
{
public:
	char *Name;	/* required element of type xsd:string */
	time_t CreationDate;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__ListAllMyBucketsEntry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ListAllMyBucketsEntry() { ns1__ListAllMyBucketsEntry::soap_default(NULL); }
	virtual ~ns1__ListAllMyBucketsEntry() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ListAllMyBucketsResult
#define SOAP_TYPE_ns1__ListAllMyBucketsResult (35)
/* ns1:ListAllMyBucketsResult */
class SOAP_CMAC ns1__ListAllMyBucketsResult
{
public:
	ns1__CanonicalUser *Owner;	/* required element of type ns1:CanonicalUser */
	class ns1__ListAllMyBucketsList *Buckets;	/* required element of type ns1:ListAllMyBucketsList */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__ListAllMyBucketsResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ListAllMyBucketsResult() { ns1__ListAllMyBucketsResult::soap_default(NULL); }
	virtual ~ns1__ListAllMyBucketsResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ListAllMyBucketsList
#define SOAP_TYPE_ns1__ListAllMyBucketsList (36)
/* ns1:ListAllMyBucketsList */
class SOAP_CMAC ns1__ListAllMyBucketsList
{
public:
	int __sizeBucket;	/* sequence of elements <Bucket> */
	ns1__ListAllMyBucketsEntry **Bucket;	/* optional element of type ns1:ListAllMyBucketsEntry */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__ListAllMyBucketsList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ListAllMyBucketsList() { ns1__ListAllMyBucketsList::soap_default(NULL); }
	virtual ~ns1__ListAllMyBucketsList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CopyObjectResult
#define SOAP_TYPE_ns1__CopyObjectResult (37)
/* ns1:CopyObjectResult */
class SOAP_CMAC ns1__CopyObjectResult
{
public:
	time_t LastModified;	/* required element of type xsd:dateTime */
	char *ETag;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__CopyObjectResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CopyObjectResult() { ns1__CopyObjectResult::soap_default(NULL); }
	virtual ~ns1__CopyObjectResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RequestPaymentConfiguration
#define SOAP_TYPE_ns1__RequestPaymentConfiguration (38)
/* ns1:RequestPaymentConfiguration */
class SOAP_CMAC ns1__RequestPaymentConfiguration
{
public:
	enum ns1__Payer Payer;	/* required element of type ns1:Payer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__RequestPaymentConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RequestPaymentConfiguration() { ns1__RequestPaymentConfiguration::soap_default(NULL); }
	virtual ~ns1__RequestPaymentConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateBucket
#define SOAP_TYPE__ns1__CreateBucket (39)
/* ns1:CreateBucket */
class SOAP_CMAC _ns1__CreateBucket
{
public:
	char *Bucket;	/* required element of type xsd:string */
	ns1__AccessControlList *AccessControlList;	/* optional element of type ns1:AccessControlList */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__ns1__CreateBucket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateBucket() { _ns1__CreateBucket::soap_default(NULL); }
	virtual ~_ns1__CreateBucket() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateBucketResponse
#define SOAP_TYPE__ns1__CreateBucketResponse (40)
/* ns1:CreateBucketResponse */
class SOAP_CMAC _ns1__CreateBucketResponse
{
public:
	ns1__CreateBucketResult *CreateBucketReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:CreateBucketResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__ns1__CreateBucketResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateBucketResponse() { _ns1__CreateBucketResponse::soap_default(NULL); }
	virtual ~_ns1__CreateBucketResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteBucket
#define SOAP_TYPE__ns1__DeleteBucket (41)
/* ns1:DeleteBucket */
class SOAP_CMAC _ns1__DeleteBucket
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__ns1__DeleteBucket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteBucket() { _ns1__DeleteBucket::soap_default(NULL); }
	virtual ~_ns1__DeleteBucket() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteBucketResponse
#define SOAP_TYPE__ns1__DeleteBucketResponse (42)
/* ns1:DeleteBucketResponse */
class SOAP_CMAC _ns1__DeleteBucketResponse
{
public:
	ns1__Status *DeleteBucketResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Status */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__ns1__DeleteBucketResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteBucketResponse() { _ns1__DeleteBucketResponse::soap_default(NULL); }
	virtual ~_ns1__DeleteBucketResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetBucketLoggingStatus
#define SOAP_TYPE__ns1__GetBucketLoggingStatus (43)
/* ns1:GetBucketLoggingStatus */
class SOAP_CMAC _ns1__GetBucketLoggingStatus
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__ns1__GetBucketLoggingStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetBucketLoggingStatus() { _ns1__GetBucketLoggingStatus::soap_default(NULL); }
	virtual ~_ns1__GetBucketLoggingStatus() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetBucketLoggingStatusResponse
#define SOAP_TYPE__ns1__GetBucketLoggingStatusResponse (44)
/* ns1:GetBucketLoggingStatusResponse */
class SOAP_CMAC _ns1__GetBucketLoggingStatusResponse
{
public:
	ns1__BucketLoggingStatus *GetBucketLoggingStatusResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:BucketLoggingStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__ns1__GetBucketLoggingStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetBucketLoggingStatusResponse() { _ns1__GetBucketLoggingStatusResponse::soap_default(NULL); }
	virtual ~_ns1__GetBucketLoggingStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetBucketLoggingStatus
#define SOAP_TYPE__ns1__SetBucketLoggingStatus (45)
/* ns1:SetBucketLoggingStatus */
class SOAP_CMAC _ns1__SetBucketLoggingStatus
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	ns1__BucketLoggingStatus *BucketLoggingStatus;	/* required element of type ns1:BucketLoggingStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__ns1__SetBucketLoggingStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetBucketLoggingStatus() { _ns1__SetBucketLoggingStatus::soap_default(NULL); }
	virtual ~_ns1__SetBucketLoggingStatus() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetBucketLoggingStatusResponse
#define SOAP_TYPE__ns1__SetBucketLoggingStatusResponse (46)
/* ns1:SetBucketLoggingStatusResponse */
class SOAP_CMAC _ns1__SetBucketLoggingStatusResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__ns1__SetBucketLoggingStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetBucketLoggingStatusResponse() { _ns1__SetBucketLoggingStatusResponse::soap_default(NULL); }
	virtual ~_ns1__SetBucketLoggingStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetObjectAccessControlPolicy
#define SOAP_TYPE__ns1__GetObjectAccessControlPolicy (47)
/* ns1:GetObjectAccessControlPolicy */
class SOAP_CMAC _ns1__GetObjectAccessControlPolicy
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__ns1__GetObjectAccessControlPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetObjectAccessControlPolicy() { _ns1__GetObjectAccessControlPolicy::soap_default(NULL); }
	virtual ~_ns1__GetObjectAccessControlPolicy() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse
#define SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse (48)
/* ns1:GetObjectAccessControlPolicyResponse */
class SOAP_CMAC _ns1__GetObjectAccessControlPolicyResponse
{
public:
	ns1__AccessControlPolicy *GetObjectAccessControlPolicyResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:AccessControlPolicy */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetObjectAccessControlPolicyResponse() { _ns1__GetObjectAccessControlPolicyResponse::soap_default(NULL); }
	virtual ~_ns1__GetObjectAccessControlPolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetBucketAccessControlPolicy
#define SOAP_TYPE__ns1__GetBucketAccessControlPolicy (49)
/* ns1:GetBucketAccessControlPolicy */
class SOAP_CMAC _ns1__GetBucketAccessControlPolicy
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__ns1__GetBucketAccessControlPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetBucketAccessControlPolicy() { _ns1__GetBucketAccessControlPolicy::soap_default(NULL); }
	virtual ~_ns1__GetBucketAccessControlPolicy() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse
#define SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse (50)
/* ns1:GetBucketAccessControlPolicyResponse */
class SOAP_CMAC _ns1__GetBucketAccessControlPolicyResponse
{
public:
	ns1__AccessControlPolicy *GetBucketAccessControlPolicyResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:AccessControlPolicy */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetBucketAccessControlPolicyResponse() { _ns1__GetBucketAccessControlPolicyResponse::soap_default(NULL); }
	virtual ~_ns1__GetBucketAccessControlPolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetObjectAccessControlPolicy
#define SOAP_TYPE__ns1__SetObjectAccessControlPolicy (51)
/* ns1:SetObjectAccessControlPolicy */
class SOAP_CMAC _ns1__SetObjectAccessControlPolicy
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	ns1__AccessControlList *AccessControlList;	/* required element of type ns1:AccessControlList */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__ns1__SetObjectAccessControlPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetObjectAccessControlPolicy() { _ns1__SetObjectAccessControlPolicy::soap_default(NULL); }
	virtual ~_ns1__SetObjectAccessControlPolicy() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse
#define SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse (52)
/* ns1:SetObjectAccessControlPolicyResponse */
class SOAP_CMAC _ns1__SetObjectAccessControlPolicyResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetObjectAccessControlPolicyResponse() { _ns1__SetObjectAccessControlPolicyResponse::soap_default(NULL); }
	virtual ~_ns1__SetObjectAccessControlPolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetBucketAccessControlPolicy
#define SOAP_TYPE__ns1__SetBucketAccessControlPolicy (53)
/* ns1:SetBucketAccessControlPolicy */
class SOAP_CMAC _ns1__SetBucketAccessControlPolicy
{
public:
	char *Bucket;	/* required element of type xsd:string */
	ns1__AccessControlList *AccessControlList;	/* optional element of type ns1:AccessControlList */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__ns1__SetBucketAccessControlPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetBucketAccessControlPolicy() { _ns1__SetBucketAccessControlPolicy::soap_default(NULL); }
	virtual ~_ns1__SetBucketAccessControlPolicy() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse
#define SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse (54)
/* ns1:SetBucketAccessControlPolicyResponse */
class SOAP_CMAC _ns1__SetBucketAccessControlPolicyResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetBucketAccessControlPolicyResponse() { _ns1__SetBucketAccessControlPolicyResponse::soap_default(NULL); }
	virtual ~_ns1__SetBucketAccessControlPolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetObject
#define SOAP_TYPE__ns1__GetObject (55)
/* ns1:GetObject */
class SOAP_CMAC _ns1__GetObject
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	bool GetMetadata;	/* required element of type xsd:boolean */
	bool GetData;	/* required element of type xsd:boolean */
	bool InlineData;	/* required element of type xsd:boolean */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns1__GetObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetObject() { _ns1__GetObject::soap_default(NULL); }
	virtual ~_ns1__GetObject() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetObjectResponse
#define SOAP_TYPE__ns1__GetObjectResponse (56)
/* ns1:GetObjectResponse */
class SOAP_CMAC _ns1__GetObjectResponse
{
public:
	class ns1__GetObjectResult *GetObjectResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:GetObjectResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns1__GetObjectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetObjectResponse() { _ns1__GetObjectResponse::soap_default(NULL); }
	virtual ~_ns1__GetObjectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetObjectExtended
#define SOAP_TYPE__ns1__GetObjectExtended (57)
/* ns1:GetObjectExtended */
class SOAP_CMAC _ns1__GetObjectExtended
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	bool GetMetadata;	/* required element of type xsd:boolean */
	bool GetData;	/* required element of type xsd:boolean */
	bool InlineData;	/* required element of type xsd:boolean */
	LONG64 *ByteRangeStart;	/* optional element of type xsd:long */
	LONG64 *ByteRangeEnd;	/* optional element of type xsd:long */
	time_t *IfModifiedSince;	/* optional element of type xsd:dateTime */
	time_t *IfUnmodifiedSince;	/* optional element of type xsd:dateTime */
	int __sizeIfMatch;	/* sequence of 0 to 100 elements <IfMatch> */
	char **IfMatch;	/* sequence of 0 to 100 elements */
	int __sizeIfNoneMatch;	/* sequence of 0 to 100 elements <IfNoneMatch> */
	char **IfNoneMatch;	/* sequence of 0 to 100 elements */
	bool *ReturnCompleteObjectOnConditionFailure;	/* optional element of type xsd:boolean */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns1__GetObjectExtended */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetObjectExtended() { _ns1__GetObjectExtended::soap_default(NULL); }
	virtual ~_ns1__GetObjectExtended() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetObjectExtendedResponse
#define SOAP_TYPE__ns1__GetObjectExtendedResponse (58)
/* ns1:GetObjectExtendedResponse */
class SOAP_CMAC _ns1__GetObjectExtendedResponse
{
public:
	ns1__GetObjectResult *GetObjectResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:GetObjectResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns1__GetObjectExtendedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetObjectExtendedResponse() { _ns1__GetObjectExtendedResponse::soap_default(NULL); }
	virtual ~_ns1__GetObjectExtendedResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PutObject
#define SOAP_TYPE__ns1__PutObject (59)
/* ns1:PutObject */
class SOAP_CMAC _ns1__PutObject
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	int __sizeMetadata;	/* sequence of 0 to 100 elements <Metadata> */
	ns1__MetadataEntry **Metadata;	/* sequence of 0 to 100 elements */
	LONG64 ContentLength;	/* required element of type xsd:long */
	ns1__AccessControlList *AccessControlList;	/* optional element of type ns1:AccessControlList */
	enum ns1__StorageClass *StorageClass;	/* optional element of type ns1:StorageClass */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__ns1__PutObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PutObject() { _ns1__PutObject::soap_default(NULL); }
	virtual ~_ns1__PutObject() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PutObjectResponse
#define SOAP_TYPE__ns1__PutObjectResponse (60)
/* ns1:PutObjectResponse */
class SOAP_CMAC _ns1__PutObjectResponse
{
public:
	ns1__PutObjectResult *PutObjectResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:PutObjectResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__ns1__PutObjectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PutObjectResponse() { _ns1__PutObjectResponse::soap_default(NULL); }
	virtual ~_ns1__PutObjectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PutObjectInline
#define SOAP_TYPE__ns1__PutObjectInline (61)
/* ns1:PutObjectInline */
class SOAP_CMAC _ns1__PutObjectInline
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	int __sizeMetadata;	/* sequence of 0 to 100 elements <Metadata> */
	ns1__MetadataEntry **Metadata;	/* sequence of 0 to 100 elements */
	xsd__base64Binary Data;	/* required element of type xsd:base64Binary */
	LONG64 ContentLength;	/* required element of type xsd:long */
	ns1__AccessControlList *AccessControlList;	/* optional element of type ns1:AccessControlList */
	enum ns1__StorageClass *StorageClass;	/* optional element of type ns1:StorageClass */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__ns1__PutObjectInline */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PutObjectInline() { _ns1__PutObjectInline::soap_default(NULL); }
	virtual ~_ns1__PutObjectInline() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PutObjectInlineResponse
#define SOAP_TYPE__ns1__PutObjectInlineResponse (62)
/* ns1:PutObjectInlineResponse */
class SOAP_CMAC _ns1__PutObjectInlineResponse
{
public:
	ns1__PutObjectResult *PutObjectInlineResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:PutObjectResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__ns1__PutObjectInlineResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PutObjectInlineResponse() { _ns1__PutObjectInlineResponse::soap_default(NULL); }
	virtual ~_ns1__PutObjectInlineResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteObject
#define SOAP_TYPE__ns1__DeleteObject (63)
/* ns1:DeleteObject */
class SOAP_CMAC _ns1__DeleteObject
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__ns1__DeleteObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteObject() { _ns1__DeleteObject::soap_default(NULL); }
	virtual ~_ns1__DeleteObject() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteObjectResponse
#define SOAP_TYPE__ns1__DeleteObjectResponse (64)
/* ns1:DeleteObjectResponse */
class SOAP_CMAC _ns1__DeleteObjectResponse
{
public:
	ns1__Status *DeleteObjectResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Status */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__ns1__DeleteObjectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteObjectResponse() { _ns1__DeleteObjectResponse::soap_default(NULL); }
	virtual ~_ns1__DeleteObjectResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ListBucket
#define SOAP_TYPE__ns1__ListBucket (65)
/* ns1:ListBucket */
class SOAP_CMAC _ns1__ListBucket
{
public:
	char *Bucket;	/* required element of type xsd:string */
	char *Prefix;	/* optional element of type xsd:string */
	char *Marker;	/* optional element of type xsd:string */
	int *MaxKeys;	/* optional element of type xsd:int */
	char *Delimiter;	/* optional element of type xsd:string */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__ns1__ListBucket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ListBucket() { _ns1__ListBucket::soap_default(NULL); }
	virtual ~_ns1__ListBucket() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ListBucketResponse
#define SOAP_TYPE__ns1__ListBucketResponse (66)
/* ns1:ListBucketResponse */
class SOAP_CMAC _ns1__ListBucketResponse
{
public:
	ns1__ListBucketResult *ListBucketResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ListBucketResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__ns1__ListBucketResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ListBucketResponse() { _ns1__ListBucketResponse::soap_default(NULL); }
	virtual ~_ns1__ListBucketResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ListAllMyBuckets
#define SOAP_TYPE__ns1__ListAllMyBuckets (67)
/* ns1:ListAllMyBuckets */
class SOAP_CMAC _ns1__ListAllMyBuckets
{
public:
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__ns1__ListAllMyBuckets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ListAllMyBuckets() { _ns1__ListAllMyBuckets::soap_default(NULL); }
	virtual ~_ns1__ListAllMyBuckets() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ListAllMyBucketsResponse
#define SOAP_TYPE__ns1__ListAllMyBucketsResponse (68)
/* ns1:ListAllMyBucketsResponse */
class SOAP_CMAC _ns1__ListAllMyBucketsResponse
{
public:
	ns1__ListAllMyBucketsResult *ListAllMyBucketsResponse;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ListAllMyBucketsResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__ns1__ListAllMyBucketsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ListAllMyBucketsResponse() { _ns1__ListAllMyBucketsResponse::soap_default(NULL); }
	virtual ~_ns1__ListAllMyBucketsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__PostResponse
#define SOAP_TYPE__ns1__PostResponse (69)
/* ns1:PostResponse */
class SOAP_CMAC _ns1__PostResponse
{
public:
	char *Location;	/* required element of type xsd:anyURI */
	char *Bucket;	/* required element of type xsd:string */
	char *Key;	/* required element of type xsd:string */
	char *ETag;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__ns1__PostResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__PostResponse() { _ns1__PostResponse::soap_default(NULL); }
	virtual ~_ns1__PostResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CopyObject
#define SOAP_TYPE__ns1__CopyObject (70)
/* ns1:CopyObject */
class SOAP_CMAC _ns1__CopyObject
{
public:
	char *SourceBucket;	/* required element of type xsd:string */
	char *SourceKey;	/* required element of type xsd:string */
	char *DestinationBucket;	/* required element of type xsd:string */
	char *DestinationKey;	/* required element of type xsd:string */
	enum ns1__MetadataDirective *MetadataDirective;	/* optional element of type ns1:MetadataDirective */
	int __sizeMetadata;	/* sequence of 0 to 100 elements <Metadata> */
	ns1__MetadataEntry **Metadata;	/* sequence of 0 to 100 elements */
	ns1__AccessControlList *AccessControlList;	/* optional element of type ns1:AccessControlList */
	time_t *CopySourceIfModifiedSince;	/* optional element of type xsd:dateTime */
	time_t *CopySourceIfUnmodifiedSince;	/* optional element of type xsd:dateTime */
	int __sizeCopySourceIfMatch;	/* sequence of 0 to 100 elements <CopySourceIfMatch> */
	char **CopySourceIfMatch;	/* sequence of 0 to 100 elements */
	int __sizeCopySourceIfNoneMatch;	/* sequence of 0 to 100 elements <CopySourceIfNoneMatch> */
	char **CopySourceIfNoneMatch;	/* sequence of 0 to 100 elements */
	enum ns1__StorageClass *StorageClass;	/* optional element of type ns1:StorageClass */
	char *AWSAccessKeyId;	/* optional element of type xsd:string */
	time_t *Timestamp;	/* optional element of type xsd:dateTime */
	char *Signature;	/* optional element of type xsd:string */
	char *Credential;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__ns1__CopyObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CopyObject() { _ns1__CopyObject::soap_default(NULL); }
	virtual ~_ns1__CopyObject() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CopyObjectResponse
#define SOAP_TYPE__ns1__CopyObjectResponse (71)
/* ns1:CopyObjectResponse */
class SOAP_CMAC _ns1__CopyObjectResponse
{
public:
	ns1__CopyObjectResult *CopyObjectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:CopyObjectResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE__ns1__CopyObjectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CopyObjectResponse() { _ns1__CopyObjectResponse::soap_default(NULL); }
	virtual ~_ns1__CopyObjectResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__User
#define SOAP_TYPE_ns1__User (20)
/* ns1:User */
class SOAP_CMAC ns1__User
{
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__User */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__User() { ns1__User::soap_default(NULL); }
	virtual ~ns1__User() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Group
#define SOAP_TYPE_ns1__Group (23)
/* ns1:Group */
class SOAP_CMAC ns1__Group
{
public:
	char *URI;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__Group */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Group() { ns1__Group::soap_default(NULL); }
	virtual ~ns1__Group() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LocationConstraint
#define SOAP_TYPE_ns1__LocationConstraint (27)
/* Primitive ns1:LocationConstraint schema type: */
class SOAP_CMAC ns1__LocationConstraint
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__LocationConstraint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LocationConstraint() { ns1__LocationConstraint::soap_default(NULL); }
	virtual ~ns1__LocationConstraint() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetObjectResult
#define SOAP_TYPE_ns1__GetObjectResult (29)
/* ns1:GetObjectResult */
class SOAP_CMAC ns1__GetObjectResult
{
public:
	ns1__Status *Status;	/* required element of type ns1:Status */
	int __sizeMetadata;	/* sequence of elements <Metadata> */
	ns1__MetadataEntry **Metadata;	/* optional element of type ns1:MetadataEntry */
	xsd__base64Binary *Data;	/* optional element of type xsd:base64Binary */
	time_t LastModified;	/* required element of type xsd:dateTime */
	char *ETag;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__GetObjectResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetObjectResult() { ns1__GetObjectResult::soap_default(NULL); }
	virtual ~ns1__GetObjectResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AmazonCustomerByEmail
#define SOAP_TYPE_ns1__AmazonCustomerByEmail (21)
/* ns1:AmazonCustomerByEmail */
class SOAP_CMAC ns1__AmazonCustomerByEmail
{
public:
	char *EmailAddress;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__AmazonCustomerByEmail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AmazonCustomerByEmail() { ns1__AmazonCustomerByEmail::soap_default(NULL); }
	virtual ~ns1__AmazonCustomerByEmail() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CanonicalUser
#define SOAP_TYPE_ns1__CanonicalUser (22)
/* ns1:CanonicalUser */
class SOAP_CMAC ns1__CanonicalUser
{
public:
	char *ID;	/* required element of type xsd:string */
	char *DisplayName;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__CanonicalUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CanonicalUser() { ns1__CanonicalUser::soap_default(NULL); }
	virtual ~ns1__CanonicalUser() { }
};
#endif

#ifndef SOAP_TYPE___ns1__CreateBucket
#define SOAP_TYPE___ns1__CreateBucket (115)
/* Operation wrapper: */
struct __ns1__CreateBucket
{
public:
	_ns1__CreateBucket *ns1__CreateBucket;	/* optional element of type ns1:CreateBucket */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteBucket
#define SOAP_TYPE___ns1__DeleteBucket (119)
/* Operation wrapper: */
struct __ns1__DeleteBucket
{
public:
	_ns1__DeleteBucket *ns1__DeleteBucket;	/* optional element of type ns1:DeleteBucket */
};
#endif

#ifndef SOAP_TYPE___ns1__GetObjectAccessControlPolicy
#define SOAP_TYPE___ns1__GetObjectAccessControlPolicy (123)
/* Operation wrapper: */
struct __ns1__GetObjectAccessControlPolicy
{
public:
	_ns1__GetObjectAccessControlPolicy *ns1__GetObjectAccessControlPolicy;	/* optional element of type ns1:GetObjectAccessControlPolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__GetBucketAccessControlPolicy
#define SOAP_TYPE___ns1__GetBucketAccessControlPolicy (127)
/* Operation wrapper: */
struct __ns1__GetBucketAccessControlPolicy
{
public:
	_ns1__GetBucketAccessControlPolicy *ns1__GetBucketAccessControlPolicy;	/* optional element of type ns1:GetBucketAccessControlPolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__SetObjectAccessControlPolicy
#define SOAP_TYPE___ns1__SetObjectAccessControlPolicy (131)
/* Operation wrapper: */
struct __ns1__SetObjectAccessControlPolicy
{
public:
	_ns1__SetObjectAccessControlPolicy *ns1__SetObjectAccessControlPolicy;	/* optional element of type ns1:SetObjectAccessControlPolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__SetBucketAccessControlPolicy
#define SOAP_TYPE___ns1__SetBucketAccessControlPolicy (135)
/* Operation wrapper: */
struct __ns1__SetBucketAccessControlPolicy
{
public:
	_ns1__SetBucketAccessControlPolicy *ns1__SetBucketAccessControlPolicy;	/* optional element of type ns1:SetBucketAccessControlPolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__GetObject
#define SOAP_TYPE___ns1__GetObject (139)
/* Operation wrapper: */
struct __ns1__GetObject
{
public:
	_ns1__GetObject *ns1__GetObject;	/* optional element of type ns1:GetObject */
};
#endif

#ifndef SOAP_TYPE___ns1__GetObjectExtended
#define SOAP_TYPE___ns1__GetObjectExtended (143)
/* Operation wrapper: */
struct __ns1__GetObjectExtended
{
public:
	_ns1__GetObjectExtended *ns1__GetObjectExtended;	/* optional element of type ns1:GetObjectExtended */
};
#endif

#ifndef SOAP_TYPE___ns1__PutObject
#define SOAP_TYPE___ns1__PutObject (147)
/* Operation wrapper: */
struct __ns1__PutObject
{
public:
	_ns1__PutObject *ns1__PutObject;	/* optional element of type ns1:PutObject */
};
#endif

#ifndef SOAP_TYPE___ns1__PutObjectInline
#define SOAP_TYPE___ns1__PutObjectInline (151)
/* Operation wrapper: */
struct __ns1__PutObjectInline
{
public:
	_ns1__PutObjectInline *ns1__PutObjectInline;	/* optional element of type ns1:PutObjectInline */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteObject
#define SOAP_TYPE___ns1__DeleteObject (155)
/* Operation wrapper: */
struct __ns1__DeleteObject
{
public:
	_ns1__DeleteObject *ns1__DeleteObject;	/* optional element of type ns1:DeleteObject */
};
#endif

#ifndef SOAP_TYPE___ns1__ListBucket
#define SOAP_TYPE___ns1__ListBucket (159)
/* Operation wrapper: */
struct __ns1__ListBucket
{
public:
	_ns1__ListBucket *ns1__ListBucket;	/* optional element of type ns1:ListBucket */
};
#endif

#ifndef SOAP_TYPE___ns1__ListAllMyBuckets
#define SOAP_TYPE___ns1__ListAllMyBuckets (163)
/* Operation wrapper: */
struct __ns1__ListAllMyBuckets
{
public:
	_ns1__ListAllMyBuckets *ns1__ListAllMyBuckets;	/* optional element of type ns1:ListAllMyBuckets */
};
#endif

#ifndef SOAP_TYPE___ns1__SetBucketLoggingStatus
#define SOAP_TYPE___ns1__SetBucketLoggingStatus (167)
/* Operation wrapper: */
struct __ns1__SetBucketLoggingStatus
{
public:
	_ns1__SetBucketLoggingStatus *ns1__SetBucketLoggingStatus;	/* optional element of type ns1:SetBucketLoggingStatus */
};
#endif

#ifndef SOAP_TYPE___ns1__GetBucketLoggingStatus
#define SOAP_TYPE___ns1__GetBucketLoggingStatus (171)
/* Operation wrapper: */
struct __ns1__GetBucketLoggingStatus
{
public:
	_ns1__GetBucketLoggingStatus *ns1__GetBucketLoggingStatus;	/* optional element of type ns1:GetBucketLoggingStatus */
};
#endif

#ifndef SOAP_TYPE___ns1__CopyObject
#define SOAP_TYPE___ns1__CopyObject (175)
/* Operation wrapper: */
struct __ns1__CopyObject
{
public:
	_ns1__CopyObject *ns1__CopyObject;	/* optional element of type ns1:CopyObject */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (176)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (177)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (179)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (182)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (183)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (12)
typedef char *xsd__anyURI;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
