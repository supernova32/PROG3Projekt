/* soapC.cpp
   Generated by gSOAP 2.8.4 from AmazonS3.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.4 2012-06-14 07:36:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__Payer:
		return soap_in_ns1__Payer(soap, NULL, NULL, "ns1:Payer");
	case SOAP_TYPE_ns1__MetadataDirective:
		return soap_in_ns1__MetadataDirective(soap, NULL, NULL, "ns1:MetadataDirective");
	case SOAP_TYPE_ns1__StorageClass:
		return soap_in_ns1__StorageClass(soap, NULL, NULL, "ns1:StorageClass");
	case SOAP_TYPE_ns1__Permission:
		return soap_in_ns1__Permission(soap, NULL, NULL, "ns1:Permission");
	case SOAP_TYPE_ns1__RequestPaymentConfiguration:
		return soap_in_ns1__RequestPaymentConfiguration(soap, NULL, NULL, "ns1:RequestPaymentConfiguration");
	case SOAP_TYPE_ns1__CopyObjectResult:
		return soap_in_ns1__CopyObjectResult(soap, NULL, NULL, "ns1:CopyObjectResult");
	case SOAP_TYPE_ns1__ListAllMyBucketsList:
		return soap_in_ns1__ListAllMyBucketsList(soap, NULL, NULL, "ns1:ListAllMyBucketsList");
	case SOAP_TYPE_ns1__ListAllMyBucketsResult:
		return soap_in_ns1__ListAllMyBucketsResult(soap, NULL, NULL, "ns1:ListAllMyBucketsResult");
	case SOAP_TYPE_ns1__ListAllMyBucketsEntry:
		return soap_in_ns1__ListAllMyBucketsEntry(soap, NULL, NULL, "ns1:ListAllMyBucketsEntry");
	case SOAP_TYPE_ns1__ListBucketResult:
		return soap_in_ns1__ListBucketResult(soap, NULL, NULL, "ns1:ListBucketResult");
	case SOAP_TYPE_ns1__PrefixEntry:
		return soap_in_ns1__PrefixEntry(soap, NULL, NULL, "ns1:PrefixEntry");
	case SOAP_TYPE_ns1__ListEntry:
		return soap_in_ns1__ListEntry(soap, NULL, NULL, "ns1:ListEntry");
	case SOAP_TYPE_ns1__PutObjectResult:
		return soap_in_ns1__PutObjectResult(soap, NULL, NULL, "ns1:PutObjectResult");
	case SOAP_TYPE_ns1__GetObjectResult:
		return soap_in_ns1__GetObjectResult(soap, NULL, NULL, "ns1:GetObjectResult");
	case SOAP_TYPE_ns1__AccessControlPolicy:
		return soap_in_ns1__AccessControlPolicy(soap, NULL, NULL, "ns1:AccessControlPolicy");
	case SOAP_TYPE_ns1__LocationConstraint:
		return soap_in_ns1__LocationConstraint(soap, NULL, NULL, "ns1:LocationConstraint");
	case SOAP_TYPE_ns1__CreateBucketConfiguration:
		return soap_in_ns1__CreateBucketConfiguration(soap, NULL, NULL, "ns1:CreateBucketConfiguration");
	case SOAP_TYPE_ns1__AccessControlList:
		return soap_in_ns1__AccessControlList(soap, NULL, NULL, "ns1:AccessControlList");
	case SOAP_TYPE_ns1__Grant:
		return soap_in_ns1__Grant(soap, NULL, NULL, "ns1:Grant");
	case SOAP_TYPE_ns1__Group:
		return soap_in_ns1__Group(soap, NULL, NULL, "ns1:Group");
	case SOAP_TYPE_ns1__CanonicalUser:
		return soap_in_ns1__CanonicalUser(soap, NULL, NULL, "ns1:CanonicalUser");
	case SOAP_TYPE_ns1__AmazonCustomerByEmail:
		return soap_in_ns1__AmazonCustomerByEmail(soap, NULL, NULL, "ns1:AmazonCustomerByEmail");
	case SOAP_TYPE_ns1__User:
		return soap_in_ns1__User(soap, NULL, NULL, "ns1:User");
	case SOAP_TYPE_ns1__Grantee:
		return soap_in_ns1__Grantee(soap, NULL, NULL, "ns1:Grantee");
	case SOAP_TYPE_ns1__LoggingSettings:
		return soap_in_ns1__LoggingSettings(soap, NULL, NULL, "ns1:LoggingSettings");
	case SOAP_TYPE_ns1__BucketLoggingStatus:
		return soap_in_ns1__BucketLoggingStatus(soap, NULL, NULL, "ns1:BucketLoggingStatus");
	case SOAP_TYPE_ns1__CreateBucketResult:
		return soap_in_ns1__CreateBucketResult(soap, NULL, NULL, "ns1:CreateBucketResult");
	case SOAP_TYPE_ns1__Result:
		return soap_in_ns1__Result(soap, NULL, NULL, "ns1:Result");
	case SOAP_TYPE_ns1__Status:
		return soap_in_ns1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_ns1__MetadataEntry:
		return soap_in_ns1__MetadataEntry(soap, NULL, NULL, "ns1:MetadataEntry");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__CopyObjectResponse:
		return soap_in_PointerTo_ns1__CopyObjectResponse(soap, NULL, NULL, "ns1:CopyObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__CopyObject:
		return soap_in_PointerTo_ns1__CopyObject(soap, NULL, NULL, "ns1:CopyObject");
	case SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatusResponse:
		return soap_in_PointerTo_ns1__GetBucketLoggingStatusResponse(soap, NULL, NULL, "ns1:GetBucketLoggingStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatus:
		return soap_in_PointerTo_ns1__GetBucketLoggingStatus(soap, NULL, NULL, "ns1:GetBucketLoggingStatus");
	case SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatusResponse:
		return soap_in_PointerTo_ns1__SetBucketLoggingStatusResponse(soap, NULL, NULL, "ns1:SetBucketLoggingStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatus:
		return soap_in_PointerTo_ns1__SetBucketLoggingStatus(soap, NULL, NULL, "ns1:SetBucketLoggingStatus");
	case SOAP_TYPE_PointerTo_ns1__ListAllMyBucketsResponse:
		return soap_in_PointerTo_ns1__ListAllMyBucketsResponse(soap, NULL, NULL, "ns1:ListAllMyBucketsResponse");
	case SOAP_TYPE_PointerTo_ns1__ListAllMyBuckets:
		return soap_in_PointerTo_ns1__ListAllMyBuckets(soap, NULL, NULL, "ns1:ListAllMyBuckets");
	case SOAP_TYPE_PointerTo_ns1__ListBucketResponse:
		return soap_in_PointerTo_ns1__ListBucketResponse(soap, NULL, NULL, "ns1:ListBucketResponse");
	case SOAP_TYPE_PointerTo_ns1__ListBucket:
		return soap_in_PointerTo_ns1__ListBucket(soap, NULL, NULL, "ns1:ListBucket");
	case SOAP_TYPE_PointerTo_ns1__DeleteObjectResponse:
		return soap_in_PointerTo_ns1__DeleteObjectResponse(soap, NULL, NULL, "ns1:DeleteObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteObject:
		return soap_in_PointerTo_ns1__DeleteObject(soap, NULL, NULL, "ns1:DeleteObject");
	case SOAP_TYPE_PointerTo_ns1__PutObjectInlineResponse:
		return soap_in_PointerTo_ns1__PutObjectInlineResponse(soap, NULL, NULL, "ns1:PutObjectInlineResponse");
	case SOAP_TYPE_PointerTo_ns1__PutObjectInline:
		return soap_in_PointerTo_ns1__PutObjectInline(soap, NULL, NULL, "ns1:PutObjectInline");
	case SOAP_TYPE_PointerTo_ns1__PutObjectResponse:
		return soap_in_PointerTo_ns1__PutObjectResponse(soap, NULL, NULL, "ns1:PutObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__PutObject:
		return soap_in_PointerTo_ns1__PutObject(soap, NULL, NULL, "ns1:PutObject");
	case SOAP_TYPE_PointerTo_ns1__GetObjectExtendedResponse:
		return soap_in_PointerTo_ns1__GetObjectExtendedResponse(soap, NULL, NULL, "ns1:GetObjectExtendedResponse");
	case SOAP_TYPE_PointerTo_ns1__GetObjectExtended:
		return soap_in_PointerTo_ns1__GetObjectExtended(soap, NULL, NULL, "ns1:GetObjectExtended");
	case SOAP_TYPE_PointerTo_ns1__GetObjectResponse:
		return soap_in_PointerTo_ns1__GetObjectResponse(soap, NULL, NULL, "ns1:GetObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__GetObject:
		return soap_in_PointerTo_ns1__GetObject(soap, NULL, NULL, "ns1:GetObject");
	case SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicyResponse:
		return soap_in_PointerTo_ns1__SetBucketAccessControlPolicyResponse(soap, NULL, NULL, "ns1:SetBucketAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicy:
		return soap_in_PointerTo_ns1__SetBucketAccessControlPolicy(soap, NULL, NULL, "ns1:SetBucketAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicyResponse:
		return soap_in_PointerTo_ns1__SetObjectAccessControlPolicyResponse(soap, NULL, NULL, "ns1:SetObjectAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicy:
		return soap_in_PointerTo_ns1__SetObjectAccessControlPolicy(soap, NULL, NULL, "ns1:SetObjectAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicyResponse:
		return soap_in_PointerTo_ns1__GetBucketAccessControlPolicyResponse(soap, NULL, NULL, "ns1:GetBucketAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicy:
		return soap_in_PointerTo_ns1__GetBucketAccessControlPolicy(soap, NULL, NULL, "ns1:GetBucketAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicyResponse:
		return soap_in_PointerTo_ns1__GetObjectAccessControlPolicyResponse(soap, NULL, NULL, "ns1:GetObjectAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicy:
		return soap_in_PointerTo_ns1__GetObjectAccessControlPolicy(soap, NULL, NULL, "ns1:GetObjectAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__DeleteBucketResponse:
		return soap_in_PointerTo_ns1__DeleteBucketResponse(soap, NULL, NULL, "ns1:DeleteBucketResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteBucket:
		return soap_in_PointerTo_ns1__DeleteBucket(soap, NULL, NULL, "ns1:DeleteBucket");
	case SOAP_TYPE_PointerTo_ns1__CreateBucketResponse:
		return soap_in_PointerTo_ns1__CreateBucketResponse(soap, NULL, NULL, "ns1:CreateBucketResponse");
	case SOAP_TYPE_PointerTo_ns1__CreateBucket:
		return soap_in_PointerTo_ns1__CreateBucket(soap, NULL, NULL, "ns1:CreateBucket");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__CopyObjectResult:
		return soap_in_PointerTons1__CopyObjectResult(soap, NULL, NULL, "ns1:CopyObjectResult");
	case SOAP_TYPE_PointerTons1__MetadataDirective:
		return soap_in_PointerTons1__MetadataDirective(soap, NULL, NULL, "ns1:MetadataDirective");
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsResult:
		return soap_in_PointerTons1__ListAllMyBucketsResult(soap, NULL, NULL, "ns1:ListAllMyBucketsResult");
	case SOAP_TYPE_PointerTons1__ListBucketResult:
		return soap_in_PointerTons1__ListBucketResult(soap, NULL, NULL, "ns1:ListBucketResult");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons1__PutObjectResult:
		return soap_in_PointerTons1__PutObjectResult(soap, NULL, NULL, "ns1:PutObjectResult");
	case SOAP_TYPE_PointerTons1__StorageClass:
		return soap_in_PointerTons1__StorageClass(soap, NULL, NULL, "ns1:StorageClass");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons1__GetObjectResult:
		return soap_in_PointerTons1__GetObjectResult(soap, NULL, NULL, "ns1:GetObjectResult");
	case SOAP_TYPE_PointerTons1__AccessControlPolicy:
		return soap_in_PointerTons1__AccessControlPolicy(soap, NULL, NULL, "ns1:AccessControlPolicy");
	case SOAP_TYPE_PointerTons1__BucketLoggingStatus:
		return soap_in_PointerTons1__BucketLoggingStatus(soap, NULL, NULL, "ns1:BucketLoggingStatus");
	case SOAP_TYPE_PointerTons1__CreateBucketResult:
		return soap_in_PointerTons1__CreateBucketResult(soap, NULL, NULL, "ns1:CreateBucketResult");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsEntry:
		return soap_in_PointerTons1__ListAllMyBucketsEntry(soap, NULL, NULL, "ns1:ListAllMyBucketsEntry");
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsList:
		return soap_in_PointerTons1__ListAllMyBucketsList(soap, NULL, NULL, "ns1:ListAllMyBucketsList");
	case SOAP_TYPE_PointerTons1__PrefixEntry:
		return soap_in_PointerTons1__PrefixEntry(soap, NULL, NULL, "ns1:PrefixEntry");
	case SOAP_TYPE_PointerTons1__ListEntry:
		return soap_in_PointerTons1__ListEntry(soap, NULL, NULL, "ns1:ListEntry");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__MetadataEntry:
		return soap_in_PointerTons1__MetadataEntry(soap, NULL, NULL, "ns1:MetadataEntry");
	case SOAP_TYPE_PointerTons1__CanonicalUser:
		return soap_in_PointerTons1__CanonicalUser(soap, NULL, NULL, "ns1:CanonicalUser");
	case SOAP_TYPE_PointerTons1__LocationConstraint:
		return soap_in_PointerTons1__LocationConstraint(soap, NULL, NULL, "ns1:LocationConstraint");
	case SOAP_TYPE_PointerTons1__Grant:
		return soap_in_PointerTons1__Grant(soap, NULL, NULL, "ns1:Grant");
	case SOAP_TYPE_PointerTons1__Grantee:
		return soap_in_PointerTons1__Grantee(soap, NULL, NULL, "ns1:Grantee");
	case SOAP_TYPE_PointerTons1__AccessControlList:
		return soap_in_PointerTons1__AccessControlList(soap, NULL, NULL, "ns1:AccessControlList");
	case SOAP_TYPE_PointerTons1__LoggingSettings:
		return soap_in_PointerTons1__LoggingSettings(soap, NULL, NULL, "ns1:LoggingSettings");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_in_PointerTons1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:RequestPaymentConfiguration"))
		{	*type = SOAP_TYPE_ns1__RequestPaymentConfiguration;
			return soap_in_ns1__RequestPaymentConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CopyObjectResult"))
		{	*type = SOAP_TYPE_ns1__CopyObjectResult;
			return soap_in_ns1__CopyObjectResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListAllMyBucketsList"))
		{	*type = SOAP_TYPE_ns1__ListAllMyBucketsList;
			return soap_in_ns1__ListAllMyBucketsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListAllMyBucketsResult"))
		{	*type = SOAP_TYPE_ns1__ListAllMyBucketsResult;
			return soap_in_ns1__ListAllMyBucketsResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListAllMyBucketsEntry"))
		{	*type = SOAP_TYPE_ns1__ListAllMyBucketsEntry;
			return soap_in_ns1__ListAllMyBucketsEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListBucketResult"))
		{	*type = SOAP_TYPE_ns1__ListBucketResult;
			return soap_in_ns1__ListBucketResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PrefixEntry"))
		{	*type = SOAP_TYPE_ns1__PrefixEntry;
			return soap_in_ns1__PrefixEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListEntry"))
		{	*type = SOAP_TYPE_ns1__ListEntry;
			return soap_in_ns1__ListEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PutObjectResult"))
		{	*type = SOAP_TYPE_ns1__PutObjectResult;
			return soap_in_ns1__PutObjectResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObjectResult"))
		{	*type = SOAP_TYPE_ns1__GetObjectResult;
			return soap_in_ns1__GetObjectResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessControlPolicy"))
		{	*type = SOAP_TYPE_ns1__AccessControlPolicy;
			return soap_in_ns1__AccessControlPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LocationConstraint"))
		{	*type = SOAP_TYPE_ns1__LocationConstraint;
			return soap_in_ns1__LocationConstraint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateBucketConfiguration"))
		{	*type = SOAP_TYPE_ns1__CreateBucketConfiguration;
			return soap_in_ns1__CreateBucketConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccessControlList"))
		{	*type = SOAP_TYPE_ns1__AccessControlList;
			return soap_in_ns1__AccessControlList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Grant"))
		{	*type = SOAP_TYPE_ns1__Grant;
			return soap_in_ns1__Grant(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Group"))
		{	*type = SOAP_TYPE_ns1__Group;
			return soap_in_ns1__Group(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CanonicalUser"))
		{	*type = SOAP_TYPE_ns1__CanonicalUser;
			return soap_in_ns1__CanonicalUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AmazonCustomerByEmail"))
		{	*type = SOAP_TYPE_ns1__AmazonCustomerByEmail;
			return soap_in_ns1__AmazonCustomerByEmail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:User"))
		{	*type = SOAP_TYPE_ns1__User;
			return soap_in_ns1__User(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Grantee"))
		{	*type = SOAP_TYPE_ns1__Grantee;
			return soap_in_ns1__Grantee(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoggingSettings"))
		{	*type = SOAP_TYPE_ns1__LoggingSettings;
			return soap_in_ns1__LoggingSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BucketLoggingStatus"))
		{	*type = SOAP_TYPE_ns1__BucketLoggingStatus;
			return soap_in_ns1__BucketLoggingStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateBucketResult"))
		{	*type = SOAP_TYPE_ns1__CreateBucketResult;
			return soap_in_ns1__CreateBucketResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Result"))
		{	*type = SOAP_TYPE_ns1__Result;
			return soap_in_ns1__Result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Status"))
		{	*type = SOAP_TYPE_ns1__Status;
			return soap_in_ns1__Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MetadataEntry"))
		{	*type = SOAP_TYPE_ns1__MetadataEntry;
			return soap_in_ns1__MetadataEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Payer"))
		{	*type = SOAP_TYPE_ns1__Payer;
			return soap_in_ns1__Payer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MetadataDirective"))
		{	*type = SOAP_TYPE_ns1__MetadataDirective;
			return soap_in_ns1__MetadataDirective(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StorageClass"))
		{	*type = SOAP_TYPE_ns1__StorageClass;
			return soap_in_ns1__StorageClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Permission"))
		{	*type = SOAP_TYPE_ns1__Permission;
			return soap_in_ns1__Permission(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:CopyObjectResponse"))
		{	*type = SOAP_TYPE__ns1__CopyObjectResponse;
			return soap_in__ns1__CopyObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CopyObject"))
		{	*type = SOAP_TYPE__ns1__CopyObject;
			return soap_in__ns1__CopyObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PostResponse"))
		{	*type = SOAP_TYPE__ns1__PostResponse;
			return soap_in__ns1__PostResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListAllMyBucketsResponse"))
		{	*type = SOAP_TYPE__ns1__ListAllMyBucketsResponse;
			return soap_in__ns1__ListAllMyBucketsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListAllMyBuckets"))
		{	*type = SOAP_TYPE__ns1__ListAllMyBuckets;
			return soap_in__ns1__ListAllMyBuckets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListBucketResponse"))
		{	*type = SOAP_TYPE__ns1__ListBucketResponse;
			return soap_in__ns1__ListBucketResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ListBucket"))
		{	*type = SOAP_TYPE__ns1__ListBucket;
			return soap_in__ns1__ListBucket(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteObjectResponse"))
		{	*type = SOAP_TYPE__ns1__DeleteObjectResponse;
			return soap_in__ns1__DeleteObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteObject"))
		{	*type = SOAP_TYPE__ns1__DeleteObject;
			return soap_in__ns1__DeleteObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PutObjectInlineResponse"))
		{	*type = SOAP_TYPE__ns1__PutObjectInlineResponse;
			return soap_in__ns1__PutObjectInlineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PutObjectInline"))
		{	*type = SOAP_TYPE__ns1__PutObjectInline;
			return soap_in__ns1__PutObjectInline(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PutObjectResponse"))
		{	*type = SOAP_TYPE__ns1__PutObjectResponse;
			return soap_in__ns1__PutObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PutObject"))
		{	*type = SOAP_TYPE__ns1__PutObject;
			return soap_in__ns1__PutObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObjectExtendedResponse"))
		{	*type = SOAP_TYPE__ns1__GetObjectExtendedResponse;
			return soap_in__ns1__GetObjectExtendedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObjectExtended"))
		{	*type = SOAP_TYPE__ns1__GetObjectExtended;
			return soap_in__ns1__GetObjectExtended(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObjectResponse"))
		{	*type = SOAP_TYPE__ns1__GetObjectResponse;
			return soap_in__ns1__GetObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObject"))
		{	*type = SOAP_TYPE__ns1__GetObject;
			return soap_in__ns1__GetObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetBucketAccessControlPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse;
			return soap_in__ns1__SetBucketAccessControlPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetBucketAccessControlPolicy"))
		{	*type = SOAP_TYPE__ns1__SetBucketAccessControlPolicy;
			return soap_in__ns1__SetBucketAccessControlPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetObjectAccessControlPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse;
			return soap_in__ns1__SetObjectAccessControlPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetObjectAccessControlPolicy"))
		{	*type = SOAP_TYPE__ns1__SetObjectAccessControlPolicy;
			return soap_in__ns1__SetObjectAccessControlPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBucketAccessControlPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse;
			return soap_in__ns1__GetBucketAccessControlPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBucketAccessControlPolicy"))
		{	*type = SOAP_TYPE__ns1__GetBucketAccessControlPolicy;
			return soap_in__ns1__GetBucketAccessControlPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObjectAccessControlPolicyResponse"))
		{	*type = SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse;
			return soap_in__ns1__GetObjectAccessControlPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetObjectAccessControlPolicy"))
		{	*type = SOAP_TYPE__ns1__GetObjectAccessControlPolicy;
			return soap_in__ns1__GetObjectAccessControlPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetBucketLoggingStatusResponse"))
		{	*type = SOAP_TYPE__ns1__SetBucketLoggingStatusResponse;
			return soap_in__ns1__SetBucketLoggingStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetBucketLoggingStatus"))
		{	*type = SOAP_TYPE__ns1__SetBucketLoggingStatus;
			return soap_in__ns1__SetBucketLoggingStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBucketLoggingStatusResponse"))
		{	*type = SOAP_TYPE__ns1__GetBucketLoggingStatusResponse;
			return soap_in__ns1__GetBucketLoggingStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetBucketLoggingStatus"))
		{	*type = SOAP_TYPE__ns1__GetBucketLoggingStatus;
			return soap_in__ns1__GetBucketLoggingStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteBucketResponse"))
		{	*type = SOAP_TYPE__ns1__DeleteBucketResponse;
			return soap_in__ns1__DeleteBucketResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeleteBucket"))
		{	*type = SOAP_TYPE__ns1__DeleteBucket;
			return soap_in__ns1__DeleteBucket(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateBucketResponse"))
		{	*type = SOAP_TYPE__ns1__CreateBucketResponse;
			return soap_in__ns1__CreateBucketResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CreateBucket"))
		{	*type = SOAP_TYPE__ns1__CreateBucket;
			return soap_in__ns1__CreateBucket(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__Payer:
		return soap_out_ns1__Payer(soap, tag, id, (const enum ns1__Payer *)ptr, "ns1:Payer");
	case SOAP_TYPE_ns1__MetadataDirective:
		return soap_out_ns1__MetadataDirective(soap, tag, id, (const enum ns1__MetadataDirective *)ptr, "ns1:MetadataDirective");
	case SOAP_TYPE_ns1__StorageClass:
		return soap_out_ns1__StorageClass(soap, tag, id, (const enum ns1__StorageClass *)ptr, "ns1:StorageClass");
	case SOAP_TYPE_ns1__Permission:
		return soap_out_ns1__Permission(soap, tag, id, (const enum ns1__Permission *)ptr, "ns1:Permission");
	case SOAP_TYPE__ns1__CopyObjectResponse:
		return ((_ns1__CopyObjectResponse *)ptr)->soap_out(soap, "ns1:CopyObjectResponse", id, NULL);
	case SOAP_TYPE__ns1__CopyObject:
		return ((_ns1__CopyObject *)ptr)->soap_out(soap, "ns1:CopyObject", id, NULL);
	case SOAP_TYPE__ns1__PostResponse:
		return ((_ns1__PostResponse *)ptr)->soap_out(soap, "ns1:PostResponse", id, NULL);
	case SOAP_TYPE__ns1__ListAllMyBucketsResponse:
		return ((_ns1__ListAllMyBucketsResponse *)ptr)->soap_out(soap, "ns1:ListAllMyBucketsResponse", id, NULL);
	case SOAP_TYPE__ns1__ListAllMyBuckets:
		return ((_ns1__ListAllMyBuckets *)ptr)->soap_out(soap, "ns1:ListAllMyBuckets", id, NULL);
	case SOAP_TYPE__ns1__ListBucketResponse:
		return ((_ns1__ListBucketResponse *)ptr)->soap_out(soap, "ns1:ListBucketResponse", id, NULL);
	case SOAP_TYPE__ns1__ListBucket:
		return ((_ns1__ListBucket *)ptr)->soap_out(soap, "ns1:ListBucket", id, NULL);
	case SOAP_TYPE__ns1__DeleteObjectResponse:
		return ((_ns1__DeleteObjectResponse *)ptr)->soap_out(soap, "ns1:DeleteObjectResponse", id, NULL);
	case SOAP_TYPE__ns1__DeleteObject:
		return ((_ns1__DeleteObject *)ptr)->soap_out(soap, "ns1:DeleteObject", id, NULL);
	case SOAP_TYPE__ns1__PutObjectInlineResponse:
		return ((_ns1__PutObjectInlineResponse *)ptr)->soap_out(soap, "ns1:PutObjectInlineResponse", id, NULL);
	case SOAP_TYPE__ns1__PutObjectInline:
		return ((_ns1__PutObjectInline *)ptr)->soap_out(soap, "ns1:PutObjectInline", id, NULL);
	case SOAP_TYPE__ns1__PutObjectResponse:
		return ((_ns1__PutObjectResponse *)ptr)->soap_out(soap, "ns1:PutObjectResponse", id, NULL);
	case SOAP_TYPE__ns1__PutObject:
		return ((_ns1__PutObject *)ptr)->soap_out(soap, "ns1:PutObject", id, NULL);
	case SOAP_TYPE__ns1__GetObjectExtendedResponse:
		return ((_ns1__GetObjectExtendedResponse *)ptr)->soap_out(soap, "ns1:GetObjectExtendedResponse", id, NULL);
	case SOAP_TYPE__ns1__GetObjectExtended:
		return ((_ns1__GetObjectExtended *)ptr)->soap_out(soap, "ns1:GetObjectExtended", id, NULL);
	case SOAP_TYPE__ns1__GetObjectResponse:
		return ((_ns1__GetObjectResponse *)ptr)->soap_out(soap, "ns1:GetObjectResponse", id, NULL);
	case SOAP_TYPE__ns1__GetObject:
		return ((_ns1__GetObject *)ptr)->soap_out(soap, "ns1:GetObject", id, NULL);
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse:
		return ((_ns1__SetBucketAccessControlPolicyResponse *)ptr)->soap_out(soap, "ns1:SetBucketAccessControlPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicy:
		return ((_ns1__SetBucketAccessControlPolicy *)ptr)->soap_out(soap, "ns1:SetBucketAccessControlPolicy", id, NULL);
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse:
		return ((_ns1__SetObjectAccessControlPolicyResponse *)ptr)->soap_out(soap, "ns1:SetObjectAccessControlPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicy:
		return ((_ns1__SetObjectAccessControlPolicy *)ptr)->soap_out(soap, "ns1:SetObjectAccessControlPolicy", id, NULL);
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse:
		return ((_ns1__GetBucketAccessControlPolicyResponse *)ptr)->soap_out(soap, "ns1:GetBucketAccessControlPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicy:
		return ((_ns1__GetBucketAccessControlPolicy *)ptr)->soap_out(soap, "ns1:GetBucketAccessControlPolicy", id, NULL);
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse:
		return ((_ns1__GetObjectAccessControlPolicyResponse *)ptr)->soap_out(soap, "ns1:GetObjectAccessControlPolicyResponse", id, NULL);
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicy:
		return ((_ns1__GetObjectAccessControlPolicy *)ptr)->soap_out(soap, "ns1:GetObjectAccessControlPolicy", id, NULL);
	case SOAP_TYPE__ns1__SetBucketLoggingStatusResponse:
		return ((_ns1__SetBucketLoggingStatusResponse *)ptr)->soap_out(soap, "ns1:SetBucketLoggingStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__SetBucketLoggingStatus:
		return ((_ns1__SetBucketLoggingStatus *)ptr)->soap_out(soap, "ns1:SetBucketLoggingStatus", id, NULL);
	case SOAP_TYPE__ns1__GetBucketLoggingStatusResponse:
		return ((_ns1__GetBucketLoggingStatusResponse *)ptr)->soap_out(soap, "ns1:GetBucketLoggingStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__GetBucketLoggingStatus:
		return ((_ns1__GetBucketLoggingStatus *)ptr)->soap_out(soap, "ns1:GetBucketLoggingStatus", id, NULL);
	case SOAP_TYPE__ns1__DeleteBucketResponse:
		return ((_ns1__DeleteBucketResponse *)ptr)->soap_out(soap, "ns1:DeleteBucketResponse", id, NULL);
	case SOAP_TYPE__ns1__DeleteBucket:
		return ((_ns1__DeleteBucket *)ptr)->soap_out(soap, "ns1:DeleteBucket", id, NULL);
	case SOAP_TYPE__ns1__CreateBucketResponse:
		return ((_ns1__CreateBucketResponse *)ptr)->soap_out(soap, "ns1:CreateBucketResponse", id, NULL);
	case SOAP_TYPE__ns1__CreateBucket:
		return ((_ns1__CreateBucket *)ptr)->soap_out(soap, "ns1:CreateBucket", id, NULL);
	case SOAP_TYPE_ns1__RequestPaymentConfiguration:
		return ((ns1__RequestPaymentConfiguration *)ptr)->soap_out(soap, tag, id, "ns1:RequestPaymentConfiguration");
	case SOAP_TYPE_ns1__CopyObjectResult:
		return ((ns1__CopyObjectResult *)ptr)->soap_out(soap, tag, id, "ns1:CopyObjectResult");
	case SOAP_TYPE_ns1__ListAllMyBucketsList:
		return ((ns1__ListAllMyBucketsList *)ptr)->soap_out(soap, tag, id, "ns1:ListAllMyBucketsList");
	case SOAP_TYPE_ns1__ListAllMyBucketsResult:
		return ((ns1__ListAllMyBucketsResult *)ptr)->soap_out(soap, tag, id, "ns1:ListAllMyBucketsResult");
	case SOAP_TYPE_ns1__ListAllMyBucketsEntry:
		return ((ns1__ListAllMyBucketsEntry *)ptr)->soap_out(soap, tag, id, "ns1:ListAllMyBucketsEntry");
	case SOAP_TYPE_ns1__ListBucketResult:
		return ((ns1__ListBucketResult *)ptr)->soap_out(soap, tag, id, "ns1:ListBucketResult");
	case SOAP_TYPE_ns1__PrefixEntry:
		return ((ns1__PrefixEntry *)ptr)->soap_out(soap, tag, id, "ns1:PrefixEntry");
	case SOAP_TYPE_ns1__ListEntry:
		return ((ns1__ListEntry *)ptr)->soap_out(soap, tag, id, "ns1:ListEntry");
	case SOAP_TYPE_ns1__PutObjectResult:
		return ((ns1__PutObjectResult *)ptr)->soap_out(soap, tag, id, "ns1:PutObjectResult");
	case SOAP_TYPE_ns1__GetObjectResult:
		return ((ns1__GetObjectResult *)ptr)->soap_out(soap, tag, id, "ns1:GetObjectResult");
	case SOAP_TYPE_ns1__AccessControlPolicy:
		return ((ns1__AccessControlPolicy *)ptr)->soap_out(soap, tag, id, "ns1:AccessControlPolicy");
	case SOAP_TYPE_ns1__LocationConstraint:
		return ((ns1__LocationConstraint *)ptr)->soap_out(soap, tag, id, "ns1:LocationConstraint");
	case SOAP_TYPE_ns1__CreateBucketConfiguration:
		return ((ns1__CreateBucketConfiguration *)ptr)->soap_out(soap, tag, id, "ns1:CreateBucketConfiguration");
	case SOAP_TYPE_ns1__AccessControlList:
		return ((ns1__AccessControlList *)ptr)->soap_out(soap, tag, id, "ns1:AccessControlList");
	case SOAP_TYPE_ns1__Grant:
		return ((ns1__Grant *)ptr)->soap_out(soap, tag, id, "ns1:Grant");
	case SOAP_TYPE_ns1__Group:
		return ((ns1__Group *)ptr)->soap_out(soap, tag, id, "ns1:Group");
	case SOAP_TYPE_ns1__CanonicalUser:
		return ((ns1__CanonicalUser *)ptr)->soap_out(soap, tag, id, "ns1:CanonicalUser");
	case SOAP_TYPE_ns1__AmazonCustomerByEmail:
		return ((ns1__AmazonCustomerByEmail *)ptr)->soap_out(soap, tag, id, "ns1:AmazonCustomerByEmail");
	case SOAP_TYPE_ns1__User:
		return ((ns1__User *)ptr)->soap_out(soap, tag, id, "ns1:User");
	case SOAP_TYPE_ns1__Grantee:
		return ((ns1__Grantee *)ptr)->soap_out(soap, tag, id, "ns1:Grantee");
	case SOAP_TYPE_ns1__LoggingSettings:
		return ((ns1__LoggingSettings *)ptr)->soap_out(soap, tag, id, "ns1:LoggingSettings");
	case SOAP_TYPE_ns1__BucketLoggingStatus:
		return ((ns1__BucketLoggingStatus *)ptr)->soap_out(soap, tag, id, "ns1:BucketLoggingStatus");
	case SOAP_TYPE_ns1__CreateBucketResult:
		return ((ns1__CreateBucketResult *)ptr)->soap_out(soap, tag, id, "ns1:CreateBucketResult");
	case SOAP_TYPE_ns1__Result:
		return ((ns1__Result *)ptr)->soap_out(soap, tag, id, "ns1:Result");
	case SOAP_TYPE_ns1__Status:
		return ((ns1__Status *)ptr)->soap_out(soap, tag, id, "ns1:Status");
	case SOAP_TYPE_ns1__MetadataEntry:
		return ((ns1__MetadataEntry *)ptr)->soap_out(soap, tag, id, "ns1:MetadataEntry");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__CopyObjectResponse:
		return soap_out_PointerTo_ns1__CopyObjectResponse(soap, tag, id, (_ns1__CopyObjectResponse *const*)ptr, "ns1:CopyObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__CopyObject:
		return soap_out_PointerTo_ns1__CopyObject(soap, tag, id, (_ns1__CopyObject *const*)ptr, "ns1:CopyObject");
	case SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatusResponse:
		return soap_out_PointerTo_ns1__GetBucketLoggingStatusResponse(soap, tag, id, (_ns1__GetBucketLoggingStatusResponse *const*)ptr, "ns1:GetBucketLoggingStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatus:
		return soap_out_PointerTo_ns1__GetBucketLoggingStatus(soap, tag, id, (_ns1__GetBucketLoggingStatus *const*)ptr, "ns1:GetBucketLoggingStatus");
	case SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatusResponse:
		return soap_out_PointerTo_ns1__SetBucketLoggingStatusResponse(soap, tag, id, (_ns1__SetBucketLoggingStatusResponse *const*)ptr, "ns1:SetBucketLoggingStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatus:
		return soap_out_PointerTo_ns1__SetBucketLoggingStatus(soap, tag, id, (_ns1__SetBucketLoggingStatus *const*)ptr, "ns1:SetBucketLoggingStatus");
	case SOAP_TYPE_PointerTo_ns1__ListAllMyBucketsResponse:
		return soap_out_PointerTo_ns1__ListAllMyBucketsResponse(soap, tag, id, (_ns1__ListAllMyBucketsResponse *const*)ptr, "ns1:ListAllMyBucketsResponse");
	case SOAP_TYPE_PointerTo_ns1__ListAllMyBuckets:
		return soap_out_PointerTo_ns1__ListAllMyBuckets(soap, tag, id, (_ns1__ListAllMyBuckets *const*)ptr, "ns1:ListAllMyBuckets");
	case SOAP_TYPE_PointerTo_ns1__ListBucketResponse:
		return soap_out_PointerTo_ns1__ListBucketResponse(soap, tag, id, (_ns1__ListBucketResponse *const*)ptr, "ns1:ListBucketResponse");
	case SOAP_TYPE_PointerTo_ns1__ListBucket:
		return soap_out_PointerTo_ns1__ListBucket(soap, tag, id, (_ns1__ListBucket *const*)ptr, "ns1:ListBucket");
	case SOAP_TYPE_PointerTo_ns1__DeleteObjectResponse:
		return soap_out_PointerTo_ns1__DeleteObjectResponse(soap, tag, id, (_ns1__DeleteObjectResponse *const*)ptr, "ns1:DeleteObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteObject:
		return soap_out_PointerTo_ns1__DeleteObject(soap, tag, id, (_ns1__DeleteObject *const*)ptr, "ns1:DeleteObject");
	case SOAP_TYPE_PointerTo_ns1__PutObjectInlineResponse:
		return soap_out_PointerTo_ns1__PutObjectInlineResponse(soap, tag, id, (_ns1__PutObjectInlineResponse *const*)ptr, "ns1:PutObjectInlineResponse");
	case SOAP_TYPE_PointerTo_ns1__PutObjectInline:
		return soap_out_PointerTo_ns1__PutObjectInline(soap, tag, id, (_ns1__PutObjectInline *const*)ptr, "ns1:PutObjectInline");
	case SOAP_TYPE_PointerTo_ns1__PutObjectResponse:
		return soap_out_PointerTo_ns1__PutObjectResponse(soap, tag, id, (_ns1__PutObjectResponse *const*)ptr, "ns1:PutObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__PutObject:
		return soap_out_PointerTo_ns1__PutObject(soap, tag, id, (_ns1__PutObject *const*)ptr, "ns1:PutObject");
	case SOAP_TYPE_PointerTo_ns1__GetObjectExtendedResponse:
		return soap_out_PointerTo_ns1__GetObjectExtendedResponse(soap, tag, id, (_ns1__GetObjectExtendedResponse *const*)ptr, "ns1:GetObjectExtendedResponse");
	case SOAP_TYPE_PointerTo_ns1__GetObjectExtended:
		return soap_out_PointerTo_ns1__GetObjectExtended(soap, tag, id, (_ns1__GetObjectExtended *const*)ptr, "ns1:GetObjectExtended");
	case SOAP_TYPE_PointerTo_ns1__GetObjectResponse:
		return soap_out_PointerTo_ns1__GetObjectResponse(soap, tag, id, (_ns1__GetObjectResponse *const*)ptr, "ns1:GetObjectResponse");
	case SOAP_TYPE_PointerTo_ns1__GetObject:
		return soap_out_PointerTo_ns1__GetObject(soap, tag, id, (_ns1__GetObject *const*)ptr, "ns1:GetObject");
	case SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicyResponse:
		return soap_out_PointerTo_ns1__SetBucketAccessControlPolicyResponse(soap, tag, id, (_ns1__SetBucketAccessControlPolicyResponse *const*)ptr, "ns1:SetBucketAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicy:
		return soap_out_PointerTo_ns1__SetBucketAccessControlPolicy(soap, tag, id, (_ns1__SetBucketAccessControlPolicy *const*)ptr, "ns1:SetBucketAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicyResponse:
		return soap_out_PointerTo_ns1__SetObjectAccessControlPolicyResponse(soap, tag, id, (_ns1__SetObjectAccessControlPolicyResponse *const*)ptr, "ns1:SetObjectAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicy:
		return soap_out_PointerTo_ns1__SetObjectAccessControlPolicy(soap, tag, id, (_ns1__SetObjectAccessControlPolicy *const*)ptr, "ns1:SetObjectAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicyResponse:
		return soap_out_PointerTo_ns1__GetBucketAccessControlPolicyResponse(soap, tag, id, (_ns1__GetBucketAccessControlPolicyResponse *const*)ptr, "ns1:GetBucketAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicy:
		return soap_out_PointerTo_ns1__GetBucketAccessControlPolicy(soap, tag, id, (_ns1__GetBucketAccessControlPolicy *const*)ptr, "ns1:GetBucketAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicyResponse:
		return soap_out_PointerTo_ns1__GetObjectAccessControlPolicyResponse(soap, tag, id, (_ns1__GetObjectAccessControlPolicyResponse *const*)ptr, "ns1:GetObjectAccessControlPolicyResponse");
	case SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicy:
		return soap_out_PointerTo_ns1__GetObjectAccessControlPolicy(soap, tag, id, (_ns1__GetObjectAccessControlPolicy *const*)ptr, "ns1:GetObjectAccessControlPolicy");
	case SOAP_TYPE_PointerTo_ns1__DeleteBucketResponse:
		return soap_out_PointerTo_ns1__DeleteBucketResponse(soap, tag, id, (_ns1__DeleteBucketResponse *const*)ptr, "ns1:DeleteBucketResponse");
	case SOAP_TYPE_PointerTo_ns1__DeleteBucket:
		return soap_out_PointerTo_ns1__DeleteBucket(soap, tag, id, (_ns1__DeleteBucket *const*)ptr, "ns1:DeleteBucket");
	case SOAP_TYPE_PointerTo_ns1__CreateBucketResponse:
		return soap_out_PointerTo_ns1__CreateBucketResponse(soap, tag, id, (_ns1__CreateBucketResponse *const*)ptr, "ns1:CreateBucketResponse");
	case SOAP_TYPE_PointerTo_ns1__CreateBucket:
		return soap_out_PointerTo_ns1__CreateBucket(soap, tag, id, (_ns1__CreateBucket *const*)ptr, "ns1:CreateBucket");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons1__CopyObjectResult:
		return soap_out_PointerTons1__CopyObjectResult(soap, tag, id, (ns1__CopyObjectResult *const*)ptr, "ns1:CopyObjectResult");
	case SOAP_TYPE_PointerTons1__MetadataDirective:
		return soap_out_PointerTons1__MetadataDirective(soap, tag, id, (enum ns1__MetadataDirective *const*)ptr, "ns1:MetadataDirective");
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsResult:
		return soap_out_PointerTons1__ListAllMyBucketsResult(soap, tag, id, (ns1__ListAllMyBucketsResult *const*)ptr, "ns1:ListAllMyBucketsResult");
	case SOAP_TYPE_PointerTons1__ListBucketResult:
		return soap_out_PointerTons1__ListBucketResult(soap, tag, id, (ns1__ListBucketResult *const*)ptr, "ns1:ListBucketResult");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons1__PutObjectResult:
		return soap_out_PointerTons1__PutObjectResult(soap, tag, id, (ns1__PutObjectResult *const*)ptr, "ns1:PutObjectResult");
	case SOAP_TYPE_PointerTons1__StorageClass:
		return soap_out_PointerTons1__StorageClass(soap, tag, id, (enum ns1__StorageClass *const*)ptr, "ns1:StorageClass");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons1__GetObjectResult:
		return soap_out_PointerTons1__GetObjectResult(soap, tag, id, (ns1__GetObjectResult *const*)ptr, "ns1:GetObjectResult");
	case SOAP_TYPE_PointerTons1__AccessControlPolicy:
		return soap_out_PointerTons1__AccessControlPolicy(soap, tag, id, (ns1__AccessControlPolicy *const*)ptr, "ns1:AccessControlPolicy");
	case SOAP_TYPE_PointerTons1__BucketLoggingStatus:
		return soap_out_PointerTons1__BucketLoggingStatus(soap, tag, id, (ns1__BucketLoggingStatus *const*)ptr, "ns1:BucketLoggingStatus");
	case SOAP_TYPE_PointerTons1__CreateBucketResult:
		return soap_out_PointerTons1__CreateBucketResult(soap, tag, id, (ns1__CreateBucketResult *const*)ptr, "ns1:CreateBucketResult");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsEntry:
		return soap_out_PointerTons1__ListAllMyBucketsEntry(soap, tag, id, (ns1__ListAllMyBucketsEntry *const*)ptr, "ns1:ListAllMyBucketsEntry");
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsList:
		return soap_out_PointerTons1__ListAllMyBucketsList(soap, tag, id, (ns1__ListAllMyBucketsList *const*)ptr, "ns1:ListAllMyBucketsList");
	case SOAP_TYPE_PointerTons1__PrefixEntry:
		return soap_out_PointerTons1__PrefixEntry(soap, tag, id, (ns1__PrefixEntry *const*)ptr, "ns1:PrefixEntry");
	case SOAP_TYPE_PointerTons1__ListEntry:
		return soap_out_PointerTons1__ListEntry(soap, tag, id, (ns1__ListEntry *const*)ptr, "ns1:ListEntry");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__MetadataEntry:
		return soap_out_PointerTons1__MetadataEntry(soap, tag, id, (ns1__MetadataEntry *const*)ptr, "ns1:MetadataEntry");
	case SOAP_TYPE_PointerTons1__CanonicalUser:
		return soap_out_PointerTons1__CanonicalUser(soap, tag, id, (ns1__CanonicalUser *const*)ptr, "ns1:CanonicalUser");
	case SOAP_TYPE_PointerTons1__LocationConstraint:
		return soap_out_PointerTons1__LocationConstraint(soap, tag, id, (ns1__LocationConstraint *const*)ptr, "ns1:LocationConstraint");
	case SOAP_TYPE_PointerTons1__Grant:
		return soap_out_PointerTons1__Grant(soap, tag, id, (ns1__Grant *const*)ptr, "ns1:Grant");
	case SOAP_TYPE_PointerTons1__Grantee:
		return soap_out_PointerTons1__Grantee(soap, tag, id, (ns1__Grantee *const*)ptr, "ns1:Grantee");
	case SOAP_TYPE_PointerTons1__AccessControlList:
		return soap_out_PointerTons1__AccessControlList(soap, tag, id, (ns1__AccessControlList *const*)ptr, "ns1:AccessControlList");
	case SOAP_TYPE_PointerTons1__LoggingSettings:
		return soap_out_PointerTons1__LoggingSettings(soap, tag, id, (ns1__LoggingSettings *const*)ptr, "ns1:LoggingSettings");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_out_PointerTons1__Status(soap, tag, id, (ns1__Status *const*)ptr, "ns1:Status");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__CopyObjectResponse:
		((_ns1__CopyObjectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CopyObject:
		((_ns1__CopyObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PostResponse:
		((_ns1__PostResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ListAllMyBucketsResponse:
		((_ns1__ListAllMyBucketsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ListAllMyBuckets:
		((_ns1__ListAllMyBuckets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ListBucketResponse:
		((_ns1__ListBucketResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ListBucket:
		((_ns1__ListBucket *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteObjectResponse:
		((_ns1__DeleteObjectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteObject:
		((_ns1__DeleteObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PutObjectInlineResponse:
		((_ns1__PutObjectInlineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PutObjectInline:
		((_ns1__PutObjectInline *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PutObjectResponse:
		((_ns1__PutObjectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__PutObject:
		((_ns1__PutObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObjectExtendedResponse:
		((_ns1__GetObjectExtendedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObjectExtended:
		((_ns1__GetObjectExtended *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObjectResponse:
		((_ns1__GetObjectResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObject:
		((_ns1__GetObject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse:
		((_ns1__SetBucketAccessControlPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicy:
		((_ns1__SetBucketAccessControlPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse:
		((_ns1__SetObjectAccessControlPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicy:
		((_ns1__SetObjectAccessControlPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse:
		((_ns1__GetBucketAccessControlPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicy:
		((_ns1__GetBucketAccessControlPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse:
		((_ns1__GetObjectAccessControlPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicy:
		((_ns1__GetObjectAccessControlPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetBucketLoggingStatusResponse:
		((_ns1__SetBucketLoggingStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetBucketLoggingStatus:
		((_ns1__SetBucketLoggingStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBucketLoggingStatusResponse:
		((_ns1__GetBucketLoggingStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetBucketLoggingStatus:
		((_ns1__GetBucketLoggingStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteBucketResponse:
		((_ns1__DeleteBucketResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DeleteBucket:
		((_ns1__DeleteBucket *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateBucketResponse:
		((_ns1__CreateBucketResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CreateBucket:
		((_ns1__CreateBucket *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RequestPaymentConfiguration:
		((ns1__RequestPaymentConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CopyObjectResult:
		((ns1__CopyObjectResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListAllMyBucketsList:
		((ns1__ListAllMyBucketsList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListAllMyBucketsResult:
		((ns1__ListAllMyBucketsResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListAllMyBucketsEntry:
		((ns1__ListAllMyBucketsEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListBucketResult:
		((ns1__ListBucketResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PrefixEntry:
		((ns1__PrefixEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ListEntry:
		((ns1__ListEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PutObjectResult:
		((ns1__PutObjectResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetObjectResult:
		((ns1__GetObjectResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AccessControlPolicy:
		((ns1__AccessControlPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LocationConstraint:
		((ns1__LocationConstraint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CreateBucketConfiguration:
		((ns1__CreateBucketConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AccessControlList:
		((ns1__AccessControlList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Grant:
		((ns1__Grant *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Group:
		((ns1__Group *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CanonicalUser:
		((ns1__CanonicalUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AmazonCustomerByEmail:
		((ns1__AmazonCustomerByEmail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__User:
		((ns1__User *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Grantee:
		((ns1__Grantee *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LoggingSettings:
		((ns1__LoggingSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BucketLoggingStatus:
		((ns1__BucketLoggingStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CreateBucketResult:
		((ns1__CreateBucketResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Result:
		((ns1__Result *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Status:
		((ns1__Status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MetadataEntry:
		((ns1__MetadataEntry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__CopyObject:
		soap_serialize___ns1__CopyObject(soap, (const struct __ns1__CopyObject *)ptr);
		break;
	case SOAP_TYPE___ns1__GetBucketLoggingStatus:
		soap_serialize___ns1__GetBucketLoggingStatus(soap, (const struct __ns1__GetBucketLoggingStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__SetBucketLoggingStatus:
		soap_serialize___ns1__SetBucketLoggingStatus(soap, (const struct __ns1__SetBucketLoggingStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__ListAllMyBuckets:
		soap_serialize___ns1__ListAllMyBuckets(soap, (const struct __ns1__ListAllMyBuckets *)ptr);
		break;
	case SOAP_TYPE___ns1__ListBucket:
		soap_serialize___ns1__ListBucket(soap, (const struct __ns1__ListBucket *)ptr);
		break;
	case SOAP_TYPE___ns1__DeleteObject:
		soap_serialize___ns1__DeleteObject(soap, (const struct __ns1__DeleteObject *)ptr);
		break;
	case SOAP_TYPE___ns1__PutObjectInline:
		soap_serialize___ns1__PutObjectInline(soap, (const struct __ns1__PutObjectInline *)ptr);
		break;
	case SOAP_TYPE___ns1__PutObject:
		soap_serialize___ns1__PutObject(soap, (const struct __ns1__PutObject *)ptr);
		break;
	case SOAP_TYPE___ns1__GetObjectExtended:
		soap_serialize___ns1__GetObjectExtended(soap, (const struct __ns1__GetObjectExtended *)ptr);
		break;
	case SOAP_TYPE___ns1__GetObject:
		soap_serialize___ns1__GetObject(soap, (const struct __ns1__GetObject *)ptr);
		break;
	case SOAP_TYPE___ns1__SetBucketAccessControlPolicy:
		soap_serialize___ns1__SetBucketAccessControlPolicy(soap, (const struct __ns1__SetBucketAccessControlPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__SetObjectAccessControlPolicy:
		soap_serialize___ns1__SetObjectAccessControlPolicy(soap, (const struct __ns1__SetObjectAccessControlPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__GetBucketAccessControlPolicy:
		soap_serialize___ns1__GetBucketAccessControlPolicy(soap, (const struct __ns1__GetBucketAccessControlPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__GetObjectAccessControlPolicy:
		soap_serialize___ns1__GetObjectAccessControlPolicy(soap, (const struct __ns1__GetObjectAccessControlPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__DeleteBucket:
		soap_serialize___ns1__DeleteBucket(soap, (const struct __ns1__DeleteBucket *)ptr);
		break;
	case SOAP_TYPE___ns1__CreateBucket:
		soap_serialize___ns1__CreateBucket(soap, (const struct __ns1__CreateBucket *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CopyObjectResponse:
		soap_serialize_PointerTo_ns1__CopyObjectResponse(soap, (_ns1__CopyObjectResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CopyObject:
		soap_serialize_PointerTo_ns1__CopyObject(soap, (_ns1__CopyObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatusResponse:
		soap_serialize_PointerTo_ns1__GetBucketLoggingStatusResponse(soap, (_ns1__GetBucketLoggingStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatus:
		soap_serialize_PointerTo_ns1__GetBucketLoggingStatus(soap, (_ns1__GetBucketLoggingStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatusResponse:
		soap_serialize_PointerTo_ns1__SetBucketLoggingStatusResponse(soap, (_ns1__SetBucketLoggingStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatus:
		soap_serialize_PointerTo_ns1__SetBucketLoggingStatus(soap, (_ns1__SetBucketLoggingStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ListAllMyBucketsResponse:
		soap_serialize_PointerTo_ns1__ListAllMyBucketsResponse(soap, (_ns1__ListAllMyBucketsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ListAllMyBuckets:
		soap_serialize_PointerTo_ns1__ListAllMyBuckets(soap, (_ns1__ListAllMyBuckets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ListBucketResponse:
		soap_serialize_PointerTo_ns1__ListBucketResponse(soap, (_ns1__ListBucketResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ListBucket:
		soap_serialize_PointerTo_ns1__ListBucket(soap, (_ns1__ListBucket *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteObjectResponse:
		soap_serialize_PointerTo_ns1__DeleteObjectResponse(soap, (_ns1__DeleteObjectResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteObject:
		soap_serialize_PointerTo_ns1__DeleteObject(soap, (_ns1__DeleteObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PutObjectInlineResponse:
		soap_serialize_PointerTo_ns1__PutObjectInlineResponse(soap, (_ns1__PutObjectInlineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PutObjectInline:
		soap_serialize_PointerTo_ns1__PutObjectInline(soap, (_ns1__PutObjectInline *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PutObjectResponse:
		soap_serialize_PointerTo_ns1__PutObjectResponse(soap, (_ns1__PutObjectResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__PutObject:
		soap_serialize_PointerTo_ns1__PutObject(soap, (_ns1__PutObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetObjectExtendedResponse:
		soap_serialize_PointerTo_ns1__GetObjectExtendedResponse(soap, (_ns1__GetObjectExtendedResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetObjectExtended:
		soap_serialize_PointerTo_ns1__GetObjectExtended(soap, (_ns1__GetObjectExtended *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetObjectResponse:
		soap_serialize_PointerTo_ns1__GetObjectResponse(soap, (_ns1__GetObjectResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetObject:
		soap_serialize_PointerTo_ns1__GetObject(soap, (_ns1__GetObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicyResponse:
		soap_serialize_PointerTo_ns1__SetBucketAccessControlPolicyResponse(soap, (_ns1__SetBucketAccessControlPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicy:
		soap_serialize_PointerTo_ns1__SetBucketAccessControlPolicy(soap, (_ns1__SetBucketAccessControlPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicyResponse:
		soap_serialize_PointerTo_ns1__SetObjectAccessControlPolicyResponse(soap, (_ns1__SetObjectAccessControlPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicy:
		soap_serialize_PointerTo_ns1__SetObjectAccessControlPolicy(soap, (_ns1__SetObjectAccessControlPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicyResponse:
		soap_serialize_PointerTo_ns1__GetBucketAccessControlPolicyResponse(soap, (_ns1__GetBucketAccessControlPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicy:
		soap_serialize_PointerTo_ns1__GetBucketAccessControlPolicy(soap, (_ns1__GetBucketAccessControlPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicyResponse:
		soap_serialize_PointerTo_ns1__GetObjectAccessControlPolicyResponse(soap, (_ns1__GetObjectAccessControlPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicy:
		soap_serialize_PointerTo_ns1__GetObjectAccessControlPolicy(soap, (_ns1__GetObjectAccessControlPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteBucketResponse:
		soap_serialize_PointerTo_ns1__DeleteBucketResponse(soap, (_ns1__DeleteBucketResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DeleteBucket:
		soap_serialize_PointerTo_ns1__DeleteBucket(soap, (_ns1__DeleteBucket *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateBucketResponse:
		soap_serialize_PointerTo_ns1__CreateBucketResponse(soap, (_ns1__CreateBucketResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CreateBucket:
		soap_serialize_PointerTo_ns1__CreateBucket(soap, (_ns1__CreateBucket *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CopyObjectResult:
		soap_serialize_PointerTons1__CopyObjectResult(soap, (ns1__CopyObjectResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MetadataDirective:
		soap_serialize_PointerTons1__MetadataDirective(soap, (enum ns1__MetadataDirective *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsResult:
		soap_serialize_PointerTons1__ListAllMyBucketsResult(soap, (ns1__ListAllMyBucketsResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListBucketResult:
		soap_serialize_PointerTons1__ListBucketResult(soap, (ns1__ListBucketResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PutObjectResult:
		soap_serialize_PointerTons1__PutObjectResult(soap, (ns1__PutObjectResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StorageClass:
		soap_serialize_PointerTons1__StorageClass(soap, (enum ns1__StorageClass *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetObjectResult:
		soap_serialize_PointerTons1__GetObjectResult(soap, (ns1__GetObjectResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessControlPolicy:
		soap_serialize_PointerTons1__AccessControlPolicy(soap, (ns1__AccessControlPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BucketLoggingStatus:
		soap_serialize_PointerTons1__BucketLoggingStatus(soap, (ns1__BucketLoggingStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CreateBucketResult:
		soap_serialize_PointerTons1__CreateBucketResult(soap, (ns1__CreateBucketResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsEntry:
		soap_serialize_PointerTons1__ListAllMyBucketsEntry(soap, (ns1__ListAllMyBucketsEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListAllMyBucketsList:
		soap_serialize_PointerTons1__ListAllMyBucketsList(soap, (ns1__ListAllMyBucketsList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PrefixEntry:
		soap_serialize_PointerTons1__PrefixEntry(soap, (ns1__PrefixEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ListEntry:
		soap_serialize_PointerTons1__ListEntry(soap, (ns1__ListEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MetadataEntry:
		soap_serialize_PointerTons1__MetadataEntry(soap, (ns1__MetadataEntry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CanonicalUser:
		soap_serialize_PointerTons1__CanonicalUser(soap, (ns1__CanonicalUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LocationConstraint:
		soap_serialize_PointerTons1__LocationConstraint(soap, (ns1__LocationConstraint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Grant:
		soap_serialize_PointerTons1__Grant(soap, (ns1__Grant *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Grantee:
		soap_serialize_PointerTons1__Grantee(soap, (ns1__Grantee *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccessControlList:
		soap_serialize_PointerTons1__AccessControlList(soap, (ns1__AccessControlList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LoggingSettings:
		soap_serialize_PointerTons1__LoggingSettings(soap, (ns1__LoggingSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Status:
		soap_serialize_PointerTons1__Status(soap, (ns1__Status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MetadataEntry:
		return (void*)soap_instantiate_ns1__MetadataEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Status:
		return (void*)soap_instantiate_ns1__Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Result:
		return (void*)soap_instantiate_ns1__Result(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CreateBucketResult:
		return (void*)soap_instantiate_ns1__CreateBucketResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BucketLoggingStatus:
		return (void*)soap_instantiate_ns1__BucketLoggingStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LoggingSettings:
		return (void*)soap_instantiate_ns1__LoggingSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Grantee:
		return (void*)soap_instantiate_ns1__Grantee(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Grant:
		return (void*)soap_instantiate_ns1__Grant(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessControlList:
		return (void*)soap_instantiate_ns1__AccessControlList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CreateBucketConfiguration:
		return (void*)soap_instantiate_ns1__CreateBucketConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccessControlPolicy:
		return (void*)soap_instantiate_ns1__AccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PutObjectResult:
		return (void*)soap_instantiate_ns1__PutObjectResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListEntry:
		return (void*)soap_instantiate_ns1__ListEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PrefixEntry:
		return (void*)soap_instantiate_ns1__PrefixEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListBucketResult:
		return (void*)soap_instantiate_ns1__ListBucketResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListAllMyBucketsEntry:
		return (void*)soap_instantiate_ns1__ListAllMyBucketsEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListAllMyBucketsResult:
		return (void*)soap_instantiate_ns1__ListAllMyBucketsResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ListAllMyBucketsList:
		return (void*)soap_instantiate_ns1__ListAllMyBucketsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CopyObjectResult:
		return (void*)soap_instantiate_ns1__CopyObjectResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RequestPaymentConfiguration:
		return (void*)soap_instantiate_ns1__RequestPaymentConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateBucket:
		return (void*)soap_instantiate__ns1__CreateBucket(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CreateBucketResponse:
		return (void*)soap_instantiate__ns1__CreateBucketResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteBucket:
		return (void*)soap_instantiate__ns1__DeleteBucket(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteBucketResponse:
		return (void*)soap_instantiate__ns1__DeleteBucketResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBucketLoggingStatus:
		return (void*)soap_instantiate__ns1__GetBucketLoggingStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBucketLoggingStatusResponse:
		return (void*)soap_instantiate__ns1__GetBucketLoggingStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetBucketLoggingStatus:
		return (void*)soap_instantiate__ns1__SetBucketLoggingStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetBucketLoggingStatusResponse:
		return (void*)soap_instantiate__ns1__SetBucketLoggingStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicy:
		return (void*)soap_instantiate__ns1__GetObjectAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse:
		return (void*)soap_instantiate__ns1__GetObjectAccessControlPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicy:
		return (void*)soap_instantiate__ns1__GetBucketAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse:
		return (void*)soap_instantiate__ns1__GetBucketAccessControlPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicy:
		return (void*)soap_instantiate__ns1__SetObjectAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse:
		return (void*)soap_instantiate__ns1__SetObjectAccessControlPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicy:
		return (void*)soap_instantiate__ns1__SetBucketAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse:
		return (void*)soap_instantiate__ns1__SetBucketAccessControlPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObject:
		return (void*)soap_instantiate__ns1__GetObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObjectResponse:
		return (void*)soap_instantiate__ns1__GetObjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObjectExtended:
		return (void*)soap_instantiate__ns1__GetObjectExtended(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetObjectExtendedResponse:
		return (void*)soap_instantiate__ns1__GetObjectExtendedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PutObject:
		return (void*)soap_instantiate__ns1__PutObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PutObjectResponse:
		return (void*)soap_instantiate__ns1__PutObjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PutObjectInline:
		return (void*)soap_instantiate__ns1__PutObjectInline(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PutObjectInlineResponse:
		return (void*)soap_instantiate__ns1__PutObjectInlineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteObject:
		return (void*)soap_instantiate__ns1__DeleteObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DeleteObjectResponse:
		return (void*)soap_instantiate__ns1__DeleteObjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ListBucket:
		return (void*)soap_instantiate__ns1__ListBucket(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ListBucketResponse:
		return (void*)soap_instantiate__ns1__ListBucketResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ListAllMyBuckets:
		return (void*)soap_instantiate__ns1__ListAllMyBuckets(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ListAllMyBucketsResponse:
		return (void*)soap_instantiate__ns1__ListAllMyBucketsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__PostResponse:
		return (void*)soap_instantiate__ns1__PostResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CopyObject:
		return (void*)soap_instantiate__ns1__CopyObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CopyObjectResponse:
		return (void*)soap_instantiate__ns1__CopyObjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__User:
		return (void*)soap_instantiate_ns1__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Group:
		return (void*)soap_instantiate_ns1__Group(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LocationConstraint:
		return (void*)soap_instantiate_ns1__LocationConstraint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetObjectResult:
		return (void*)soap_instantiate_ns1__GetObjectResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AmazonCustomerByEmail:
		return (void*)soap_instantiate_ns1__AmazonCustomerByEmail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CanonicalUser:
		return (void*)soap_instantiate_ns1__CanonicalUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CreateBucket:
		return (void*)soap_instantiate___ns1__CreateBucket(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DeleteBucket:
		return (void*)soap_instantiate___ns1__DeleteBucket(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetObjectAccessControlPolicy:
		return (void*)soap_instantiate___ns1__GetObjectAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBucketAccessControlPolicy:
		return (void*)soap_instantiate___ns1__GetBucketAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetObjectAccessControlPolicy:
		return (void*)soap_instantiate___ns1__SetObjectAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetBucketAccessControlPolicy:
		return (void*)soap_instantiate___ns1__SetBucketAccessControlPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetObject:
		return (void*)soap_instantiate___ns1__GetObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetObjectExtended:
		return (void*)soap_instantiate___ns1__GetObjectExtended(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__PutObject:
		return (void*)soap_instantiate___ns1__PutObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__PutObjectInline:
		return (void*)soap_instantiate___ns1__PutObjectInline(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DeleteObject:
		return (void*)soap_instantiate___ns1__DeleteObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ListBucket:
		return (void*)soap_instantiate___ns1__ListBucket(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ListAllMyBuckets:
		return (void*)soap_instantiate___ns1__ListAllMyBuckets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetBucketLoggingStatus:
		return (void*)soap_instantiate___ns1__SetBucketLoggingStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetBucketLoggingStatus:
		return (void*)soap_instantiate___ns1__GetBucketLoggingStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CopyObject:
		return (void*)soap_instantiate___ns1__CopyObject(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PrefixEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__PrefixEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ListEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MetadataEntry:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Grant:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Grant(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_ns1__MetadataEntry:
		if (p->size < 0)
			SOAP_DELETE((ns1__MetadataEntry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__MetadataEntry*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Status:
		if (p->size < 0)
			SOAP_DELETE((ns1__Status*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Status*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Result:
		if (p->size < 0)
			SOAP_DELETE((ns1__Result*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Result*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CreateBucketResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__CreateBucketResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CreateBucketResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__BucketLoggingStatus:
		if (p->size < 0)
			SOAP_DELETE((ns1__BucketLoggingStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__BucketLoggingStatus*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LoggingSettings:
		if (p->size < 0)
			SOAP_DELETE((ns1__LoggingSettings*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__LoggingSettings*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Grantee:
		if (p->size < 0)
			SOAP_DELETE((ns1__Grantee*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Grantee*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Grant:
		if (p->size < 0)
			SOAP_DELETE((ns1__Grant*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Grant*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AccessControlList:
		if (p->size < 0)
			SOAP_DELETE((ns1__AccessControlList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AccessControlList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CreateBucketConfiguration:
		if (p->size < 0)
			SOAP_DELETE((ns1__CreateBucketConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CreateBucketConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((ns1__AccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PutObjectResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__PutObjectResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PutObjectResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ListEntry:
		if (p->size < 0)
			SOAP_DELETE((ns1__ListEntry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ListEntry*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PrefixEntry:
		if (p->size < 0)
			SOAP_DELETE((ns1__PrefixEntry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PrefixEntry*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ListBucketResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__ListBucketResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ListBucketResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ListAllMyBucketsEntry:
		if (p->size < 0)
			SOAP_DELETE((ns1__ListAllMyBucketsEntry*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ListAllMyBucketsEntry*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ListAllMyBucketsResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__ListAllMyBucketsResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ListAllMyBucketsResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ListAllMyBucketsList:
		if (p->size < 0)
			SOAP_DELETE((ns1__ListAllMyBucketsList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ListAllMyBucketsList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CopyObjectResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__CopyObjectResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CopyObjectResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__RequestPaymentConfiguration:
		if (p->size < 0)
			SOAP_DELETE((ns1__RequestPaymentConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__RequestPaymentConfiguration*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CreateBucket:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CreateBucket*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CreateBucket*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CreateBucketResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CreateBucketResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CreateBucketResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteBucket:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteBucket*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteBucket*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteBucketResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteBucketResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteBucketResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBucketLoggingStatus:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBucketLoggingStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBucketLoggingStatus*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBucketLoggingStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBucketLoggingStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBucketLoggingStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetBucketLoggingStatus:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetBucketLoggingStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetBucketLoggingStatus*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetBucketLoggingStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetBucketLoggingStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetBucketLoggingStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetObjectAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetObjectAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetObjectAccessControlPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetObjectAccessControlPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBucketAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBucketAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetBucketAccessControlPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetBucketAccessControlPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetObjectAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetObjectAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetObjectAccessControlPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetObjectAccessControlPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetBucketAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetBucketAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__SetBucketAccessControlPolicyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__SetBucketAccessControlPolicyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetObject:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetObject*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetObjectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetObjectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetObjectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetObjectExtended:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetObjectExtended*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetObjectExtended*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetObjectExtendedResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetObjectExtendedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetObjectExtendedResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PutObject:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PutObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PutObject*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PutObjectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PutObjectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PutObjectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PutObjectInline:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PutObjectInline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PutObjectInline*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PutObjectInlineResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PutObjectInlineResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PutObjectInlineResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteObject:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteObject*)p->ptr);
		break;
	case SOAP_TYPE__ns1__DeleteObjectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__DeleteObjectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__DeleteObjectResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__ListBucket:
		if (p->size < 0)
			SOAP_DELETE((_ns1__ListBucket*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__ListBucket*)p->ptr);
		break;
	case SOAP_TYPE__ns1__ListBucketResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__ListBucketResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__ListBucketResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__ListAllMyBuckets:
		if (p->size < 0)
			SOAP_DELETE((_ns1__ListAllMyBuckets*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__ListAllMyBuckets*)p->ptr);
		break;
	case SOAP_TYPE__ns1__ListAllMyBucketsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__ListAllMyBucketsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__ListAllMyBucketsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__PostResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__PostResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__PostResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CopyObject:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CopyObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CopyObject*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CopyObjectResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CopyObjectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CopyObjectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__User:
		if (p->size < 0)
			SOAP_DELETE((ns1__User*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__User*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Group:
		if (p->size < 0)
			SOAP_DELETE((ns1__Group*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Group*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LocationConstraint:
		if (p->size < 0)
			SOAP_DELETE((ns1__LocationConstraint*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__LocationConstraint*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetObjectResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__GetObjectResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__GetObjectResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AmazonCustomerByEmail:
		if (p->size < 0)
			SOAP_DELETE((ns1__AmazonCustomerByEmail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AmazonCustomerByEmail*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CanonicalUser:
		if (p->size < 0)
			SOAP_DELETE((ns1__CanonicalUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CanonicalUser*)p->ptr);
		break;
	case SOAP_TYPE___ns1__CreateBucket:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__CreateBucket*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__CreateBucket*)p->ptr);
		break;
	case SOAP_TYPE___ns1__DeleteBucket:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__DeleteBucket*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__DeleteBucket*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetObjectAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetObjectAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetObjectAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetBucketAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetBucketAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetBucketAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetObjectAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetObjectAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetObjectAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetBucketAccessControlPolicy:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetBucketAccessControlPolicy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetBucketAccessControlPolicy*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetObject:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetObject*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetObjectExtended:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetObjectExtended*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetObjectExtended*)p->ptr);
		break;
	case SOAP_TYPE___ns1__PutObject:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__PutObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__PutObject*)p->ptr);
		break;
	case SOAP_TYPE___ns1__PutObjectInline:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__PutObjectInline*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__PutObjectInline*)p->ptr);
		break;
	case SOAP_TYPE___ns1__DeleteObject:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__DeleteObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__DeleteObject*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ListBucket:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ListBucket*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ListBucket*)p->ptr);
		break;
	case SOAP_TYPE___ns1__ListAllMyBuckets:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__ListAllMyBuckets*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__ListAllMyBuckets*)p->ptr);
		break;
	case SOAP_TYPE___ns1__SetBucketLoggingStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__SetBucketLoggingStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__SetBucketLoggingStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetBucketLoggingStatus:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetBucketLoggingStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetBucketLoggingStatus*)p->ptr);
		break;
	case SOAP_TYPE___ns1__CopyObject:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__CopyObject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__CopyObject*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__ListAllMyBucketsEntry * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__ListAllMyBucketsEntry * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PrefixEntry:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__PrefixEntry * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__PrefixEntry * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListEntry:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__ListEntry * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__ListEntry * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MetadataEntry:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__MetadataEntry * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__MetadataEntry * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Grant:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__Grant * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__Grant * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ListAllMyBucketsEntry * >*)p)[len] = *(ns1__ListAllMyBucketsEntry **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PrefixEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__PrefixEntry * >*)p)[len] = *(ns1__PrefixEntry **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ListEntry * >*)p)[len] = *(ns1__ListEntry **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MetadataEntry:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__MetadataEntry * >*)p)[len] = *(ns1__MetadataEntry **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Grant:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Grant * >*)p)[len] = *(ns1__Grant **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Payer(struct soap *soap, enum ns1__Payer *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Payer
	*a = SOAP_DEFAULT_ns1__Payer;
#else
	*a = (enum ns1__Payer)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__Payer[] =
{	{ (long)ns1__Payer__BucketOwner, "BucketOwner" },
	{ (long)ns1__Payer__Requester, "Requester" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Payer2s(struct soap *soap, enum ns1__Payer n)
{	const char *s = soap_code_str(soap_codes_ns1__Payer, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Payer(struct soap *soap, const char *tag, int id, const enum ns1__Payer *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Payer), type) || soap_send(soap, soap_ns1__Payer2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Payer(struct soap *soap, const char *s, enum ns1__Payer *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Payer, s);
	if (map)
		*a = (enum ns1__Payer)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Payer)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Payer * SOAP_FMAC4 soap_in_ns1__Payer(struct soap *soap, const char *tag, enum ns1__Payer *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Payer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Payer, sizeof(enum ns1__Payer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__Payer(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Payer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Payer, 0, sizeof(enum ns1__Payer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Payer(struct soap *soap, const enum ns1__Payer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Payer);
	if (soap_out_ns1__Payer(soap, tag?tag:"ns1:Payer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Payer * SOAP_FMAC4 soap_get_ns1__Payer(struct soap *soap, enum ns1__Payer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Payer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__MetadataDirective(struct soap *soap, enum ns1__MetadataDirective *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__MetadataDirective
	*a = SOAP_DEFAULT_ns1__MetadataDirective;
#else
	*a = (enum ns1__MetadataDirective)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__MetadataDirective[] =
{	{ (long)ns1__MetadataDirective__COPY, "COPY" },
	{ (long)ns1__MetadataDirective__REPLACE, "REPLACE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__MetadataDirective2s(struct soap *soap, enum ns1__MetadataDirective n)
{	const char *s = soap_code_str(soap_codes_ns1__MetadataDirective, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MetadataDirective(struct soap *soap, const char *tag, int id, const enum ns1__MetadataDirective *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MetadataDirective), type) || soap_send(soap, soap_ns1__MetadataDirective2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__MetadataDirective(struct soap *soap, const char *s, enum ns1__MetadataDirective *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__MetadataDirective, s);
	if (map)
		*a = (enum ns1__MetadataDirective)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__MetadataDirective)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__MetadataDirective * SOAP_FMAC4 soap_in_ns1__MetadataDirective(struct soap *soap, const char *tag, enum ns1__MetadataDirective *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__MetadataDirective *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MetadataDirective, sizeof(enum ns1__MetadataDirective), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__MetadataDirective(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__MetadataDirective *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MetadataDirective, 0, sizeof(enum ns1__MetadataDirective), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__MetadataDirective(struct soap *soap, const enum ns1__MetadataDirective *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__MetadataDirective);
	if (soap_out_ns1__MetadataDirective(soap, tag?tag:"ns1:MetadataDirective", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MetadataDirective * SOAP_FMAC4 soap_get_ns1__MetadataDirective(struct soap *soap, enum ns1__MetadataDirective *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MetadataDirective(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StorageClass(struct soap *soap, enum ns1__StorageClass *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__StorageClass
	*a = SOAP_DEFAULT_ns1__StorageClass;
#else
	*a = (enum ns1__StorageClass)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__StorageClass[] =
{	{ (long)ns1__StorageClass__STANDARD, "STANDARD" },
	{ (long)ns1__StorageClass__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__StorageClass2s(struct soap *soap, enum ns1__StorageClass n)
{	const char *s = soap_code_str(soap_codes_ns1__StorageClass, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StorageClass(struct soap *soap, const char *tag, int id, const enum ns1__StorageClass *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StorageClass), type) || soap_send(soap, soap_ns1__StorageClass2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__StorageClass(struct soap *soap, const char *s, enum ns1__StorageClass *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__StorageClass, s);
	if (map)
		*a = (enum ns1__StorageClass)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__StorageClass)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StorageClass * SOAP_FMAC4 soap_in_ns1__StorageClass(struct soap *soap, const char *tag, enum ns1__StorageClass *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__StorageClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StorageClass, sizeof(enum ns1__StorageClass), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__StorageClass(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__StorageClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StorageClass, 0, sizeof(enum ns1__StorageClass), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StorageClass(struct soap *soap, const enum ns1__StorageClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StorageClass);
	if (soap_out_ns1__StorageClass(soap, tag?tag:"ns1:StorageClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__StorageClass * SOAP_FMAC4 soap_get_ns1__StorageClass(struct soap *soap, enum ns1__StorageClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StorageClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Permission(struct soap *soap, enum ns1__Permission *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Permission
	*a = SOAP_DEFAULT_ns1__Permission;
#else
	*a = (enum ns1__Permission)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__Permission[] =
{	{ (long)ns1__Permission__READ, "READ" },
	{ (long)ns1__Permission__WRITE, "WRITE" },
	{ (long)ns1__Permission__READ_USCOREACP, "READ_ACP" },
	{ (long)ns1__Permission__WRITE_USCOREACP, "WRITE_ACP" },
	{ (long)ns1__Permission__FULL_USCORECONTROL, "FULL_CONTROL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Permission2s(struct soap *soap, enum ns1__Permission n)
{	const char *s = soap_code_str(soap_codes_ns1__Permission, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Permission(struct soap *soap, const char *tag, int id, const enum ns1__Permission *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Permission), type) || soap_send(soap, soap_ns1__Permission2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Permission(struct soap *soap, const char *s, enum ns1__Permission *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Permission, s);
	if (map)
		*a = (enum ns1__Permission)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Permission)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Permission * SOAP_FMAC4 soap_in_ns1__Permission(struct soap *soap, const char *tag, enum ns1__Permission *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Permission *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Permission, sizeof(enum ns1__Permission), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__Permission(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Permission *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Permission, 0, sizeof(enum ns1__Permission), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Permission(struct soap *soap, const enum ns1__Permission *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Permission);
	if (soap_out_ns1__Permission(soap, tag?tag:"ns1:Permission", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Permission * SOAP_FMAC4 soap_get_ns1__Permission(struct soap *soap, enum ns1__Permission *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Permission(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CopyObjectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CopyObjectResponse::CopyObjectResult = NULL;
	/* transient soap skipped */
}

void _ns1__CopyObjectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CopyObjectResult(soap, &this->_ns1__CopyObjectResponse::CopyObjectResult);
	/* transient soap skipped */
}

int _ns1__CopyObjectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CopyObjectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CopyObjectResponse(struct soap *soap, const char *tag, int id, const _ns1__CopyObjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CopyObjectResponse), type))
		return soap->error;
	if (a->CopyObjectResult)
		soap_element_result(soap, "ns1:CopyObjectResult");
	if (a->_ns1__CopyObjectResponse::CopyObjectResult)
	{	if (soap_out_PointerTons1__CopyObjectResult(soap, "ns1:CopyObjectResult", -1, &a->_ns1__CopyObjectResponse::CopyObjectResult, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:CopyObjectResult"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CopyObjectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CopyObjectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CopyObjectResponse * SOAP_FMAC4 soap_in__ns1__CopyObjectResponse(struct soap *soap, const char *tag, _ns1__CopyObjectResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CopyObjectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CopyObjectResponse, sizeof(_ns1__CopyObjectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CopyObjectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CopyObjectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CopyObjectResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CopyObjectResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CopyObjectResult(soap, "ns1:CopyObjectResult", &(a->_ns1__CopyObjectResponse::CopyObjectResult), "ns1:CopyObjectResult"))
				{	soap_flag_CopyObjectResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:CopyObjectResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CopyObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CopyObjectResponse, 0, sizeof(_ns1__CopyObjectResponse), 0, soap_copy__ns1__CopyObjectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CopyObjectResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__CopyObjectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CopyObjectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:CopyObjectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CopyObjectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CopyObjectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CopyObjectResponse * SOAP_FMAC4 soap_get__ns1__CopyObjectResponse(struct soap *soap, _ns1__CopyObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CopyObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CopyObjectResponse * SOAP_FMAC2 soap_instantiate__ns1__CopyObjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CopyObjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CopyObjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CopyObjectResponse);
		if (size)
			*size = sizeof(_ns1__CopyObjectResponse);
		((_ns1__CopyObjectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CopyObjectResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CopyObjectResponse);
		for (int i = 0; i < n; i++)
			((_ns1__CopyObjectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CopyObjectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CopyObjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CopyObjectResponse %p -> %p\n", q, p));
	*(_ns1__CopyObjectResponse*)p = *(_ns1__CopyObjectResponse*)q;
}

void _ns1__CopyObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__CopyObject::SourceBucket);
	soap_default_std__string(soap, &this->_ns1__CopyObject::SourceKey);
	soap_default_std__string(soap, &this->_ns1__CopyObject::DestinationBucket);
	soap_default_std__string(soap, &this->_ns1__CopyObject::DestinationKey);
	this->_ns1__CopyObject::MetadataDirective = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->_ns1__CopyObject::Metadata);
	this->_ns1__CopyObject::AccessControlList = NULL;
	this->_ns1__CopyObject::CopySourceIfModifiedSince = NULL;
	this->_ns1__CopyObject::CopySourceIfUnmodifiedSince = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns1__CopyObject::CopySourceIfMatch);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns1__CopyObject::CopySourceIfNoneMatch);
	this->_ns1__CopyObject::StorageClass = NULL;
	this->_ns1__CopyObject::AWSAccessKeyId = NULL;
	this->_ns1__CopyObject::Timestamp = NULL;
	this->_ns1__CopyObject::Signature = NULL;
	this->_ns1__CopyObject::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__CopyObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__CopyObject::SourceBucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__CopyObject::SourceBucket);
	soap_embedded(soap, &this->_ns1__CopyObject::SourceKey, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__CopyObject::SourceKey);
	soap_embedded(soap, &this->_ns1__CopyObject::DestinationBucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__CopyObject::DestinationBucket);
	soap_embedded(soap, &this->_ns1__CopyObject::DestinationKey, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__CopyObject::DestinationKey);
	soap_serialize_PointerTons1__MetadataDirective(soap, &this->_ns1__CopyObject::MetadataDirective);
	soap_serialize_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->_ns1__CopyObject::Metadata);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->_ns1__CopyObject::AccessControlList);
	soap_serialize_PointerTotime(soap, &this->_ns1__CopyObject::CopySourceIfModifiedSince);
	soap_serialize_PointerTotime(soap, &this->_ns1__CopyObject::CopySourceIfUnmodifiedSince);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns1__CopyObject::CopySourceIfMatch);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns1__CopyObject::CopySourceIfNoneMatch);
	soap_serialize_PointerTons1__StorageClass(soap, &this->_ns1__CopyObject::StorageClass);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CopyObject::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__CopyObject::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CopyObject::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CopyObject::Credential);
	/* transient soap skipped */
}

int _ns1__CopyObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CopyObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CopyObject(struct soap *soap, const char *tag, int id, const _ns1__CopyObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CopyObject), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:SourceBucket", -1, &(a->_ns1__CopyObject::SourceBucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:SourceKey", -1, &(a->_ns1__CopyObject::SourceKey), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:DestinationBucket", -1, &(a->_ns1__CopyObject::DestinationBucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:DestinationKey", -1, &(a->_ns1__CopyObject::DestinationKey), ""))
		return soap->error;
	if (soap_out_PointerTons1__MetadataDirective(soap, "ns1:MetadataDirective", -1, &(a->_ns1__CopyObject::MetadataDirective), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", -1, &(a->_ns1__CopyObject::Metadata), ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", -1, &(a->_ns1__CopyObject::AccessControlList), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:CopySourceIfModifiedSince", -1, &(a->_ns1__CopyObject::CopySourceIfModifiedSince), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:CopySourceIfUnmodifiedSince", -1, &(a->_ns1__CopyObject::CopySourceIfUnmodifiedSince), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:CopySourceIfMatch", -1, &(a->_ns1__CopyObject::CopySourceIfMatch), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:CopySourceIfNoneMatch", -1, &(a->_ns1__CopyObject::CopySourceIfNoneMatch), ""))
		return soap->error;
	if (soap_out_PointerTons1__StorageClass(soap, "ns1:StorageClass", -1, &(a->_ns1__CopyObject::StorageClass), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__CopyObject::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__CopyObject::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__CopyObject::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__CopyObject::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CopyObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CopyObject(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CopyObject * SOAP_FMAC4 soap_in__ns1__CopyObject(struct soap *soap, const char *tag, _ns1__CopyObject *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CopyObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CopyObject, sizeof(_ns1__CopyObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CopyObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CopyObject *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SourceBucket1 = 1;
	size_t soap_flag_SourceKey1 = 1;
	size_t soap_flag_DestinationBucket1 = 1;
	size_t soap_flag_DestinationKey1 = 1;
	size_t soap_flag_MetadataDirective1 = 1;
	size_t soap_flag_AccessControlList1 = 1;
	size_t soap_flag_CopySourceIfModifiedSince1 = 1;
	size_t soap_flag_CopySourceIfUnmodifiedSince1 = 1;
	size_t soap_flag_StorageClass1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SourceBucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:SourceBucket", &(a->_ns1__CopyObject::SourceBucket), "xsd:string"))
				{	soap_flag_SourceBucket1--;
					continue;
				}
			if (soap_flag_SourceKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:SourceKey", &(a->_ns1__CopyObject::SourceKey), "xsd:string"))
				{	soap_flag_SourceKey1--;
					continue;
				}
			if (soap_flag_DestinationBucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:DestinationBucket", &(a->_ns1__CopyObject::DestinationBucket), "xsd:string"))
				{	soap_flag_DestinationBucket1--;
					continue;
				}
			if (soap_flag_DestinationKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:DestinationKey", &(a->_ns1__CopyObject::DestinationKey), "xsd:string"))
				{	soap_flag_DestinationKey1--;
					continue;
				}
			if (soap_flag_MetadataDirective1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MetadataDirective(soap, "ns1:MetadataDirective", &(a->_ns1__CopyObject::MetadataDirective), "ns1:MetadataDirective"))
				{	soap_flag_MetadataDirective1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", &(a->_ns1__CopyObject::Metadata), "ns1:MetadataEntry"))
					continue;
			if (soap_flag_AccessControlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", &(a->_ns1__CopyObject::AccessControlList), "ns1:AccessControlList"))
				{	soap_flag_AccessControlList1--;
					continue;
				}
			if (soap_flag_CopySourceIfModifiedSince1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:CopySourceIfModifiedSince", &(a->_ns1__CopyObject::CopySourceIfModifiedSince), "xsd:dateTime"))
				{	soap_flag_CopySourceIfModifiedSince1--;
					continue;
				}
			if (soap_flag_CopySourceIfUnmodifiedSince1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:CopySourceIfUnmodifiedSince", &(a->_ns1__CopyObject::CopySourceIfUnmodifiedSince), "xsd:dateTime"))
				{	soap_flag_CopySourceIfUnmodifiedSince1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:CopySourceIfMatch", &(a->_ns1__CopyObject::CopySourceIfMatch), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:CopySourceIfNoneMatch", &(a->_ns1__CopyObject::CopySourceIfNoneMatch), "xsd:string"))
					continue;
			if (soap_flag_StorageClass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StorageClass(soap, "ns1:StorageClass", &(a->_ns1__CopyObject::StorageClass), "ns1:StorageClass"))
				{	soap_flag_StorageClass1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__CopyObject::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__CopyObject::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__CopyObject::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__CopyObject::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CopyObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CopyObject, 0, sizeof(_ns1__CopyObject), 0, soap_copy__ns1__CopyObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SourceBucket1 > 0 || soap_flag_SourceKey1 > 0 || soap_flag_DestinationBucket1 > 0 || soap_flag_DestinationKey1 > 0 || a->_ns1__CopyObject::Metadata.size() > 100 || a->_ns1__CopyObject::CopySourceIfMatch.size() > 100 || a->_ns1__CopyObject::CopySourceIfNoneMatch.size() > 100))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__CopyObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CopyObject);
	if (this->soap_out(soap, tag?tag:"ns1:CopyObject", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CopyObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CopyObject(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CopyObject * SOAP_FMAC4 soap_get__ns1__CopyObject(struct soap *soap, _ns1__CopyObject *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CopyObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CopyObject * SOAP_FMAC2 soap_instantiate__ns1__CopyObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CopyObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CopyObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CopyObject);
		if (size)
			*size = sizeof(_ns1__CopyObject);
		((_ns1__CopyObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CopyObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CopyObject);
		for (int i = 0; i < n; i++)
			((_ns1__CopyObject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CopyObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CopyObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CopyObject %p -> %p\n", q, p));
	*(_ns1__CopyObject*)p = *(_ns1__CopyObject*)q;
}

void _ns1__PostResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_ns1__PostResponse::Location);
	soap_default_std__string(soap, &this->_ns1__PostResponse::Bucket);
	soap_default_std__string(soap, &this->_ns1__PostResponse::Key);
	soap_default_std__string(soap, &this->_ns1__PostResponse::ETag);
	/* transient soap skipped */
}

void _ns1__PostResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->_ns1__PostResponse::Location);
	soap_embedded(soap, &this->_ns1__PostResponse::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__PostResponse::Bucket);
	soap_embedded(soap, &this->_ns1__PostResponse::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__PostResponse::Key);
	soap_embedded(soap, &this->_ns1__PostResponse::ETag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__PostResponse::ETag);
	/* transient soap skipped */
}

int _ns1__PostResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PostResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PostResponse(struct soap *soap, const char *tag, int id, const _ns1__PostResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PostResponse), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns1:Location", -1, &(a->_ns1__PostResponse::Location), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__PostResponse::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__PostResponse::Key), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ETag", -1, &(a->_ns1__PostResponse::ETag), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PostResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PostResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PostResponse * SOAP_FMAC4 soap_in__ns1__PostResponse(struct soap *soap, const char *tag, _ns1__PostResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PostResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PostResponse, sizeof(_ns1__PostResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PostResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PostResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Location1 = 1;
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_ETag1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns1:Location", &(a->_ns1__PostResponse::Location), "xsd:anyURI"))
				{	soap_flag_Location1--;
					continue;
				}
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__PostResponse::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__PostResponse::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_ETag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ETag", &(a->_ns1__PostResponse::ETag), "xsd:string"))
				{	soap_flag_ETag1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PostResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PostResponse, 0, sizeof(_ns1__PostResponse), 0, soap_copy__ns1__PostResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Location1 > 0 || soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0 || soap_flag_ETag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__PostResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PostResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PostResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PostResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PostResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PostResponse * SOAP_FMAC4 soap_get__ns1__PostResponse(struct soap *soap, _ns1__PostResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PostResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PostResponse * SOAP_FMAC2 soap_instantiate__ns1__PostResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PostResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PostResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PostResponse);
		if (size)
			*size = sizeof(_ns1__PostResponse);
		((_ns1__PostResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PostResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PostResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PostResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PostResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PostResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PostResponse %p -> %p\n", q, p));
	*(_ns1__PostResponse*)p = *(_ns1__PostResponse*)q;
}

void _ns1__ListAllMyBucketsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ListAllMyBucketsResponse::ListAllMyBucketsResponse = NULL;
	/* transient soap skipped */
}

void _ns1__ListAllMyBucketsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ListAllMyBucketsResult(soap, &this->_ns1__ListAllMyBucketsResponse::ListAllMyBucketsResponse);
	/* transient soap skipped */
}

int _ns1__ListAllMyBucketsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ListAllMyBucketsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ListAllMyBucketsResponse(struct soap *soap, const char *tag, int id, const _ns1__ListAllMyBucketsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ListAllMyBucketsResponse), type))
		return soap->error;
	if (a->ListAllMyBucketsResponse)
		soap_element_result(soap, "ns1:ListAllMyBucketsResponse");
	if (a->_ns1__ListAllMyBucketsResponse::ListAllMyBucketsResponse)
	{	if (soap_out_PointerTons1__ListAllMyBucketsResult(soap, "ns1:ListAllMyBucketsResponse", -1, &a->_ns1__ListAllMyBucketsResponse::ListAllMyBucketsResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ListAllMyBucketsResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ListAllMyBucketsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ListAllMyBucketsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ListAllMyBucketsResponse * SOAP_FMAC4 soap_in__ns1__ListAllMyBucketsResponse(struct soap *soap, const char *tag, _ns1__ListAllMyBucketsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ListAllMyBucketsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ListAllMyBucketsResponse, sizeof(_ns1__ListAllMyBucketsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ListAllMyBucketsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ListAllMyBucketsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ListAllMyBucketsResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListAllMyBucketsResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ListAllMyBucketsResult(soap, "ns1:ListAllMyBucketsResponse", &(a->_ns1__ListAllMyBucketsResponse::ListAllMyBucketsResponse), "ns1:ListAllMyBucketsResult"))
				{	soap_flag_ListAllMyBucketsResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:ListAllMyBucketsResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ListAllMyBucketsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ListAllMyBucketsResponse, 0, sizeof(_ns1__ListAllMyBucketsResponse), 0, soap_copy__ns1__ListAllMyBucketsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ListAllMyBucketsResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__ListAllMyBucketsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ListAllMyBucketsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ListAllMyBucketsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ListAllMyBucketsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ListAllMyBucketsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ListAllMyBucketsResponse * SOAP_FMAC4 soap_get__ns1__ListAllMyBucketsResponse(struct soap *soap, _ns1__ListAllMyBucketsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ListAllMyBucketsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__ListAllMyBucketsResponse * SOAP_FMAC2 soap_instantiate__ns1__ListAllMyBucketsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ListAllMyBucketsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ListAllMyBucketsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListAllMyBucketsResponse);
		if (size)
			*size = sizeof(_ns1__ListAllMyBucketsResponse);
		((_ns1__ListAllMyBucketsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListAllMyBucketsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ListAllMyBucketsResponse);
		for (int i = 0; i < n; i++)
			((_ns1__ListAllMyBucketsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ListAllMyBucketsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ListAllMyBucketsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ListAllMyBucketsResponse %p -> %p\n", q, p));
	*(_ns1__ListAllMyBucketsResponse*)p = *(_ns1__ListAllMyBucketsResponse*)q;
}

void _ns1__ListAllMyBuckets::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ListAllMyBuckets::AWSAccessKeyId = NULL;
	this->_ns1__ListAllMyBuckets::Timestamp = NULL;
	this->_ns1__ListAllMyBuckets::Signature = NULL;
	/* transient soap skipped */
}

void _ns1__ListAllMyBuckets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListAllMyBuckets::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__ListAllMyBuckets::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListAllMyBuckets::Signature);
	/* transient soap skipped */
}

int _ns1__ListAllMyBuckets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ListAllMyBuckets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ListAllMyBuckets(struct soap *soap, const char *tag, int id, const _ns1__ListAllMyBuckets *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ListAllMyBuckets), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__ListAllMyBuckets::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__ListAllMyBuckets::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__ListAllMyBuckets::Signature), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ListAllMyBuckets::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ListAllMyBuckets(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ListAllMyBuckets * SOAP_FMAC4 soap_in__ns1__ListAllMyBuckets(struct soap *soap, const char *tag, _ns1__ListAllMyBuckets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ListAllMyBuckets *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ListAllMyBuckets, sizeof(_ns1__ListAllMyBuckets), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ListAllMyBuckets)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ListAllMyBuckets *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__ListAllMyBuckets::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__ListAllMyBuckets::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__ListAllMyBuckets::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ListAllMyBuckets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ListAllMyBuckets, 0, sizeof(_ns1__ListAllMyBuckets), 0, soap_copy__ns1__ListAllMyBuckets);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__ListAllMyBuckets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ListAllMyBuckets);
	if (this->soap_out(soap, tag?tag:"ns1:ListAllMyBuckets", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ListAllMyBuckets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ListAllMyBuckets(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ListAllMyBuckets * SOAP_FMAC4 soap_get__ns1__ListAllMyBuckets(struct soap *soap, _ns1__ListAllMyBuckets *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ListAllMyBuckets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__ListAllMyBuckets * SOAP_FMAC2 soap_instantiate__ns1__ListAllMyBuckets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ListAllMyBuckets(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ListAllMyBuckets, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListAllMyBuckets);
		if (size)
			*size = sizeof(_ns1__ListAllMyBuckets);
		((_ns1__ListAllMyBuckets*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListAllMyBuckets[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ListAllMyBuckets);
		for (int i = 0; i < n; i++)
			((_ns1__ListAllMyBuckets*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ListAllMyBuckets*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ListAllMyBuckets(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ListAllMyBuckets %p -> %p\n", q, p));
	*(_ns1__ListAllMyBuckets*)p = *(_ns1__ListAllMyBuckets*)q;
}

void _ns1__ListBucketResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ListBucketResponse::ListBucketResponse = NULL;
	/* transient soap skipped */
}

void _ns1__ListBucketResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ListBucketResult(soap, &this->_ns1__ListBucketResponse::ListBucketResponse);
	/* transient soap skipped */
}

int _ns1__ListBucketResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ListBucketResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ListBucketResponse(struct soap *soap, const char *tag, int id, const _ns1__ListBucketResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ListBucketResponse), type))
		return soap->error;
	if (a->ListBucketResponse)
		soap_element_result(soap, "ns1:ListBucketResponse");
	if (a->_ns1__ListBucketResponse::ListBucketResponse)
	{	if (soap_out_PointerTons1__ListBucketResult(soap, "ns1:ListBucketResponse", -1, &a->_ns1__ListBucketResponse::ListBucketResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:ListBucketResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ListBucketResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ListBucketResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ListBucketResponse * SOAP_FMAC4 soap_in__ns1__ListBucketResponse(struct soap *soap, const char *tag, _ns1__ListBucketResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ListBucketResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ListBucketResponse, sizeof(_ns1__ListBucketResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ListBucketResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ListBucketResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ListBucketResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ListBucketResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ListBucketResult(soap, "ns1:ListBucketResponse", &(a->_ns1__ListBucketResponse::ListBucketResponse), "ns1:ListBucketResult"))
				{	soap_flag_ListBucketResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:ListBucketResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ListBucketResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ListBucketResponse, 0, sizeof(_ns1__ListBucketResponse), 0, soap_copy__ns1__ListBucketResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ListBucketResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__ListBucketResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ListBucketResponse);
	if (this->soap_out(soap, tag?tag:"ns1:ListBucketResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ListBucketResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ListBucketResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ListBucketResponse * SOAP_FMAC4 soap_get__ns1__ListBucketResponse(struct soap *soap, _ns1__ListBucketResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ListBucketResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__ListBucketResponse * SOAP_FMAC2 soap_instantiate__ns1__ListBucketResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ListBucketResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ListBucketResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListBucketResponse);
		if (size)
			*size = sizeof(_ns1__ListBucketResponse);
		((_ns1__ListBucketResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListBucketResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ListBucketResponse);
		for (int i = 0; i < n; i++)
			((_ns1__ListBucketResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ListBucketResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ListBucketResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ListBucketResponse %p -> %p\n", q, p));
	*(_ns1__ListBucketResponse*)p = *(_ns1__ListBucketResponse*)q;
}

void _ns1__ListBucket::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__ListBucket::Bucket);
	this->_ns1__ListBucket::Prefix = NULL;
	this->_ns1__ListBucket::Marker = NULL;
	this->_ns1__ListBucket::MaxKeys = NULL;
	this->_ns1__ListBucket::Delimiter = NULL;
	this->_ns1__ListBucket::AWSAccessKeyId = NULL;
	this->_ns1__ListBucket::Timestamp = NULL;
	this->_ns1__ListBucket::Signature = NULL;
	this->_ns1__ListBucket::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__ListBucket::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__ListBucket::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__ListBucket::Bucket);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListBucket::Prefix);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListBucket::Marker);
	soap_serialize_PointerToint(soap, &this->_ns1__ListBucket::MaxKeys);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListBucket::Delimiter);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListBucket::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__ListBucket::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListBucket::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ListBucket::Credential);
	/* transient soap skipped */
}

int _ns1__ListBucket::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ListBucket(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ListBucket(struct soap *soap, const char *tag, int id, const _ns1__ListBucket *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ListBucket), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__ListBucket::Bucket), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Prefix", -1, &(a->_ns1__ListBucket::Prefix), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Marker", -1, &(a->_ns1__ListBucket::Marker), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns1:MaxKeys", -1, &(a->_ns1__ListBucket::MaxKeys), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Delimiter", -1, &(a->_ns1__ListBucket::Delimiter), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__ListBucket::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__ListBucket::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__ListBucket::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__ListBucket::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__ListBucket::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ListBucket(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ListBucket * SOAP_FMAC4 soap_in__ns1__ListBucket(struct soap *soap, const char *tag, _ns1__ListBucket *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ListBucket *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ListBucket, sizeof(_ns1__ListBucket), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ListBucket)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ListBucket *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Prefix1 = 1;
	size_t soap_flag_Marker1 = 1;
	size_t soap_flag_MaxKeys1 = 1;
	size_t soap_flag_Delimiter1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__ListBucket::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Prefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Prefix", &(a->_ns1__ListBucket::Prefix), "xsd:string"))
				{	soap_flag_Prefix1--;
					continue;
				}
			if (soap_flag_Marker1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Marker", &(a->_ns1__ListBucket::Marker), "xsd:string"))
				{	soap_flag_Marker1--;
					continue;
				}
			if (soap_flag_MaxKeys1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns1:MaxKeys", &(a->_ns1__ListBucket::MaxKeys), "xsd:int"))
				{	soap_flag_MaxKeys1--;
					continue;
				}
			if (soap_flag_Delimiter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Delimiter", &(a->_ns1__ListBucket::Delimiter), "xsd:string"))
				{	soap_flag_Delimiter1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__ListBucket::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__ListBucket::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__ListBucket::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__ListBucket::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ListBucket *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ListBucket, 0, sizeof(_ns1__ListBucket), 0, soap_copy__ns1__ListBucket);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__ListBucket::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ListBucket);
	if (this->soap_out(soap, tag?tag:"ns1:ListBucket", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ListBucket::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ListBucket(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ListBucket * SOAP_FMAC4 soap_get__ns1__ListBucket(struct soap *soap, _ns1__ListBucket *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ListBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__ListBucket * SOAP_FMAC2 soap_instantiate__ns1__ListBucket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ListBucket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ListBucket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListBucket);
		if (size)
			*size = sizeof(_ns1__ListBucket);
		((_ns1__ListBucket*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__ListBucket[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ListBucket);
		for (int i = 0; i < n; i++)
			((_ns1__ListBucket*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ListBucket*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ListBucket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ListBucket %p -> %p\n", q, p));
	*(_ns1__ListBucket*)p = *(_ns1__ListBucket*)q;
}

void _ns1__DeleteObjectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DeleteObjectResponse::DeleteObjectResponse = NULL;
	/* transient soap skipped */
}

void _ns1__DeleteObjectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Status(soap, &this->_ns1__DeleteObjectResponse::DeleteObjectResponse);
	/* transient soap skipped */
}

int _ns1__DeleteObjectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteObjectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteObjectResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteObjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteObjectResponse), type))
		return soap->error;
	if (a->DeleteObjectResponse)
		soap_element_result(soap, "ns1:DeleteObjectResponse");
	if (a->_ns1__DeleteObjectResponse::DeleteObjectResponse)
	{	if (soap_out_PointerTons1__Status(soap, "ns1:DeleteObjectResponse", -1, &a->_ns1__DeleteObjectResponse::DeleteObjectResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:DeleteObjectResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteObjectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteObjectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteObjectResponse * SOAP_FMAC4 soap_in__ns1__DeleteObjectResponse(struct soap *soap, const char *tag, _ns1__DeleteObjectResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteObjectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteObjectResponse, sizeof(_ns1__DeleteObjectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteObjectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteObjectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DeleteObjectResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeleteObjectResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "ns1:DeleteObjectResponse", &(a->_ns1__DeleteObjectResponse::DeleteObjectResponse), "ns1:Status"))
				{	soap_flag_DeleteObjectResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DeleteObjectResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteObjectResponse, 0, sizeof(_ns1__DeleteObjectResponse), 0, soap_copy__ns1__DeleteObjectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DeleteObjectResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__DeleteObjectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteObjectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteObjectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteObjectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteObjectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteObjectResponse * SOAP_FMAC4 soap_get__ns1__DeleteObjectResponse(struct soap *soap, _ns1__DeleteObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteObjectResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteObjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteObjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteObjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteObjectResponse);
		if (size)
			*size = sizeof(_ns1__DeleteObjectResponse);
		((_ns1__DeleteObjectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteObjectResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteObjectResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteObjectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteObjectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteObjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteObjectResponse %p -> %p\n", q, p));
	*(_ns1__DeleteObjectResponse*)p = *(_ns1__DeleteObjectResponse*)q;
}

void _ns1__DeleteObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__DeleteObject::Bucket);
	soap_default_std__string(soap, &this->_ns1__DeleteObject::Key);
	this->_ns1__DeleteObject::AWSAccessKeyId = NULL;
	this->_ns1__DeleteObject::Timestamp = NULL;
	this->_ns1__DeleteObject::Signature = NULL;
	this->_ns1__DeleteObject::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__DeleteObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__DeleteObject::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__DeleteObject::Bucket);
	soap_embedded(soap, &this->_ns1__DeleteObject::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__DeleteObject::Key);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DeleteObject::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__DeleteObject::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DeleteObject::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DeleteObject::Credential);
	/* transient soap skipped */
}

int _ns1__DeleteObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteObject(struct soap *soap, const char *tag, int id, const _ns1__DeleteObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteObject), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__DeleteObject::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__DeleteObject::Key), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__DeleteObject::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__DeleteObject::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__DeleteObject::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__DeleteObject::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteObject(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteObject * SOAP_FMAC4 soap_in__ns1__DeleteObject(struct soap *soap, const char *tag, _ns1__DeleteObject *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteObject, sizeof(_ns1__DeleteObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteObject *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__DeleteObject::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__DeleteObject::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__DeleteObject::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__DeleteObject::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__DeleteObject::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__DeleteObject::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteObject, 0, sizeof(_ns1__DeleteObject), 0, soap_copy__ns1__DeleteObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__DeleteObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteObject);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteObject", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteObject(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteObject * SOAP_FMAC4 soap_get__ns1__DeleteObject(struct soap *soap, _ns1__DeleteObject *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteObject * SOAP_FMAC2 soap_instantiate__ns1__DeleteObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteObject);
		if (size)
			*size = sizeof(_ns1__DeleteObject);
		((_ns1__DeleteObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteObject);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteObject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteObject %p -> %p\n", q, p));
	*(_ns1__DeleteObject*)p = *(_ns1__DeleteObject*)q;
}

void _ns1__PutObjectInlineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__PutObjectInlineResponse::PutObjectInlineResponse = NULL;
	/* transient soap skipped */
}

void _ns1__PutObjectInlineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PutObjectResult(soap, &this->_ns1__PutObjectInlineResponse::PutObjectInlineResponse);
	/* transient soap skipped */
}

int _ns1__PutObjectInlineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PutObjectInlineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PutObjectInlineResponse(struct soap *soap, const char *tag, int id, const _ns1__PutObjectInlineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PutObjectInlineResponse), type))
		return soap->error;
	if (a->PutObjectInlineResponse)
		soap_element_result(soap, "ns1:PutObjectInlineResponse");
	if (a->_ns1__PutObjectInlineResponse::PutObjectInlineResponse)
	{	if (soap_out_PointerTons1__PutObjectResult(soap, "ns1:PutObjectInlineResponse", -1, &a->_ns1__PutObjectInlineResponse::PutObjectInlineResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:PutObjectInlineResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PutObjectInlineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PutObjectInlineResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PutObjectInlineResponse * SOAP_FMAC4 soap_in__ns1__PutObjectInlineResponse(struct soap *soap, const char *tag, _ns1__PutObjectInlineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PutObjectInlineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PutObjectInlineResponse, sizeof(_ns1__PutObjectInlineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PutObjectInlineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PutObjectInlineResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PutObjectInlineResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PutObjectInlineResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PutObjectResult(soap, "ns1:PutObjectInlineResponse", &(a->_ns1__PutObjectInlineResponse::PutObjectInlineResponse), "ns1:PutObjectResult"))
				{	soap_flag_PutObjectInlineResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PutObjectInlineResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PutObjectInlineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PutObjectInlineResponse, 0, sizeof(_ns1__PutObjectInlineResponse), 0, soap_copy__ns1__PutObjectInlineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PutObjectInlineResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__PutObjectInlineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PutObjectInlineResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PutObjectInlineResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PutObjectInlineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PutObjectInlineResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PutObjectInlineResponse * SOAP_FMAC4 soap_get__ns1__PutObjectInlineResponse(struct soap *soap, _ns1__PutObjectInlineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PutObjectInlineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PutObjectInlineResponse * SOAP_FMAC2 soap_instantiate__ns1__PutObjectInlineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PutObjectInlineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PutObjectInlineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObjectInlineResponse);
		if (size)
			*size = sizeof(_ns1__PutObjectInlineResponse);
		((_ns1__PutObjectInlineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObjectInlineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PutObjectInlineResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PutObjectInlineResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PutObjectInlineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PutObjectInlineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PutObjectInlineResponse %p -> %p\n", q, p));
	*(_ns1__PutObjectInlineResponse*)p = *(_ns1__PutObjectInlineResponse*)q;
}

void _ns1__PutObjectInline::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__PutObjectInline::Bucket);
	soap_default_std__string(soap, &this->_ns1__PutObjectInline::Key);
	soap_default_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->_ns1__PutObjectInline::Metadata);
	this->_ns1__PutObjectInline::Data.xsd__base64Binary::soap_default(soap);
	soap_default_LONG64(soap, &this->_ns1__PutObjectInline::ContentLength);
	this->_ns1__PutObjectInline::AccessControlList = NULL;
	this->_ns1__PutObjectInline::StorageClass = NULL;
	this->_ns1__PutObjectInline::AWSAccessKeyId = NULL;
	this->_ns1__PutObjectInline::Timestamp = NULL;
	this->_ns1__PutObjectInline::Signature = NULL;
	this->_ns1__PutObjectInline::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__PutObjectInline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__PutObjectInline::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__PutObjectInline::Bucket);
	soap_embedded(soap, &this->_ns1__PutObjectInline::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__PutObjectInline::Key);
	soap_serialize_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->_ns1__PutObjectInline::Metadata);
	soap_embedded(soap, &this->_ns1__PutObjectInline::Data, SOAP_TYPE_xsd__base64Binary);
	this->_ns1__PutObjectInline::Data.soap_serialize(soap);
	soap_embedded(soap, &this->_ns1__PutObjectInline::ContentLength, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->_ns1__PutObjectInline::AccessControlList);
	soap_serialize_PointerTons1__StorageClass(soap, &this->_ns1__PutObjectInline::StorageClass);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PutObjectInline::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__PutObjectInline::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PutObjectInline::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PutObjectInline::Credential);
	/* transient soap skipped */
}

int _ns1__PutObjectInline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PutObjectInline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PutObjectInline(struct soap *soap, const char *tag, int id, const _ns1__PutObjectInline *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PutObjectInline), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__PutObjectInline::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__PutObjectInline::Key), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", -1, &(a->_ns1__PutObjectInline::Metadata), ""))
		return soap->error;
	if ((a->_ns1__PutObjectInline::Data).soap_out(soap, "ns1:Data", -1, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:ContentLength", -1, &(a->_ns1__PutObjectInline::ContentLength), ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", -1, &(a->_ns1__PutObjectInline::AccessControlList), ""))
		return soap->error;
	if (soap_out_PointerTons1__StorageClass(soap, "ns1:StorageClass", -1, &(a->_ns1__PutObjectInline::StorageClass), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__PutObjectInline::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__PutObjectInline::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__PutObjectInline::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__PutObjectInline::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PutObjectInline::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PutObjectInline(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PutObjectInline * SOAP_FMAC4 soap_in__ns1__PutObjectInline(struct soap *soap, const char *tag, _ns1__PutObjectInline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PutObjectInline *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PutObjectInline, sizeof(_ns1__PutObjectInline), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PutObjectInline)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PutObjectInline *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_ContentLength1 = 1;
	size_t soap_flag_AccessControlList1 = 1;
	size_t soap_flag_StorageClass1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__PutObjectInline::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__PutObjectInline::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", &(a->_ns1__PutObjectInline::Metadata), "ns1:MetadataEntry"))
					continue;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns1__PutObjectInline::Data).soap_in(soap, "ns1:Data", "xsd:base64Binary"))
				{	soap_flag_Data1--;
					continue;
				}
			if (soap_flag_ContentLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:ContentLength", &(a->_ns1__PutObjectInline::ContentLength), "xsd:long"))
				{	soap_flag_ContentLength1--;
					continue;
				}
			if (soap_flag_AccessControlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", &(a->_ns1__PutObjectInline::AccessControlList), "ns1:AccessControlList"))
				{	soap_flag_AccessControlList1--;
					continue;
				}
			if (soap_flag_StorageClass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StorageClass(soap, "ns1:StorageClass", &(a->_ns1__PutObjectInline::StorageClass), "ns1:StorageClass"))
				{	soap_flag_StorageClass1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__PutObjectInline::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__PutObjectInline::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__PutObjectInline::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__PutObjectInline::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PutObjectInline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PutObjectInline, 0, sizeof(_ns1__PutObjectInline), 0, soap_copy__ns1__PutObjectInline);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0 || a->_ns1__PutObjectInline::Metadata.size() > 100 || soap_flag_Data1 > 0 || soap_flag_ContentLength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__PutObjectInline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PutObjectInline);
	if (this->soap_out(soap, tag?tag:"ns1:PutObjectInline", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PutObjectInline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PutObjectInline(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PutObjectInline * SOAP_FMAC4 soap_get__ns1__PutObjectInline(struct soap *soap, _ns1__PutObjectInline *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PutObjectInline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PutObjectInline * SOAP_FMAC2 soap_instantiate__ns1__PutObjectInline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PutObjectInline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PutObjectInline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObjectInline);
		if (size)
			*size = sizeof(_ns1__PutObjectInline);
		((_ns1__PutObjectInline*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObjectInline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PutObjectInline);
		for (int i = 0; i < n; i++)
			((_ns1__PutObjectInline*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PutObjectInline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PutObjectInline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PutObjectInline %p -> %p\n", q, p));
	*(_ns1__PutObjectInline*)p = *(_ns1__PutObjectInline*)q;
}

void _ns1__PutObjectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__PutObjectResponse::PutObjectResponse = NULL;
	/* transient soap skipped */
}

void _ns1__PutObjectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PutObjectResult(soap, &this->_ns1__PutObjectResponse::PutObjectResponse);
	/* transient soap skipped */
}

int _ns1__PutObjectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PutObjectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PutObjectResponse(struct soap *soap, const char *tag, int id, const _ns1__PutObjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PutObjectResponse), type))
		return soap->error;
	if (a->PutObjectResponse)
		soap_element_result(soap, "ns1:PutObjectResponse");
	if (a->_ns1__PutObjectResponse::PutObjectResponse)
	{	if (soap_out_PointerTons1__PutObjectResult(soap, "ns1:PutObjectResponse", -1, &a->_ns1__PutObjectResponse::PutObjectResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:PutObjectResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PutObjectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PutObjectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PutObjectResponse * SOAP_FMAC4 soap_in__ns1__PutObjectResponse(struct soap *soap, const char *tag, _ns1__PutObjectResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PutObjectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PutObjectResponse, sizeof(_ns1__PutObjectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PutObjectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PutObjectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PutObjectResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PutObjectResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PutObjectResult(soap, "ns1:PutObjectResponse", &(a->_ns1__PutObjectResponse::PutObjectResponse), "ns1:PutObjectResult"))
				{	soap_flag_PutObjectResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:PutObjectResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PutObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PutObjectResponse, 0, sizeof(_ns1__PutObjectResponse), 0, soap_copy__ns1__PutObjectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PutObjectResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__PutObjectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PutObjectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:PutObjectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PutObjectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PutObjectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PutObjectResponse * SOAP_FMAC4 soap_get__ns1__PutObjectResponse(struct soap *soap, _ns1__PutObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PutObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PutObjectResponse * SOAP_FMAC2 soap_instantiate__ns1__PutObjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PutObjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PutObjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObjectResponse);
		if (size)
			*size = sizeof(_ns1__PutObjectResponse);
		((_ns1__PutObjectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObjectResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PutObjectResponse);
		for (int i = 0; i < n; i++)
			((_ns1__PutObjectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PutObjectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PutObjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PutObjectResponse %p -> %p\n", q, p));
	*(_ns1__PutObjectResponse*)p = *(_ns1__PutObjectResponse*)q;
}

void _ns1__PutObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__PutObject::Bucket);
	soap_default_std__string(soap, &this->_ns1__PutObject::Key);
	soap_default_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->_ns1__PutObject::Metadata);
	soap_default_LONG64(soap, &this->_ns1__PutObject::ContentLength);
	this->_ns1__PutObject::AccessControlList = NULL;
	this->_ns1__PutObject::StorageClass = NULL;
	this->_ns1__PutObject::AWSAccessKeyId = NULL;
	this->_ns1__PutObject::Timestamp = NULL;
	this->_ns1__PutObject::Signature = NULL;
	this->_ns1__PutObject::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__PutObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__PutObject::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__PutObject::Bucket);
	soap_embedded(soap, &this->_ns1__PutObject::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__PutObject::Key);
	soap_serialize_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->_ns1__PutObject::Metadata);
	soap_embedded(soap, &this->_ns1__PutObject::ContentLength, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->_ns1__PutObject::AccessControlList);
	soap_serialize_PointerTons1__StorageClass(soap, &this->_ns1__PutObject::StorageClass);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PutObject::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__PutObject::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PutObject::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__PutObject::Credential);
	/* transient soap skipped */
}

int _ns1__PutObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__PutObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__PutObject(struct soap *soap, const char *tag, int id, const _ns1__PutObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__PutObject), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__PutObject::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__PutObject::Key), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", -1, &(a->_ns1__PutObject::Metadata), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:ContentLength", -1, &(a->_ns1__PutObject::ContentLength), ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", -1, &(a->_ns1__PutObject::AccessControlList), ""))
		return soap->error;
	if (soap_out_PointerTons1__StorageClass(soap, "ns1:StorageClass", -1, &(a->_ns1__PutObject::StorageClass), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__PutObject::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__PutObject::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__PutObject::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__PutObject::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__PutObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__PutObject(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__PutObject * SOAP_FMAC4 soap_in__ns1__PutObject(struct soap *soap, const char *tag, _ns1__PutObject *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__PutObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__PutObject, sizeof(_ns1__PutObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__PutObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__PutObject *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_ContentLength1 = 1;
	size_t soap_flag_AccessControlList1 = 1;
	size_t soap_flag_StorageClass1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__PutObject::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__PutObject::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", &(a->_ns1__PutObject::Metadata), "ns1:MetadataEntry"))
					continue;
			if (soap_flag_ContentLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:ContentLength", &(a->_ns1__PutObject::ContentLength), "xsd:long"))
				{	soap_flag_ContentLength1--;
					continue;
				}
			if (soap_flag_AccessControlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", &(a->_ns1__PutObject::AccessControlList), "ns1:AccessControlList"))
				{	soap_flag_AccessControlList1--;
					continue;
				}
			if (soap_flag_StorageClass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StorageClass(soap, "ns1:StorageClass", &(a->_ns1__PutObject::StorageClass), "ns1:StorageClass"))
				{	soap_flag_StorageClass1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__PutObject::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__PutObject::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__PutObject::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__PutObject::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__PutObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__PutObject, 0, sizeof(_ns1__PutObject), 0, soap_copy__ns1__PutObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0 || a->_ns1__PutObject::Metadata.size() > 100 || soap_flag_ContentLength1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__PutObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__PutObject);
	if (this->soap_out(soap, tag?tag:"ns1:PutObject", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__PutObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__PutObject(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__PutObject * SOAP_FMAC4 soap_get__ns1__PutObject(struct soap *soap, _ns1__PutObject *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__PutObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__PutObject * SOAP_FMAC2 soap_instantiate__ns1__PutObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__PutObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__PutObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObject);
		if (size)
			*size = sizeof(_ns1__PutObject);
		((_ns1__PutObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__PutObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__PutObject);
		for (int i = 0; i < n; i++)
			((_ns1__PutObject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__PutObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__PutObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__PutObject %p -> %p\n", q, p));
	*(_ns1__PutObject*)p = *(_ns1__PutObject*)q;
}

void _ns1__GetObjectExtendedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetObjectExtendedResponse::GetObjectResponse = NULL;
	/* transient soap skipped */
}

void _ns1__GetObjectExtendedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GetObjectResult(soap, &this->_ns1__GetObjectExtendedResponse::GetObjectResponse);
	/* transient soap skipped */
}

int _ns1__GetObjectExtendedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObjectExtendedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObjectExtendedResponse(struct soap *soap, const char *tag, int id, const _ns1__GetObjectExtendedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObjectExtendedResponse), type))
		return soap->error;
	if (a->GetObjectResponse)
		soap_element_result(soap, "ns1:GetObjectResponse");
	if (a->_ns1__GetObjectExtendedResponse::GetObjectResponse)
	{	if (soap_out_PointerTons1__GetObjectResult(soap, "ns1:GetObjectResponse", -1, &a->_ns1__GetObjectExtendedResponse::GetObjectResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetObjectResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObjectExtendedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObjectExtendedResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObjectExtendedResponse * SOAP_FMAC4 soap_in__ns1__GetObjectExtendedResponse(struct soap *soap, const char *tag, _ns1__GetObjectExtendedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObjectExtendedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObjectExtendedResponse, sizeof(_ns1__GetObjectExtendedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetObjectExtendedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetObjectExtendedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetObjectResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetObjectResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GetObjectResult(soap, "ns1:GetObjectResponse", &(a->_ns1__GetObjectExtendedResponse::GetObjectResponse), "ns1:GetObjectResult"))
				{	soap_flag_GetObjectResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetObjectResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObjectExtendedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObjectExtendedResponse, 0, sizeof(_ns1__GetObjectExtendedResponse), 0, soap_copy__ns1__GetObjectExtendedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetObjectResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetObjectExtendedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetObjectExtendedResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetObjectExtendedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObjectExtendedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObjectExtendedResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObjectExtendedResponse * SOAP_FMAC4 soap_get__ns1__GetObjectExtendedResponse(struct soap *soap, _ns1__GetObjectExtendedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObjectExtendedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetObjectExtendedResponse * SOAP_FMAC2 soap_instantiate__ns1__GetObjectExtendedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObjectExtendedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetObjectExtendedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectExtendedResponse);
		if (size)
			*size = sizeof(_ns1__GetObjectExtendedResponse);
		((_ns1__GetObjectExtendedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectExtendedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetObjectExtendedResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetObjectExtendedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetObjectExtendedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetObjectExtendedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetObjectExtendedResponse %p -> %p\n", q, p));
	*(_ns1__GetObjectExtendedResponse*)p = *(_ns1__GetObjectExtendedResponse*)q;
}

void _ns1__GetObjectExtended::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__GetObjectExtended::Bucket);
	soap_default_std__string(soap, &this->_ns1__GetObjectExtended::Key);
	soap_default_bool(soap, &this->_ns1__GetObjectExtended::GetMetadata);
	soap_default_bool(soap, &this->_ns1__GetObjectExtended::GetData);
	soap_default_bool(soap, &this->_ns1__GetObjectExtended::InlineData);
	this->_ns1__GetObjectExtended::ByteRangeStart = NULL;
	this->_ns1__GetObjectExtended::ByteRangeEnd = NULL;
	this->_ns1__GetObjectExtended::IfModifiedSince = NULL;
	this->_ns1__GetObjectExtended::IfUnmodifiedSince = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns1__GetObjectExtended::IfMatch);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_ns1__GetObjectExtended::IfNoneMatch);
	this->_ns1__GetObjectExtended::ReturnCompleteObjectOnConditionFailure = NULL;
	this->_ns1__GetObjectExtended::AWSAccessKeyId = NULL;
	this->_ns1__GetObjectExtended::Timestamp = NULL;
	this->_ns1__GetObjectExtended::Signature = NULL;
	this->_ns1__GetObjectExtended::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__GetObjectExtended::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__GetObjectExtended::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetObjectExtended::Bucket);
	soap_embedded(soap, &this->_ns1__GetObjectExtended::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetObjectExtended::Key);
	soap_embedded(soap, &this->_ns1__GetObjectExtended::GetMetadata, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_ns1__GetObjectExtended::GetData, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_ns1__GetObjectExtended::InlineData, SOAP_TYPE_bool);
	soap_serialize_PointerToLONG64(soap, &this->_ns1__GetObjectExtended::ByteRangeStart);
	soap_serialize_PointerToLONG64(soap, &this->_ns1__GetObjectExtended::ByteRangeEnd);
	soap_serialize_PointerTotime(soap, &this->_ns1__GetObjectExtended::IfModifiedSince);
	soap_serialize_PointerTotime(soap, &this->_ns1__GetObjectExtended::IfUnmodifiedSince);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns1__GetObjectExtended::IfMatch);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_ns1__GetObjectExtended::IfNoneMatch);
	soap_serialize_PointerTobool(soap, &this->_ns1__GetObjectExtended::ReturnCompleteObjectOnConditionFailure);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObjectExtended::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__GetObjectExtended::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObjectExtended::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObjectExtended::Credential);
	/* transient soap skipped */
}

int _ns1__GetObjectExtended::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObjectExtended(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObjectExtended(struct soap *soap, const char *tag, int id, const _ns1__GetObjectExtended *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObjectExtended), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__GetObjectExtended::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__GetObjectExtended::Key), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:GetMetadata", -1, &(a->_ns1__GetObjectExtended::GetMetadata), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:GetData", -1, &(a->_ns1__GetObjectExtended::GetData), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:InlineData", -1, &(a->_ns1__GetObjectExtended::InlineData), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns1:ByteRangeStart", -1, &(a->_ns1__GetObjectExtended::ByteRangeStart), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "ns1:ByteRangeEnd", -1, &(a->_ns1__GetObjectExtended::ByteRangeEnd), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:IfModifiedSince", -1, &(a->_ns1__GetObjectExtended::IfModifiedSince), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:IfUnmodifiedSince", -1, &(a->_ns1__GetObjectExtended::IfUnmodifiedSince), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:IfMatch", -1, &(a->_ns1__GetObjectExtended::IfMatch), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns1:IfNoneMatch", -1, &(a->_ns1__GetObjectExtended::IfNoneMatch), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns1:ReturnCompleteObjectOnConditionFailure", -1, &(a->_ns1__GetObjectExtended::ReturnCompleteObjectOnConditionFailure), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__GetObjectExtended::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__GetObjectExtended::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__GetObjectExtended::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__GetObjectExtended::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObjectExtended::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObjectExtended(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObjectExtended * SOAP_FMAC4 soap_in__ns1__GetObjectExtended(struct soap *soap, const char *tag, _ns1__GetObjectExtended *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObjectExtended *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObjectExtended, sizeof(_ns1__GetObjectExtended), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetObjectExtended)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetObjectExtended *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_GetMetadata1 = 1;
	size_t soap_flag_GetData1 = 1;
	size_t soap_flag_InlineData1 = 1;
	size_t soap_flag_ByteRangeStart1 = 1;
	size_t soap_flag_ByteRangeEnd1 = 1;
	size_t soap_flag_IfModifiedSince1 = 1;
	size_t soap_flag_IfUnmodifiedSince1 = 1;
	size_t soap_flag_ReturnCompleteObjectOnConditionFailure1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__GetObjectExtended::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__GetObjectExtended::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_GetMetadata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:GetMetadata", &(a->_ns1__GetObjectExtended::GetMetadata), "xsd:boolean"))
				{	soap_flag_GetMetadata1--;
					continue;
				}
			if (soap_flag_GetData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:GetData", &(a->_ns1__GetObjectExtended::GetData), "xsd:boolean"))
				{	soap_flag_GetData1--;
					continue;
				}
			if (soap_flag_InlineData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:InlineData", &(a->_ns1__GetObjectExtended::InlineData), "xsd:boolean"))
				{	soap_flag_InlineData1--;
					continue;
				}
			if (soap_flag_ByteRangeStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns1:ByteRangeStart", &(a->_ns1__GetObjectExtended::ByteRangeStart), "xsd:long"))
				{	soap_flag_ByteRangeStart1--;
					continue;
				}
			if (soap_flag_ByteRangeEnd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "ns1:ByteRangeEnd", &(a->_ns1__GetObjectExtended::ByteRangeEnd), "xsd:long"))
				{	soap_flag_ByteRangeEnd1--;
					continue;
				}
			if (soap_flag_IfModifiedSince1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:IfModifiedSince", &(a->_ns1__GetObjectExtended::IfModifiedSince), "xsd:dateTime"))
				{	soap_flag_IfModifiedSince1--;
					continue;
				}
			if (soap_flag_IfUnmodifiedSince1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:IfUnmodifiedSince", &(a->_ns1__GetObjectExtended::IfUnmodifiedSince), "xsd:dateTime"))
				{	soap_flag_IfUnmodifiedSince1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:IfMatch", &(a->_ns1__GetObjectExtended::IfMatch), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:IfNoneMatch", &(a->_ns1__GetObjectExtended::IfNoneMatch), "xsd:string"))
					continue;
			if (soap_flag_ReturnCompleteObjectOnConditionFailure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns1:ReturnCompleteObjectOnConditionFailure", &(a->_ns1__GetObjectExtended::ReturnCompleteObjectOnConditionFailure), "xsd:boolean"))
				{	soap_flag_ReturnCompleteObjectOnConditionFailure1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__GetObjectExtended::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__GetObjectExtended::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__GetObjectExtended::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__GetObjectExtended::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObjectExtended *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObjectExtended, 0, sizeof(_ns1__GetObjectExtended), 0, soap_copy__ns1__GetObjectExtended);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0 || soap_flag_GetMetadata1 > 0 || soap_flag_GetData1 > 0 || soap_flag_InlineData1 > 0 || a->_ns1__GetObjectExtended::IfMatch.size() > 100 || a->_ns1__GetObjectExtended::IfNoneMatch.size() > 100))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetObjectExtended::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetObjectExtended);
	if (this->soap_out(soap, tag?tag:"ns1:GetObjectExtended", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObjectExtended::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObjectExtended(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObjectExtended * SOAP_FMAC4 soap_get__ns1__GetObjectExtended(struct soap *soap, _ns1__GetObjectExtended *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObjectExtended(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetObjectExtended * SOAP_FMAC2 soap_instantiate__ns1__GetObjectExtended(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObjectExtended(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetObjectExtended, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectExtended);
		if (size)
			*size = sizeof(_ns1__GetObjectExtended);
		((_ns1__GetObjectExtended*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectExtended[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetObjectExtended);
		for (int i = 0; i < n; i++)
			((_ns1__GetObjectExtended*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetObjectExtended*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetObjectExtended(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetObjectExtended %p -> %p\n", q, p));
	*(_ns1__GetObjectExtended*)p = *(_ns1__GetObjectExtended*)q;
}

void _ns1__GetObjectResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetObjectResponse::GetObjectResponse = NULL;
	/* transient soap skipped */
}

void _ns1__GetObjectResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GetObjectResult(soap, &this->_ns1__GetObjectResponse::GetObjectResponse);
	/* transient soap skipped */
}

int _ns1__GetObjectResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObjectResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObjectResponse(struct soap *soap, const char *tag, int id, const _ns1__GetObjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObjectResponse), type))
		return soap->error;
	if (a->GetObjectResponse)
		soap_element_result(soap, "ns1:GetObjectResponse");
	if (a->_ns1__GetObjectResponse::GetObjectResponse)
	{	if (soap_out_PointerTons1__GetObjectResult(soap, "ns1:GetObjectResponse", -1, &a->_ns1__GetObjectResponse::GetObjectResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetObjectResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObjectResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObjectResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObjectResponse * SOAP_FMAC4 soap_in__ns1__GetObjectResponse(struct soap *soap, const char *tag, _ns1__GetObjectResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObjectResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObjectResponse, sizeof(_ns1__GetObjectResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetObjectResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetObjectResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetObjectResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetObjectResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GetObjectResult(soap, "ns1:GetObjectResponse", &(a->_ns1__GetObjectResponse::GetObjectResponse), "ns1:GetObjectResult"))
				{	soap_flag_GetObjectResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetObjectResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObjectResponse, 0, sizeof(_ns1__GetObjectResponse), 0, soap_copy__ns1__GetObjectResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetObjectResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetObjectResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetObjectResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetObjectResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObjectResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObjectResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObjectResponse * SOAP_FMAC4 soap_get__ns1__GetObjectResponse(struct soap *soap, _ns1__GetObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetObjectResponse * SOAP_FMAC2 soap_instantiate__ns1__GetObjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetObjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectResponse);
		if (size)
			*size = sizeof(_ns1__GetObjectResponse);
		((_ns1__GetObjectResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetObjectResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetObjectResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetObjectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetObjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetObjectResponse %p -> %p\n", q, p));
	*(_ns1__GetObjectResponse*)p = *(_ns1__GetObjectResponse*)q;
}

void _ns1__GetObject::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__GetObject::Bucket);
	soap_default_std__string(soap, &this->_ns1__GetObject::Key);
	soap_default_bool(soap, &this->_ns1__GetObject::GetMetadata);
	soap_default_bool(soap, &this->_ns1__GetObject::GetData);
	soap_default_bool(soap, &this->_ns1__GetObject::InlineData);
	this->_ns1__GetObject::AWSAccessKeyId = NULL;
	this->_ns1__GetObject::Timestamp = NULL;
	this->_ns1__GetObject::Signature = NULL;
	this->_ns1__GetObject::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__GetObject::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__GetObject::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetObject::Bucket);
	soap_embedded(soap, &this->_ns1__GetObject::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetObject::Key);
	soap_embedded(soap, &this->_ns1__GetObject::GetMetadata, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_ns1__GetObject::GetData, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_ns1__GetObject::InlineData, SOAP_TYPE_bool);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObject::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__GetObject::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObject::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObject::Credential);
	/* transient soap skipped */
}

int _ns1__GetObject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObject(struct soap *soap, const char *tag, int id, const _ns1__GetObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObject), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__GetObject::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__GetObject::Key), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:GetMetadata", -1, &(a->_ns1__GetObject::GetMetadata), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:GetData", -1, &(a->_ns1__GetObject::GetData), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:InlineData", -1, &(a->_ns1__GetObject::InlineData), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__GetObject::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__GetObject::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__GetObject::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__GetObject::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObject(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObject * SOAP_FMAC4 soap_in__ns1__GetObject(struct soap *soap, const char *tag, _ns1__GetObject *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObject, sizeof(_ns1__GetObject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetObject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetObject *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_GetMetadata1 = 1;
	size_t soap_flag_GetData1 = 1;
	size_t soap_flag_InlineData1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__GetObject::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__GetObject::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_GetMetadata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:GetMetadata", &(a->_ns1__GetObject::GetMetadata), "xsd:boolean"))
				{	soap_flag_GetMetadata1--;
					continue;
				}
			if (soap_flag_GetData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:GetData", &(a->_ns1__GetObject::GetData), "xsd:boolean"))
				{	soap_flag_GetData1--;
					continue;
				}
			if (soap_flag_InlineData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:InlineData", &(a->_ns1__GetObject::InlineData), "xsd:boolean"))
				{	soap_flag_InlineData1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__GetObject::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__GetObject::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__GetObject::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__GetObject::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObject, 0, sizeof(_ns1__GetObject), 0, soap_copy__ns1__GetObject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0 || soap_flag_GetMetadata1 > 0 || soap_flag_GetData1 > 0 || soap_flag_InlineData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetObject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetObject);
	if (this->soap_out(soap, tag?tag:"ns1:GetObject", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObject(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObject * SOAP_FMAC4 soap_get__ns1__GetObject(struct soap *soap, _ns1__GetObject *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetObject * SOAP_FMAC2 soap_instantiate__ns1__GetObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObject);
		if (size)
			*size = sizeof(_ns1__GetObject);
		((_ns1__GetObject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetObject);
		for (int i = 0; i < n; i++)
			((_ns1__GetObject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetObject %p -> %p\n", q, p));
	*(_ns1__GetObject*)p = *(_ns1__GetObject*)q;
}

void _ns1__SetBucketAccessControlPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__SetBucketAccessControlPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetBucketAccessControlPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetBucketAccessControlPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__SetBucketAccessControlPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetBucketAccessControlPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetBucketAccessControlPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicyResponse * SOAP_FMAC4 soap_in__ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__SetBucketAccessControlPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetBucketAccessControlPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse, sizeof(_ns1__SetBucketAccessControlPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetBucketAccessControlPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetBucketAccessControlPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse, 0, sizeof(_ns1__SetBucketAccessControlPolicyResponse), 0, soap_copy__ns1__SetBucketAccessControlPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetBucketAccessControlPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SetBucketAccessControlPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetBucketAccessControlPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetBucketAccessControlPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicyResponse * SOAP_FMAC4 soap_get__ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__SetBucketAccessControlPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetBucketAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetBucketAccessControlPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetBucketAccessControlPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketAccessControlPolicyResponse);
		if (size)
			*size = sizeof(_ns1__SetBucketAccessControlPolicyResponse);
		((_ns1__SetBucketAccessControlPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketAccessControlPolicyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetBucketAccessControlPolicyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetBucketAccessControlPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetBucketAccessControlPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetBucketAccessControlPolicyResponse %p -> %p\n", q, p));
	*(_ns1__SetBucketAccessControlPolicyResponse*)p = *(_ns1__SetBucketAccessControlPolicyResponse*)q;
}

void _ns1__SetBucketAccessControlPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__SetBucketAccessControlPolicy::Bucket);
	this->_ns1__SetBucketAccessControlPolicy::AccessControlList = NULL;
	this->_ns1__SetBucketAccessControlPolicy::AWSAccessKeyId = NULL;
	this->_ns1__SetBucketAccessControlPolicy::Timestamp = NULL;
	this->_ns1__SetBucketAccessControlPolicy::Signature = NULL;
	this->_ns1__SetBucketAccessControlPolicy::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__SetBucketAccessControlPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__SetBucketAccessControlPolicy::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__SetBucketAccessControlPolicy::Bucket);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->_ns1__SetBucketAccessControlPolicy::AccessControlList);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetBucketAccessControlPolicy::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__SetBucketAccessControlPolicy::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetBucketAccessControlPolicy::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetBucketAccessControlPolicy::Credential);
	/* transient soap skipped */
}

int _ns1__SetBucketAccessControlPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetBucketAccessControlPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetBucketAccessControlPolicy(struct soap *soap, const char *tag, int id, const _ns1__SetBucketAccessControlPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetBucketAccessControlPolicy), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__SetBucketAccessControlPolicy::Bucket), ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", -1, &(a->_ns1__SetBucketAccessControlPolicy::AccessControlList), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__SetBucketAccessControlPolicy::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__SetBucketAccessControlPolicy::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__SetBucketAccessControlPolicy::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__SetBucketAccessControlPolicy::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetBucketAccessControlPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetBucketAccessControlPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicy * SOAP_FMAC4 soap_in__ns1__SetBucketAccessControlPolicy(struct soap *soap, const char *tag, _ns1__SetBucketAccessControlPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetBucketAccessControlPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetBucketAccessControlPolicy, sizeof(_ns1__SetBucketAccessControlPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetBucketAccessControlPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetBucketAccessControlPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_AccessControlList1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__SetBucketAccessControlPolicy::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_AccessControlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", &(a->_ns1__SetBucketAccessControlPolicy::AccessControlList), "ns1:AccessControlList"))
				{	soap_flag_AccessControlList1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__SetBucketAccessControlPolicy::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__SetBucketAccessControlPolicy::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__SetBucketAccessControlPolicy::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__SetBucketAccessControlPolicy::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetBucketAccessControlPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetBucketAccessControlPolicy, 0, sizeof(_ns1__SetBucketAccessControlPolicy), 0, soap_copy__ns1__SetBucketAccessControlPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__SetBucketAccessControlPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetBucketAccessControlPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:SetBucketAccessControlPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetBucketAccessControlPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetBucketAccessControlPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicy * SOAP_FMAC4 soap_get__ns1__SetBucketAccessControlPolicy(struct soap *soap, _ns1__SetBucketAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetBucketAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetBucketAccessControlPolicy * SOAP_FMAC2 soap_instantiate__ns1__SetBucketAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetBucketAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetBucketAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketAccessControlPolicy);
		if (size)
			*size = sizeof(_ns1__SetBucketAccessControlPolicy);
		((_ns1__SetBucketAccessControlPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetBucketAccessControlPolicy);
		for (int i = 0; i < n; i++)
			((_ns1__SetBucketAccessControlPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetBucketAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetBucketAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetBucketAccessControlPolicy %p -> %p\n", q, p));
	*(_ns1__SetBucketAccessControlPolicy*)p = *(_ns1__SetBucketAccessControlPolicy*)q;
}

void _ns1__SetObjectAccessControlPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__SetObjectAccessControlPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetObjectAccessControlPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetObjectAccessControlPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__SetObjectAccessControlPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetObjectAccessControlPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetObjectAccessControlPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicyResponse * SOAP_FMAC4 soap_in__ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__SetObjectAccessControlPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetObjectAccessControlPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse, sizeof(_ns1__SetObjectAccessControlPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetObjectAccessControlPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetObjectAccessControlPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse, 0, sizeof(_ns1__SetObjectAccessControlPolicyResponse), 0, soap_copy__ns1__SetObjectAccessControlPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetObjectAccessControlPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SetObjectAccessControlPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetObjectAccessControlPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetObjectAccessControlPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicyResponse * SOAP_FMAC4 soap_get__ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__SetObjectAccessControlPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetObjectAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetObjectAccessControlPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetObjectAccessControlPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetObjectAccessControlPolicyResponse);
		if (size)
			*size = sizeof(_ns1__SetObjectAccessControlPolicyResponse);
		((_ns1__SetObjectAccessControlPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetObjectAccessControlPolicyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetObjectAccessControlPolicyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetObjectAccessControlPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetObjectAccessControlPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetObjectAccessControlPolicyResponse %p -> %p\n", q, p));
	*(_ns1__SetObjectAccessControlPolicyResponse*)p = *(_ns1__SetObjectAccessControlPolicyResponse*)q;
}

void _ns1__SetObjectAccessControlPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__SetObjectAccessControlPolicy::Bucket);
	soap_default_std__string(soap, &this->_ns1__SetObjectAccessControlPolicy::Key);
	this->_ns1__SetObjectAccessControlPolicy::AccessControlList = NULL;
	this->_ns1__SetObjectAccessControlPolicy::AWSAccessKeyId = NULL;
	this->_ns1__SetObjectAccessControlPolicy::Timestamp = NULL;
	this->_ns1__SetObjectAccessControlPolicy::Signature = NULL;
	this->_ns1__SetObjectAccessControlPolicy::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__SetObjectAccessControlPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__SetObjectAccessControlPolicy::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__SetObjectAccessControlPolicy::Bucket);
	soap_embedded(soap, &this->_ns1__SetObjectAccessControlPolicy::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__SetObjectAccessControlPolicy::Key);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->_ns1__SetObjectAccessControlPolicy::AccessControlList);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetObjectAccessControlPolicy::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__SetObjectAccessControlPolicy::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetObjectAccessControlPolicy::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetObjectAccessControlPolicy::Credential);
	/* transient soap skipped */
}

int _ns1__SetObjectAccessControlPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetObjectAccessControlPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetObjectAccessControlPolicy(struct soap *soap, const char *tag, int id, const _ns1__SetObjectAccessControlPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetObjectAccessControlPolicy), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__SetObjectAccessControlPolicy::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__SetObjectAccessControlPolicy::Key), ""))
		return soap->error;
	if (a->_ns1__SetObjectAccessControlPolicy::AccessControlList)
	{	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", -1, &a->_ns1__SetObjectAccessControlPolicy::AccessControlList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:AccessControlList"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__SetObjectAccessControlPolicy::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__SetObjectAccessControlPolicy::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__SetObjectAccessControlPolicy::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__SetObjectAccessControlPolicy::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetObjectAccessControlPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetObjectAccessControlPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicy * SOAP_FMAC4 soap_in__ns1__SetObjectAccessControlPolicy(struct soap *soap, const char *tag, _ns1__SetObjectAccessControlPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetObjectAccessControlPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetObjectAccessControlPolicy, sizeof(_ns1__SetObjectAccessControlPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetObjectAccessControlPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetObjectAccessControlPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_AccessControlList1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__SetObjectAccessControlPolicy::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__SetObjectAccessControlPolicy::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_AccessControlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", &(a->_ns1__SetObjectAccessControlPolicy::AccessControlList), "ns1:AccessControlList"))
				{	soap_flag_AccessControlList1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__SetObjectAccessControlPolicy::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__SetObjectAccessControlPolicy::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__SetObjectAccessControlPolicy::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__SetObjectAccessControlPolicy::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetObjectAccessControlPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetObjectAccessControlPolicy, 0, sizeof(_ns1__SetObjectAccessControlPolicy), 0, soap_copy__ns1__SetObjectAccessControlPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0 || soap_flag_AccessControlList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__SetObjectAccessControlPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetObjectAccessControlPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:SetObjectAccessControlPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetObjectAccessControlPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetObjectAccessControlPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicy * SOAP_FMAC4 soap_get__ns1__SetObjectAccessControlPolicy(struct soap *soap, _ns1__SetObjectAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetObjectAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetObjectAccessControlPolicy * SOAP_FMAC2 soap_instantiate__ns1__SetObjectAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetObjectAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetObjectAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetObjectAccessControlPolicy);
		if (size)
			*size = sizeof(_ns1__SetObjectAccessControlPolicy);
		((_ns1__SetObjectAccessControlPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetObjectAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetObjectAccessControlPolicy);
		for (int i = 0; i < n; i++)
			((_ns1__SetObjectAccessControlPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetObjectAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetObjectAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetObjectAccessControlPolicy %p -> %p\n", q, p));
	*(_ns1__SetObjectAccessControlPolicy*)p = *(_ns1__SetObjectAccessControlPolicy*)q;
}

void _ns1__GetBucketAccessControlPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetBucketAccessControlPolicyResponse::GetBucketAccessControlPolicyResponse = NULL;
	/* transient soap skipped */
}

void _ns1__GetBucketAccessControlPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccessControlPolicy(soap, &this->_ns1__GetBucketAccessControlPolicyResponse::GetBucketAccessControlPolicyResponse);
	/* transient soap skipped */
}

int _ns1__GetBucketAccessControlPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBucketAccessControlPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetBucketAccessControlPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse), type))
		return soap->error;
	if (a->GetBucketAccessControlPolicyResponse)
		soap_element_result(soap, "ns1:GetBucketAccessControlPolicyResponse");
	if (a->_ns1__GetBucketAccessControlPolicyResponse::GetBucketAccessControlPolicyResponse)
	{	if (soap_out_PointerTons1__AccessControlPolicy(soap, "ns1:GetBucketAccessControlPolicyResponse", -1, &a->_ns1__GetBucketAccessControlPolicyResponse::GetBucketAccessControlPolicyResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetBucketAccessControlPolicyResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBucketAccessControlPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBucketAccessControlPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicyResponse * SOAP_FMAC4 soap_in__ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__GetBucketAccessControlPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBucketAccessControlPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse, sizeof(_ns1__GetBucketAccessControlPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBucketAccessControlPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetBucketAccessControlPolicyResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetBucketAccessControlPolicyResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlPolicy(soap, "ns1:GetBucketAccessControlPolicyResponse", &(a->_ns1__GetBucketAccessControlPolicyResponse::GetBucketAccessControlPolicyResponse), "ns1:AccessControlPolicy"))
				{	soap_flag_GetBucketAccessControlPolicyResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetBucketAccessControlPolicyResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBucketAccessControlPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse, 0, sizeof(_ns1__GetBucketAccessControlPolicyResponse), 0, soap_copy__ns1__GetBucketAccessControlPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetBucketAccessControlPolicyResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetBucketAccessControlPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetBucketAccessControlPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBucketAccessControlPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBucketAccessControlPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicyResponse * SOAP_FMAC4 soap_get__ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__GetBucketAccessControlPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBucketAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBucketAccessControlPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBucketAccessControlPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketAccessControlPolicyResponse);
		if (size)
			*size = sizeof(_ns1__GetBucketAccessControlPolicyResponse);
		((_ns1__GetBucketAccessControlPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketAccessControlPolicyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBucketAccessControlPolicyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetBucketAccessControlPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBucketAccessControlPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBucketAccessControlPolicyResponse %p -> %p\n", q, p));
	*(_ns1__GetBucketAccessControlPolicyResponse*)p = *(_ns1__GetBucketAccessControlPolicyResponse*)q;
}

void _ns1__GetBucketAccessControlPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__GetBucketAccessControlPolicy::Bucket);
	this->_ns1__GetBucketAccessControlPolicy::AWSAccessKeyId = NULL;
	this->_ns1__GetBucketAccessControlPolicy::Timestamp = NULL;
	this->_ns1__GetBucketAccessControlPolicy::Signature = NULL;
	this->_ns1__GetBucketAccessControlPolicy::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__GetBucketAccessControlPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__GetBucketAccessControlPolicy::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetBucketAccessControlPolicy::Bucket);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetBucketAccessControlPolicy::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__GetBucketAccessControlPolicy::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetBucketAccessControlPolicy::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetBucketAccessControlPolicy::Credential);
	/* transient soap skipped */
}

int _ns1__GetBucketAccessControlPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBucketAccessControlPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBucketAccessControlPolicy(struct soap *soap, const char *tag, int id, const _ns1__GetBucketAccessControlPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBucketAccessControlPolicy), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__GetBucketAccessControlPolicy::Bucket), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__GetBucketAccessControlPolicy::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__GetBucketAccessControlPolicy::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__GetBucketAccessControlPolicy::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__GetBucketAccessControlPolicy::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBucketAccessControlPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBucketAccessControlPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicy * SOAP_FMAC4 soap_in__ns1__GetBucketAccessControlPolicy(struct soap *soap, const char *tag, _ns1__GetBucketAccessControlPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBucketAccessControlPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBucketAccessControlPolicy, sizeof(_ns1__GetBucketAccessControlPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBucketAccessControlPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBucketAccessControlPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__GetBucketAccessControlPolicy::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__GetBucketAccessControlPolicy::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__GetBucketAccessControlPolicy::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__GetBucketAccessControlPolicy::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__GetBucketAccessControlPolicy::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBucketAccessControlPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBucketAccessControlPolicy, 0, sizeof(_ns1__GetBucketAccessControlPolicy), 0, soap_copy__ns1__GetBucketAccessControlPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetBucketAccessControlPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBucketAccessControlPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:GetBucketAccessControlPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBucketAccessControlPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBucketAccessControlPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicy * SOAP_FMAC4 soap_get__ns1__GetBucketAccessControlPolicy(struct soap *soap, _ns1__GetBucketAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBucketAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBucketAccessControlPolicy * SOAP_FMAC2 soap_instantiate__ns1__GetBucketAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBucketAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBucketAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketAccessControlPolicy);
		if (size)
			*size = sizeof(_ns1__GetBucketAccessControlPolicy);
		((_ns1__GetBucketAccessControlPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBucketAccessControlPolicy);
		for (int i = 0; i < n; i++)
			((_ns1__GetBucketAccessControlPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBucketAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBucketAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBucketAccessControlPolicy %p -> %p\n", q, p));
	*(_ns1__GetBucketAccessControlPolicy*)p = *(_ns1__GetBucketAccessControlPolicy*)q;
}

void _ns1__GetObjectAccessControlPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetObjectAccessControlPolicyResponse::GetObjectAccessControlPolicyResponse = NULL;
	/* transient soap skipped */
}

void _ns1__GetObjectAccessControlPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccessControlPolicy(soap, &this->_ns1__GetObjectAccessControlPolicyResponse::GetObjectAccessControlPolicyResponse);
	/* transient soap skipped */
}

int _ns1__GetObjectAccessControlPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObjectAccessControlPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, const _ns1__GetObjectAccessControlPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse), type))
		return soap->error;
	if (a->GetObjectAccessControlPolicyResponse)
		soap_element_result(soap, "ns1:GetObjectAccessControlPolicyResponse");
	if (a->_ns1__GetObjectAccessControlPolicyResponse::GetObjectAccessControlPolicyResponse)
	{	if (soap_out_PointerTons1__AccessControlPolicy(soap, "ns1:GetObjectAccessControlPolicyResponse", -1, &a->_ns1__GetObjectAccessControlPolicyResponse::GetObjectAccessControlPolicyResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetObjectAccessControlPolicyResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObjectAccessControlPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObjectAccessControlPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicyResponse * SOAP_FMAC4 soap_in__ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__GetObjectAccessControlPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObjectAccessControlPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse, sizeof(_ns1__GetObjectAccessControlPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetObjectAccessControlPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetObjectAccessControlPolicyResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetObjectAccessControlPolicyResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlPolicy(soap, "ns1:GetObjectAccessControlPolicyResponse", &(a->_ns1__GetObjectAccessControlPolicyResponse::GetObjectAccessControlPolicyResponse), "ns1:AccessControlPolicy"))
				{	soap_flag_GetObjectAccessControlPolicyResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetObjectAccessControlPolicyResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObjectAccessControlPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse, 0, sizeof(_ns1__GetObjectAccessControlPolicyResponse), 0, soap_copy__ns1__GetObjectAccessControlPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetObjectAccessControlPolicyResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetObjectAccessControlPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetObjectAccessControlPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObjectAccessControlPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObjectAccessControlPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicyResponse * SOAP_FMAC4 soap_get__ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__GetObjectAccessControlPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObjectAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetObjectAccessControlPolicyResponse * SOAP_FMAC2 soap_instantiate__ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObjectAccessControlPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectAccessControlPolicyResponse);
		if (size)
			*size = sizeof(_ns1__GetObjectAccessControlPolicyResponse);
		((_ns1__GetObjectAccessControlPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectAccessControlPolicyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetObjectAccessControlPolicyResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetObjectAccessControlPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetObjectAccessControlPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetObjectAccessControlPolicyResponse %p -> %p\n", q, p));
	*(_ns1__GetObjectAccessControlPolicyResponse*)p = *(_ns1__GetObjectAccessControlPolicyResponse*)q;
}

void _ns1__GetObjectAccessControlPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__GetObjectAccessControlPolicy::Bucket);
	soap_default_std__string(soap, &this->_ns1__GetObjectAccessControlPolicy::Key);
	this->_ns1__GetObjectAccessControlPolicy::AWSAccessKeyId = NULL;
	this->_ns1__GetObjectAccessControlPolicy::Timestamp = NULL;
	this->_ns1__GetObjectAccessControlPolicy::Signature = NULL;
	this->_ns1__GetObjectAccessControlPolicy::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__GetObjectAccessControlPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__GetObjectAccessControlPolicy::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetObjectAccessControlPolicy::Bucket);
	soap_embedded(soap, &this->_ns1__GetObjectAccessControlPolicy::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetObjectAccessControlPolicy::Key);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObjectAccessControlPolicy::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__GetObjectAccessControlPolicy::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObjectAccessControlPolicy::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetObjectAccessControlPolicy::Credential);
	/* transient soap skipped */
}

int _ns1__GetObjectAccessControlPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetObjectAccessControlPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetObjectAccessControlPolicy(struct soap *soap, const char *tag, int id, const _ns1__GetObjectAccessControlPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetObjectAccessControlPolicy), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__GetObjectAccessControlPolicy::Bucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->_ns1__GetObjectAccessControlPolicy::Key), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__GetObjectAccessControlPolicy::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__GetObjectAccessControlPolicy::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__GetObjectAccessControlPolicy::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__GetObjectAccessControlPolicy::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetObjectAccessControlPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetObjectAccessControlPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicy * SOAP_FMAC4 soap_in__ns1__GetObjectAccessControlPolicy(struct soap *soap, const char *tag, _ns1__GetObjectAccessControlPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetObjectAccessControlPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetObjectAccessControlPolicy, sizeof(_ns1__GetObjectAccessControlPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetObjectAccessControlPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetObjectAccessControlPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__GetObjectAccessControlPolicy::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->_ns1__GetObjectAccessControlPolicy::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__GetObjectAccessControlPolicy::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__GetObjectAccessControlPolicy::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__GetObjectAccessControlPolicy::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__GetObjectAccessControlPolicy::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetObjectAccessControlPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetObjectAccessControlPolicy, 0, sizeof(_ns1__GetObjectAccessControlPolicy), 0, soap_copy__ns1__GetObjectAccessControlPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_Key1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetObjectAccessControlPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetObjectAccessControlPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:GetObjectAccessControlPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetObjectAccessControlPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetObjectAccessControlPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicy * SOAP_FMAC4 soap_get__ns1__GetObjectAccessControlPolicy(struct soap *soap, _ns1__GetObjectAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetObjectAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetObjectAccessControlPolicy * SOAP_FMAC2 soap_instantiate__ns1__GetObjectAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetObjectAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetObjectAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectAccessControlPolicy);
		if (size)
			*size = sizeof(_ns1__GetObjectAccessControlPolicy);
		((_ns1__GetObjectAccessControlPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetObjectAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetObjectAccessControlPolicy);
		for (int i = 0; i < n; i++)
			((_ns1__GetObjectAccessControlPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetObjectAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetObjectAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetObjectAccessControlPolicy %p -> %p\n", q, p));
	*(_ns1__GetObjectAccessControlPolicy*)p = *(_ns1__GetObjectAccessControlPolicy*)q;
}

void _ns1__SetBucketLoggingStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__SetBucketLoggingStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SetBucketLoggingStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetBucketLoggingStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetBucketLoggingStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__SetBucketLoggingStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetBucketLoggingStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetBucketLoggingStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatusResponse * SOAP_FMAC4 soap_in__ns1__SetBucketLoggingStatusResponse(struct soap *soap, const char *tag, _ns1__SetBucketLoggingStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetBucketLoggingStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse, sizeof(_ns1__SetBucketLoggingStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetBucketLoggingStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetBucketLoggingStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetBucketLoggingStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse, 0, sizeof(_ns1__SetBucketLoggingStatusResponse), 0, soap_copy__ns1__SetBucketLoggingStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SetBucketLoggingStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SetBucketLoggingStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetBucketLoggingStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetBucketLoggingStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatusResponse * SOAP_FMAC4 soap_get__ns1__SetBucketLoggingStatusResponse(struct soap *soap, _ns1__SetBucketLoggingStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetBucketLoggingStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetBucketLoggingStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__SetBucketLoggingStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetBucketLoggingStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketLoggingStatusResponse);
		if (size)
			*size = sizeof(_ns1__SetBucketLoggingStatusResponse);
		((_ns1__SetBucketLoggingStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketLoggingStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetBucketLoggingStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SetBucketLoggingStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetBucketLoggingStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetBucketLoggingStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetBucketLoggingStatusResponse %p -> %p\n", q, p));
	*(_ns1__SetBucketLoggingStatusResponse*)p = *(_ns1__SetBucketLoggingStatusResponse*)q;
}

void _ns1__SetBucketLoggingStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__SetBucketLoggingStatus::Bucket);
	this->_ns1__SetBucketLoggingStatus::AWSAccessKeyId = NULL;
	this->_ns1__SetBucketLoggingStatus::Timestamp = NULL;
	this->_ns1__SetBucketLoggingStatus::Signature = NULL;
	this->_ns1__SetBucketLoggingStatus::Credential = NULL;
	this->_ns1__SetBucketLoggingStatus::BucketLoggingStatus = NULL;
	/* transient soap skipped */
}

void _ns1__SetBucketLoggingStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__SetBucketLoggingStatus::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__SetBucketLoggingStatus::Bucket);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetBucketLoggingStatus::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__SetBucketLoggingStatus::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetBucketLoggingStatus::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetBucketLoggingStatus::Credential);
	soap_serialize_PointerTons1__BucketLoggingStatus(soap, &this->_ns1__SetBucketLoggingStatus::BucketLoggingStatus);
	/* transient soap skipped */
}

int _ns1__SetBucketLoggingStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetBucketLoggingStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetBucketLoggingStatus(struct soap *soap, const char *tag, int id, const _ns1__SetBucketLoggingStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetBucketLoggingStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__SetBucketLoggingStatus::Bucket), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__SetBucketLoggingStatus::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__SetBucketLoggingStatus::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__SetBucketLoggingStatus::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__SetBucketLoggingStatus::Credential), ""))
		return soap->error;
	if (a->_ns1__SetBucketLoggingStatus::BucketLoggingStatus)
	{	if (soap_out_PointerTons1__BucketLoggingStatus(soap, "ns1:BucketLoggingStatus", -1, &a->_ns1__SetBucketLoggingStatus::BucketLoggingStatus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:BucketLoggingStatus"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetBucketLoggingStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetBucketLoggingStatus(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatus * SOAP_FMAC4 soap_in__ns1__SetBucketLoggingStatus(struct soap *soap, const char *tag, _ns1__SetBucketLoggingStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetBucketLoggingStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetBucketLoggingStatus, sizeof(_ns1__SetBucketLoggingStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SetBucketLoggingStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SetBucketLoggingStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	size_t soap_flag_BucketLoggingStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__SetBucketLoggingStatus::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__SetBucketLoggingStatus::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__SetBucketLoggingStatus::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__SetBucketLoggingStatus::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__SetBucketLoggingStatus::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			if (soap_flag_BucketLoggingStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BucketLoggingStatus(soap, "ns1:BucketLoggingStatus", &(a->_ns1__SetBucketLoggingStatus::BucketLoggingStatus), "ns1:BucketLoggingStatus"))
				{	soap_flag_BucketLoggingStatus1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetBucketLoggingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetBucketLoggingStatus, 0, sizeof(_ns1__SetBucketLoggingStatus), 0, soap_copy__ns1__SetBucketLoggingStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0 || soap_flag_BucketLoggingStatus1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__SetBucketLoggingStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SetBucketLoggingStatus);
	if (this->soap_out(soap, tag?tag:"ns1:SetBucketLoggingStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetBucketLoggingStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetBucketLoggingStatus(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatus * SOAP_FMAC4 soap_get__ns1__SetBucketLoggingStatus(struct soap *soap, _ns1__SetBucketLoggingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetBucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SetBucketLoggingStatus * SOAP_FMAC2 soap_instantiate__ns1__SetBucketLoggingStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetBucketLoggingStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SetBucketLoggingStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketLoggingStatus);
		if (size)
			*size = sizeof(_ns1__SetBucketLoggingStatus);
		((_ns1__SetBucketLoggingStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__SetBucketLoggingStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SetBucketLoggingStatus);
		for (int i = 0; i < n; i++)
			((_ns1__SetBucketLoggingStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SetBucketLoggingStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SetBucketLoggingStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SetBucketLoggingStatus %p -> %p\n", q, p));
	*(_ns1__SetBucketLoggingStatus*)p = *(_ns1__SetBucketLoggingStatus*)q;
}

void _ns1__GetBucketLoggingStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetBucketLoggingStatusResponse::GetBucketLoggingStatusResponse = NULL;
	/* transient soap skipped */
}

void _ns1__GetBucketLoggingStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BucketLoggingStatus(soap, &this->_ns1__GetBucketLoggingStatusResponse::GetBucketLoggingStatusResponse);
	/* transient soap skipped */
}

int _ns1__GetBucketLoggingStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBucketLoggingStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBucketLoggingStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__GetBucketLoggingStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse), type))
		return soap->error;
	if (a->GetBucketLoggingStatusResponse)
		soap_element_result(soap, "ns1:GetBucketLoggingStatusResponse");
	if (a->_ns1__GetBucketLoggingStatusResponse::GetBucketLoggingStatusResponse)
	{	if (soap_out_PointerTons1__BucketLoggingStatus(soap, "ns1:GetBucketLoggingStatusResponse", -1, &a->_ns1__GetBucketLoggingStatusResponse::GetBucketLoggingStatusResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:GetBucketLoggingStatusResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBucketLoggingStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBucketLoggingStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatusResponse * SOAP_FMAC4 soap_in__ns1__GetBucketLoggingStatusResponse(struct soap *soap, const char *tag, _ns1__GetBucketLoggingStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBucketLoggingStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse, sizeof(_ns1__GetBucketLoggingStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBucketLoggingStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBucketLoggingStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetBucketLoggingStatusResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetBucketLoggingStatusResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BucketLoggingStatus(soap, "ns1:GetBucketLoggingStatusResponse", &(a->_ns1__GetBucketLoggingStatusResponse::GetBucketLoggingStatusResponse), "ns1:BucketLoggingStatus"))
				{	soap_flag_GetBucketLoggingStatusResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetBucketLoggingStatusResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBucketLoggingStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse, 0, sizeof(_ns1__GetBucketLoggingStatusResponse), 0, soap_copy__ns1__GetBucketLoggingStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetBucketLoggingStatusResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetBucketLoggingStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetBucketLoggingStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBucketLoggingStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBucketLoggingStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatusResponse * SOAP_FMAC4 soap_get__ns1__GetBucketLoggingStatusResponse(struct soap *soap, _ns1__GetBucketLoggingStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBucketLoggingStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBucketLoggingStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__GetBucketLoggingStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBucketLoggingStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketLoggingStatusResponse);
		if (size)
			*size = sizeof(_ns1__GetBucketLoggingStatusResponse);
		((_ns1__GetBucketLoggingStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketLoggingStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBucketLoggingStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetBucketLoggingStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBucketLoggingStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBucketLoggingStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBucketLoggingStatusResponse %p -> %p\n", q, p));
	*(_ns1__GetBucketLoggingStatusResponse*)p = *(_ns1__GetBucketLoggingStatusResponse*)q;
}

void _ns1__GetBucketLoggingStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__GetBucketLoggingStatus::Bucket);
	this->_ns1__GetBucketLoggingStatus::AWSAccessKeyId = NULL;
	this->_ns1__GetBucketLoggingStatus::Timestamp = NULL;
	this->_ns1__GetBucketLoggingStatus::Signature = NULL;
	this->_ns1__GetBucketLoggingStatus::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__GetBucketLoggingStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__GetBucketLoggingStatus::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetBucketLoggingStatus::Bucket);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetBucketLoggingStatus::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__GetBucketLoggingStatus::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetBucketLoggingStatus::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetBucketLoggingStatus::Credential);
	/* transient soap skipped */
}

int _ns1__GetBucketLoggingStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetBucketLoggingStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetBucketLoggingStatus(struct soap *soap, const char *tag, int id, const _ns1__GetBucketLoggingStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetBucketLoggingStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__GetBucketLoggingStatus::Bucket), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__GetBucketLoggingStatus::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__GetBucketLoggingStatus::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__GetBucketLoggingStatus::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__GetBucketLoggingStatus::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetBucketLoggingStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetBucketLoggingStatus(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatus * SOAP_FMAC4 soap_in__ns1__GetBucketLoggingStatus(struct soap *soap, const char *tag, _ns1__GetBucketLoggingStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetBucketLoggingStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetBucketLoggingStatus, sizeof(_ns1__GetBucketLoggingStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetBucketLoggingStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetBucketLoggingStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__GetBucketLoggingStatus::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__GetBucketLoggingStatus::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__GetBucketLoggingStatus::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__GetBucketLoggingStatus::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__GetBucketLoggingStatus::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetBucketLoggingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetBucketLoggingStatus, 0, sizeof(_ns1__GetBucketLoggingStatus), 0, soap_copy__ns1__GetBucketLoggingStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__GetBucketLoggingStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetBucketLoggingStatus);
	if (this->soap_out(soap, tag?tag:"ns1:GetBucketLoggingStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetBucketLoggingStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetBucketLoggingStatus(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatus * SOAP_FMAC4 soap_get__ns1__GetBucketLoggingStatus(struct soap *soap, _ns1__GetBucketLoggingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetBucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetBucketLoggingStatus * SOAP_FMAC2 soap_instantiate__ns1__GetBucketLoggingStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetBucketLoggingStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetBucketLoggingStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketLoggingStatus);
		if (size)
			*size = sizeof(_ns1__GetBucketLoggingStatus);
		((_ns1__GetBucketLoggingStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetBucketLoggingStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetBucketLoggingStatus);
		for (int i = 0; i < n; i++)
			((_ns1__GetBucketLoggingStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetBucketLoggingStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetBucketLoggingStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetBucketLoggingStatus %p -> %p\n", q, p));
	*(_ns1__GetBucketLoggingStatus*)p = *(_ns1__GetBucketLoggingStatus*)q;
}

void _ns1__DeleteBucketResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DeleteBucketResponse::DeleteBucketResponse = NULL;
	/* transient soap skipped */
}

void _ns1__DeleteBucketResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Status(soap, &this->_ns1__DeleteBucketResponse::DeleteBucketResponse);
	/* transient soap skipped */
}

int _ns1__DeleteBucketResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteBucketResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteBucketResponse(struct soap *soap, const char *tag, int id, const _ns1__DeleteBucketResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteBucketResponse), type))
		return soap->error;
	if (a->DeleteBucketResponse)
		soap_element_result(soap, "ns1:DeleteBucketResponse");
	if (a->_ns1__DeleteBucketResponse::DeleteBucketResponse)
	{	if (soap_out_PointerTons1__Status(soap, "ns1:DeleteBucketResponse", -1, &a->_ns1__DeleteBucketResponse::DeleteBucketResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:DeleteBucketResponse"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteBucketResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteBucketResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteBucketResponse * SOAP_FMAC4 soap_in__ns1__DeleteBucketResponse(struct soap *soap, const char *tag, _ns1__DeleteBucketResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteBucketResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteBucketResponse, sizeof(_ns1__DeleteBucketResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteBucketResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteBucketResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DeleteBucketResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeleteBucketResponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "ns1:DeleteBucketResponse", &(a->_ns1__DeleteBucketResponse::DeleteBucketResponse), "ns1:Status"))
				{	soap_flag_DeleteBucketResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:DeleteBucketResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteBucketResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteBucketResponse, 0, sizeof(_ns1__DeleteBucketResponse), 0, soap_copy__ns1__DeleteBucketResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DeleteBucketResponse1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__DeleteBucketResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteBucketResponse);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteBucketResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteBucketResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteBucketResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteBucketResponse * SOAP_FMAC4 soap_get__ns1__DeleteBucketResponse(struct soap *soap, _ns1__DeleteBucketResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteBucketResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteBucketResponse * SOAP_FMAC2 soap_instantiate__ns1__DeleteBucketResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteBucketResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteBucketResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteBucketResponse);
		if (size)
			*size = sizeof(_ns1__DeleteBucketResponse);
		((_ns1__DeleteBucketResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteBucketResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteBucketResponse);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteBucketResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteBucketResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteBucketResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteBucketResponse %p -> %p\n", q, p));
	*(_ns1__DeleteBucketResponse*)p = *(_ns1__DeleteBucketResponse*)q;
}

void _ns1__DeleteBucket::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__DeleteBucket::Bucket);
	this->_ns1__DeleteBucket::AWSAccessKeyId = NULL;
	this->_ns1__DeleteBucket::Timestamp = NULL;
	this->_ns1__DeleteBucket::Signature = NULL;
	this->_ns1__DeleteBucket::Credential = NULL;
	/* transient soap skipped */
}

void _ns1__DeleteBucket::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__DeleteBucket::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__DeleteBucket::Bucket);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DeleteBucket::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__DeleteBucket::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DeleteBucket::Signature);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DeleteBucket::Credential);
	/* transient soap skipped */
}

int _ns1__DeleteBucket::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DeleteBucket(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DeleteBucket(struct soap *soap, const char *tag, int id, const _ns1__DeleteBucket *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DeleteBucket), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__DeleteBucket::Bucket), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__DeleteBucket::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__DeleteBucket::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__DeleteBucket::Signature), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Credential", -1, &(a->_ns1__DeleteBucket::Credential), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__DeleteBucket::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DeleteBucket(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DeleteBucket * SOAP_FMAC4 soap_in__ns1__DeleteBucket(struct soap *soap, const char *tag, _ns1__DeleteBucket *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DeleteBucket *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DeleteBucket, sizeof(_ns1__DeleteBucket), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__DeleteBucket)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__DeleteBucket *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	size_t soap_flag_Credential1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__DeleteBucket::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__DeleteBucket::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__DeleteBucket::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__DeleteBucket::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			if (soap_flag_Credential1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Credential", &(a->_ns1__DeleteBucket::Credential), "xsd:string"))
				{	soap_flag_Credential1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__DeleteBucket *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DeleteBucket, 0, sizeof(_ns1__DeleteBucket), 0, soap_copy__ns1__DeleteBucket);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__DeleteBucket::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__DeleteBucket);
	if (this->soap_out(soap, tag?tag:"ns1:DeleteBucket", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DeleteBucket::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DeleteBucket(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DeleteBucket * SOAP_FMAC4 soap_get__ns1__DeleteBucket(struct soap *soap, _ns1__DeleteBucket *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DeleteBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__DeleteBucket * SOAP_FMAC2 soap_instantiate__ns1__DeleteBucket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DeleteBucket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__DeleteBucket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteBucket);
		if (size)
			*size = sizeof(_ns1__DeleteBucket);
		((_ns1__DeleteBucket*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__DeleteBucket[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__DeleteBucket);
		for (int i = 0; i < n; i++)
			((_ns1__DeleteBucket*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__DeleteBucket*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__DeleteBucket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__DeleteBucket %p -> %p\n", q, p));
	*(_ns1__DeleteBucket*)p = *(_ns1__DeleteBucket*)q;
}

void _ns1__CreateBucketResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CreateBucketResponse::CreateBucketReturn = NULL;
	/* transient soap skipped */
}

void _ns1__CreateBucketResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CreateBucketResult(soap, &this->_ns1__CreateBucketResponse::CreateBucketReturn);
	/* transient soap skipped */
}

int _ns1__CreateBucketResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateBucketResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateBucketResponse(struct soap *soap, const char *tag, int id, const _ns1__CreateBucketResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateBucketResponse), type))
		return soap->error;
	if (a->CreateBucketReturn)
		soap_element_result(soap, "ns1:CreateBucketReturn");
	if (a->_ns1__CreateBucketResponse::CreateBucketReturn)
	{	if (soap_out_PointerTons1__CreateBucketResult(soap, "ns1:CreateBucketReturn", -1, &a->_ns1__CreateBucketResponse::CreateBucketReturn, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:CreateBucketReturn"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateBucketResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateBucketResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateBucketResponse * SOAP_FMAC4 soap_in__ns1__CreateBucketResponse(struct soap *soap, const char *tag, _ns1__CreateBucketResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateBucketResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateBucketResponse, sizeof(_ns1__CreateBucketResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CreateBucketResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CreateBucketResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CreateBucketReturn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CreateBucketReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CreateBucketResult(soap, "ns1:CreateBucketReturn", &(a->_ns1__CreateBucketResponse::CreateBucketReturn), "ns1:CreateBucketResult"))
				{	soap_flag_CreateBucketReturn1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:CreateBucketReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CreateBucketResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateBucketResponse, 0, sizeof(_ns1__CreateBucketResponse), 0, soap_copy__ns1__CreateBucketResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CreateBucketReturn1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__CreateBucketResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CreateBucketResponse);
	if (this->soap_out(soap, tag?tag:"ns1:CreateBucketResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateBucketResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateBucketResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateBucketResponse * SOAP_FMAC4 soap_get__ns1__CreateBucketResponse(struct soap *soap, _ns1__CreateBucketResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateBucketResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CreateBucketResponse * SOAP_FMAC2 soap_instantiate__ns1__CreateBucketResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateBucketResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CreateBucketResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CreateBucketResponse);
		if (size)
			*size = sizeof(_ns1__CreateBucketResponse);
		((_ns1__CreateBucketResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CreateBucketResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CreateBucketResponse);
		for (int i = 0; i < n; i++)
			((_ns1__CreateBucketResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CreateBucketResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CreateBucketResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CreateBucketResponse %p -> %p\n", q, p));
	*(_ns1__CreateBucketResponse*)p = *(_ns1__CreateBucketResponse*)q;
}

void _ns1__CreateBucket::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__CreateBucket::Bucket);
	this->_ns1__CreateBucket::AccessControlList = NULL;
	this->_ns1__CreateBucket::AWSAccessKeyId = NULL;
	this->_ns1__CreateBucket::Timestamp = NULL;
	this->_ns1__CreateBucket::Signature = NULL;
	/* transient soap skipped */
}

void _ns1__CreateBucket::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_ns1__CreateBucket::Bucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__CreateBucket::Bucket);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->_ns1__CreateBucket::AccessControlList);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CreateBucket::AWSAccessKeyId);
	soap_serialize_PointerTotime(soap, &this->_ns1__CreateBucket::Timestamp);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CreateBucket::Signature);
	/* transient soap skipped */
}

int _ns1__CreateBucket::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CreateBucket(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CreateBucket(struct soap *soap, const char *tag, int id, const _ns1__CreateBucket *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CreateBucket), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Bucket", -1, &(a->_ns1__CreateBucket::Bucket), ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", -1, &(a->_ns1__CreateBucket::AccessControlList), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:AWSAccessKeyId", -1, &(a->_ns1__CreateBucket::AWSAccessKeyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "ns1:Timestamp", -1, &(a->_ns1__CreateBucket::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Signature", -1, &(a->_ns1__CreateBucket::Signature), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CreateBucket::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CreateBucket(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CreateBucket * SOAP_FMAC4 soap_in__ns1__CreateBucket(struct soap *soap, const char *tag, _ns1__CreateBucket *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CreateBucket *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CreateBucket, sizeof(_ns1__CreateBucket), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CreateBucket)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CreateBucket *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Bucket1 = 1;
	size_t soap_flag_AccessControlList1 = 1;
	size_t soap_flag_AWSAccessKeyId1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_Signature1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Bucket", &(a->_ns1__CreateBucket::Bucket), "xsd:string"))
				{	soap_flag_Bucket1--;
					continue;
				}
			if (soap_flag_AccessControlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", &(a->_ns1__CreateBucket::AccessControlList), "ns1:AccessControlList"))
				{	soap_flag_AccessControlList1--;
					continue;
				}
			if (soap_flag_AWSAccessKeyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:AWSAccessKeyId", &(a->_ns1__CreateBucket::AWSAccessKeyId), "xsd:string"))
				{	soap_flag_AWSAccessKeyId1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "ns1:Timestamp", &(a->_ns1__CreateBucket::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_Signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Signature", &(a->_ns1__CreateBucket::Signature), "xsd:string"))
				{	soap_flag_Signature1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CreateBucket *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CreateBucket, 0, sizeof(_ns1__CreateBucket), 0, soap_copy__ns1__CreateBucket);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Bucket1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__CreateBucket::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CreateBucket);
	if (this->soap_out(soap, tag?tag:"ns1:CreateBucket", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CreateBucket::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CreateBucket(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CreateBucket * SOAP_FMAC4 soap_get__ns1__CreateBucket(struct soap *soap, _ns1__CreateBucket *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CreateBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CreateBucket * SOAP_FMAC2 soap_instantiate__ns1__CreateBucket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CreateBucket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CreateBucket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CreateBucket);
		if (size)
			*size = sizeof(_ns1__CreateBucket);
		((_ns1__CreateBucket*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CreateBucket[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__CreateBucket);
		for (int i = 0; i < n; i++)
			((_ns1__CreateBucket*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__CreateBucket*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CreateBucket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CreateBucket %p -> %p\n", q, p));
	*(_ns1__CreateBucket*)p = *(_ns1__CreateBucket*)q;
}

void ns1__RequestPaymentConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__Payer(soap, &this->ns1__RequestPaymentConfiguration::Payer);
	/* transient soap skipped */
}

void ns1__RequestPaymentConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__RequestPaymentConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RequestPaymentConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RequestPaymentConfiguration(struct soap *soap, const char *tag, int id, const ns1__RequestPaymentConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RequestPaymentConfiguration), type))
		return soap->error;
	if (soap_out_ns1__Payer(soap, "ns1:Payer", -1, &(a->ns1__RequestPaymentConfiguration::Payer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__RequestPaymentConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RequestPaymentConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RequestPaymentConfiguration * SOAP_FMAC4 soap_in_ns1__RequestPaymentConfiguration(struct soap *soap, const char *tag, ns1__RequestPaymentConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RequestPaymentConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RequestPaymentConfiguration, sizeof(ns1__RequestPaymentConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RequestPaymentConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RequestPaymentConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Payer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Payer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__Payer(soap, "ns1:Payer", &(a->ns1__RequestPaymentConfiguration::Payer), "ns1:Payer"))
				{	soap_flag_Payer1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RequestPaymentConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RequestPaymentConfiguration, 0, sizeof(ns1__RequestPaymentConfiguration), 0, soap_copy_ns1__RequestPaymentConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Payer1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__RequestPaymentConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RequestPaymentConfiguration);
	if (this->soap_out(soap, tag?tag:"ns1:RequestPaymentConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RequestPaymentConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RequestPaymentConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RequestPaymentConfiguration * SOAP_FMAC4 soap_get_ns1__RequestPaymentConfiguration(struct soap *soap, ns1__RequestPaymentConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RequestPaymentConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__RequestPaymentConfiguration * SOAP_FMAC2 soap_instantiate_ns1__RequestPaymentConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RequestPaymentConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RequestPaymentConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__RequestPaymentConfiguration);
		if (size)
			*size = sizeof(ns1__RequestPaymentConfiguration);
		((ns1__RequestPaymentConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__RequestPaymentConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RequestPaymentConfiguration);
		for (int i = 0; i < n; i++)
			((ns1__RequestPaymentConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RequestPaymentConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RequestPaymentConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RequestPaymentConfiguration %p -> %p\n", q, p));
	*(ns1__RequestPaymentConfiguration*)p = *(ns1__RequestPaymentConfiguration*)q;
}

void ns1__CopyObjectResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->ns1__CopyObjectResult::LastModified);
	soap_default_std__string(soap, &this->ns1__CopyObjectResult::ETag);
	/* transient soap skipped */
}

void ns1__CopyObjectResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CopyObjectResult::LastModified, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns1__CopyObjectResult::ETag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CopyObjectResult::ETag);
	/* transient soap skipped */
}

int ns1__CopyObjectResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CopyObjectResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CopyObjectResult(struct soap *soap, const char *tag, int id, const ns1__CopyObjectResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CopyObjectResult), type))
		return soap->error;
	if (soap_out_time(soap, "ns1:LastModified", -1, &(a->ns1__CopyObjectResult::LastModified), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ETag", -1, &(a->ns1__CopyObjectResult::ETag), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CopyObjectResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CopyObjectResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CopyObjectResult * SOAP_FMAC4 soap_in_ns1__CopyObjectResult(struct soap *soap, const char *tag, ns1__CopyObjectResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CopyObjectResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CopyObjectResult, sizeof(ns1__CopyObjectResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CopyObjectResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CopyObjectResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LastModified1 = 1;
	size_t soap_flag_ETag1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LastModified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LastModified", &(a->ns1__CopyObjectResult::LastModified), "xsd:dateTime"))
				{	soap_flag_LastModified1--;
					continue;
				}
			if (soap_flag_ETag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ETag", &(a->ns1__CopyObjectResult::ETag), "xsd:string"))
				{	soap_flag_ETag1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CopyObjectResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CopyObjectResult, 0, sizeof(ns1__CopyObjectResult), 0, soap_copy_ns1__CopyObjectResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LastModified1 > 0 || soap_flag_ETag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CopyObjectResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CopyObjectResult);
	if (this->soap_out(soap, tag?tag:"ns1:CopyObjectResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CopyObjectResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CopyObjectResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CopyObjectResult * SOAP_FMAC4 soap_get_ns1__CopyObjectResult(struct soap *soap, ns1__CopyObjectResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CopyObjectResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CopyObjectResult * SOAP_FMAC2 soap_instantiate_ns1__CopyObjectResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CopyObjectResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CopyObjectResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CopyObjectResult);
		if (size)
			*size = sizeof(ns1__CopyObjectResult);
		((ns1__CopyObjectResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CopyObjectResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CopyObjectResult);
		for (int i = 0; i < n; i++)
			((ns1__CopyObjectResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CopyObjectResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CopyObjectResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CopyObjectResult %p -> %p\n", q, p));
	*(ns1__CopyObjectResult*)p = *(ns1__CopyObjectResult*)q;
}

void ns1__ListAllMyBucketsList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(soap, &this->ns1__ListAllMyBucketsList::Bucket);
	/* transient soap skipped */
}

void ns1__ListAllMyBucketsList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(soap, &this->ns1__ListAllMyBucketsList::Bucket);
	/* transient soap skipped */
}

int ns1__ListAllMyBucketsList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListAllMyBucketsList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListAllMyBucketsList(struct soap *soap, const char *tag, int id, const ns1__ListAllMyBucketsList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListAllMyBucketsList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(soap, "ns1:Bucket", -1, &(a->ns1__ListAllMyBucketsList::Bucket), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListAllMyBucketsList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListAllMyBucketsList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsList * SOAP_FMAC4 soap_in_ns1__ListAllMyBucketsList(struct soap *soap, const char *tag, ns1__ListAllMyBucketsList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListAllMyBucketsList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListAllMyBucketsList, sizeof(ns1__ListAllMyBucketsList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListAllMyBucketsList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListAllMyBucketsList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(soap, "ns1:Bucket", &(a->ns1__ListAllMyBucketsList::Bucket), "ns1:ListAllMyBucketsEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListAllMyBucketsList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListAllMyBucketsList, 0, sizeof(ns1__ListAllMyBucketsList), 0, soap_copy_ns1__ListAllMyBucketsList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__ListAllMyBucketsList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListAllMyBucketsList);
	if (this->soap_out(soap, tag?tag:"ns1:ListAllMyBucketsList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ListAllMyBucketsList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListAllMyBucketsList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsList * SOAP_FMAC4 soap_get_ns1__ListAllMyBucketsList(struct soap *soap, ns1__ListAllMyBucketsList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListAllMyBucketsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ListAllMyBucketsList * SOAP_FMAC2 soap_instantiate_ns1__ListAllMyBucketsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListAllMyBucketsList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListAllMyBucketsList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListAllMyBucketsList);
		if (size)
			*size = sizeof(ns1__ListAllMyBucketsList);
		((ns1__ListAllMyBucketsList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListAllMyBucketsList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListAllMyBucketsList);
		for (int i = 0; i < n; i++)
			((ns1__ListAllMyBucketsList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListAllMyBucketsList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListAllMyBucketsList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListAllMyBucketsList %p -> %p\n", q, p));
	*(ns1__ListAllMyBucketsList*)p = *(ns1__ListAllMyBucketsList*)q;
}

void ns1__ListAllMyBucketsResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ListAllMyBucketsResult::Owner = NULL;
	this->ns1__ListAllMyBucketsResult::Buckets = NULL;
	/* transient soap skipped */
}

void ns1__ListAllMyBucketsResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CanonicalUser(soap, &this->ns1__ListAllMyBucketsResult::Owner);
	soap_serialize_PointerTons1__ListAllMyBucketsList(soap, &this->ns1__ListAllMyBucketsResult::Buckets);
	/* transient soap skipped */
}

int ns1__ListAllMyBucketsResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListAllMyBucketsResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListAllMyBucketsResult(struct soap *soap, const char *tag, int id, const ns1__ListAllMyBucketsResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListAllMyBucketsResult), type))
		return soap->error;
	if (a->ns1__ListAllMyBucketsResult::Owner)
	{	if (soap_out_PointerTons1__CanonicalUser(soap, "ns1:Owner", -1, &a->ns1__ListAllMyBucketsResult::Owner, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Owner"))
		return soap->error;
	if (a->ns1__ListAllMyBucketsResult::Buckets)
	{	if (soap_out_PointerTons1__ListAllMyBucketsList(soap, "ns1:Buckets", -1, &a->ns1__ListAllMyBucketsResult::Buckets, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Buckets"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListAllMyBucketsResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListAllMyBucketsResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsResult * SOAP_FMAC4 soap_in_ns1__ListAllMyBucketsResult(struct soap *soap, const char *tag, ns1__ListAllMyBucketsResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListAllMyBucketsResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListAllMyBucketsResult, sizeof(ns1__ListAllMyBucketsResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListAllMyBucketsResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListAllMyBucketsResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Owner1 = 1;
	size_t soap_flag_Buckets1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CanonicalUser(soap, "ns1:Owner", &(a->ns1__ListAllMyBucketsResult::Owner), "ns1:CanonicalUser"))
				{	soap_flag_Owner1--;
					continue;
				}
			if (soap_flag_Buckets1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ListAllMyBucketsList(soap, "ns1:Buckets", &(a->ns1__ListAllMyBucketsResult::Buckets), "ns1:ListAllMyBucketsList"))
				{	soap_flag_Buckets1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListAllMyBucketsResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListAllMyBucketsResult, 0, sizeof(ns1__ListAllMyBucketsResult), 0, soap_copy_ns1__ListAllMyBucketsResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Owner1 > 0 || soap_flag_Buckets1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ListAllMyBucketsResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListAllMyBucketsResult);
	if (this->soap_out(soap, tag?tag:"ns1:ListAllMyBucketsResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ListAllMyBucketsResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListAllMyBucketsResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsResult * SOAP_FMAC4 soap_get_ns1__ListAllMyBucketsResult(struct soap *soap, ns1__ListAllMyBucketsResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListAllMyBucketsResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ListAllMyBucketsResult * SOAP_FMAC2 soap_instantiate_ns1__ListAllMyBucketsResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListAllMyBucketsResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListAllMyBucketsResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListAllMyBucketsResult);
		if (size)
			*size = sizeof(ns1__ListAllMyBucketsResult);
		((ns1__ListAllMyBucketsResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListAllMyBucketsResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListAllMyBucketsResult);
		for (int i = 0; i < n; i++)
			((ns1__ListAllMyBucketsResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListAllMyBucketsResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListAllMyBucketsResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListAllMyBucketsResult %p -> %p\n", q, p));
	*(ns1__ListAllMyBucketsResult*)p = *(ns1__ListAllMyBucketsResult*)q;
}

void ns1__ListAllMyBucketsEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ListAllMyBucketsEntry::Name);
	soap_default_time(soap, &this->ns1__ListAllMyBucketsEntry::CreationDate);
	/* transient soap skipped */
}

void ns1__ListAllMyBucketsEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ListAllMyBucketsEntry::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListAllMyBucketsEntry::Name);
	soap_embedded(soap, &this->ns1__ListAllMyBucketsEntry::CreationDate, SOAP_TYPE_time);
	/* transient soap skipped */
}

int ns1__ListAllMyBucketsEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListAllMyBucketsEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListAllMyBucketsEntry(struct soap *soap, const char *tag, int id, const ns1__ListAllMyBucketsEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListAllMyBucketsEntry), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Name", -1, &(a->ns1__ListAllMyBucketsEntry::Name), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:CreationDate", -1, &(a->ns1__ListAllMyBucketsEntry::CreationDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListAllMyBucketsEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListAllMyBucketsEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsEntry * SOAP_FMAC4 soap_in_ns1__ListAllMyBucketsEntry(struct soap *soap, const char *tag, ns1__ListAllMyBucketsEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListAllMyBucketsEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListAllMyBucketsEntry, sizeof(ns1__ListAllMyBucketsEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListAllMyBucketsEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListAllMyBucketsEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_CreationDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Name", &(a->ns1__ListAllMyBucketsEntry::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_CreationDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:CreationDate", &(a->ns1__ListAllMyBucketsEntry::CreationDate), "xsd:dateTime"))
				{	soap_flag_CreationDate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListAllMyBucketsEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListAllMyBucketsEntry, 0, sizeof(ns1__ListAllMyBucketsEntry), 0, soap_copy_ns1__ListAllMyBucketsEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_CreationDate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ListAllMyBucketsEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListAllMyBucketsEntry);
	if (this->soap_out(soap, tag?tag:"ns1:ListAllMyBucketsEntry", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ListAllMyBucketsEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListAllMyBucketsEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsEntry * SOAP_FMAC4 soap_get_ns1__ListAllMyBucketsEntry(struct soap *soap, ns1__ListAllMyBucketsEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListAllMyBucketsEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ListAllMyBucketsEntry * SOAP_FMAC2 soap_instantiate_ns1__ListAllMyBucketsEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListAllMyBucketsEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListAllMyBucketsEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListAllMyBucketsEntry);
		if (size)
			*size = sizeof(ns1__ListAllMyBucketsEntry);
		((ns1__ListAllMyBucketsEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListAllMyBucketsEntry[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListAllMyBucketsEntry);
		for (int i = 0; i < n; i++)
			((ns1__ListAllMyBucketsEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListAllMyBucketsEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListAllMyBucketsEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListAllMyBucketsEntry %p -> %p\n", q, p));
	*(ns1__ListAllMyBucketsEntry*)p = *(ns1__ListAllMyBucketsEntry*)q;
}

void ns1__ListBucketResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->ns1__ListBucketResult::Metadata);
	soap_default_std__string(soap, &this->ns1__ListBucketResult::Name);
	soap_default_std__string(soap, &this->ns1__ListBucketResult::Prefix);
	soap_default_std__string(soap, &this->ns1__ListBucketResult::Marker);
	this->ns1__ListBucketResult::NextMarker = NULL;
	soap_default_int(soap, &this->ns1__ListBucketResult::MaxKeys);
	this->ns1__ListBucketResult::Delimiter = NULL;
	soap_default_bool(soap, &this->ns1__ListBucketResult::IsTruncated);
	soap_default_std__vectorTemplateOfPointerTons1__ListEntry(soap, &this->ns1__ListBucketResult::Contents);
	soap_default_std__vectorTemplateOfPointerTons1__PrefixEntry(soap, &this->ns1__ListBucketResult::CommonPrefixes);
	/* transient soap skipped */
}

void ns1__ListBucketResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->ns1__ListBucketResult::Metadata);
	soap_embedded(soap, &this->ns1__ListBucketResult::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListBucketResult::Name);
	soap_embedded(soap, &this->ns1__ListBucketResult::Prefix, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListBucketResult::Prefix);
	soap_embedded(soap, &this->ns1__ListBucketResult::Marker, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListBucketResult::Marker);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListBucketResult::NextMarker);
	soap_embedded(soap, &this->ns1__ListBucketResult::MaxKeys, SOAP_TYPE_int);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ListBucketResult::Delimiter);
	soap_embedded(soap, &this->ns1__ListBucketResult::IsTruncated, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTons1__ListEntry(soap, &this->ns1__ListBucketResult::Contents);
	soap_serialize_std__vectorTemplateOfPointerTons1__PrefixEntry(soap, &this->ns1__ListBucketResult::CommonPrefixes);
	/* transient soap skipped */
}

int ns1__ListBucketResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListBucketResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListBucketResult(struct soap *soap, const char *tag, int id, const ns1__ListBucketResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListBucketResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", -1, &(a->ns1__ListBucketResult::Metadata), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Name", -1, &(a->ns1__ListBucketResult::Name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Prefix", -1, &(a->ns1__ListBucketResult::Prefix), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Marker", -1, &(a->ns1__ListBucketResult::Marker), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:NextMarker", -1, &(a->ns1__ListBucketResult::NextMarker), ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:MaxKeys", -1, &(a->ns1__ListBucketResult::MaxKeys), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Delimiter", -1, &(a->ns1__ListBucketResult::Delimiter), ""))
		return soap->error;
	if (soap_out_bool(soap, "ns1:IsTruncated", -1, &(a->ns1__ListBucketResult::IsTruncated), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ListEntry(soap, "ns1:Contents", -1, &(a->ns1__ListBucketResult::Contents), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__PrefixEntry(soap, "ns1:CommonPrefixes", -1, &(a->ns1__ListBucketResult::CommonPrefixes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListBucketResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListBucketResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListBucketResult * SOAP_FMAC4 soap_in_ns1__ListBucketResult(struct soap *soap, const char *tag, ns1__ListBucketResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListBucketResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListBucketResult, sizeof(ns1__ListBucketResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListBucketResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListBucketResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Prefix1 = 1;
	size_t soap_flag_Marker1 = 1;
	size_t soap_flag_NextMarker1 = 1;
	size_t soap_flag_MaxKeys1 = 1;
	size_t soap_flag_Delimiter1 = 1;
	size_t soap_flag_IsTruncated1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", &(a->ns1__ListBucketResult::Metadata), "ns1:MetadataEntry"))
					continue;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Name", &(a->ns1__ListBucketResult::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Prefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Prefix", &(a->ns1__ListBucketResult::Prefix), "xsd:string"))
				{	soap_flag_Prefix1--;
					continue;
				}
			if (soap_flag_Marker1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Marker", &(a->ns1__ListBucketResult::Marker), "xsd:string"))
				{	soap_flag_Marker1--;
					continue;
				}
			if (soap_flag_NextMarker1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:NextMarker", &(a->ns1__ListBucketResult::NextMarker), "xsd:string"))
				{	soap_flag_NextMarker1--;
					continue;
				}
			if (soap_flag_MaxKeys1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:MaxKeys", &(a->ns1__ListBucketResult::MaxKeys), "xsd:int"))
				{	soap_flag_MaxKeys1--;
					continue;
				}
			if (soap_flag_Delimiter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Delimiter", &(a->ns1__ListBucketResult::Delimiter), "xsd:string"))
				{	soap_flag_Delimiter1--;
					continue;
				}
			if (soap_flag_IsTruncated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:IsTruncated", &(a->ns1__ListBucketResult::IsTruncated), "xsd:boolean"))
				{	soap_flag_IsTruncated1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ListEntry(soap, "ns1:Contents", &(a->ns1__ListBucketResult::Contents), "ns1:ListEntry"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__PrefixEntry(soap, "ns1:CommonPrefixes", &(a->ns1__ListBucketResult::CommonPrefixes), "ns1:PrefixEntry"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListBucketResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListBucketResult, 0, sizeof(ns1__ListBucketResult), 0, soap_copy_ns1__ListBucketResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Prefix1 > 0 || soap_flag_Marker1 > 0 || soap_flag_MaxKeys1 > 0 || soap_flag_IsTruncated1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ListBucketResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListBucketResult);
	if (this->soap_out(soap, tag?tag:"ns1:ListBucketResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ListBucketResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListBucketResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListBucketResult * SOAP_FMAC4 soap_get_ns1__ListBucketResult(struct soap *soap, ns1__ListBucketResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListBucketResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ListBucketResult * SOAP_FMAC2 soap_instantiate_ns1__ListBucketResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListBucketResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListBucketResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListBucketResult);
		if (size)
			*size = sizeof(ns1__ListBucketResult);
		((ns1__ListBucketResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListBucketResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListBucketResult);
		for (int i = 0; i < n; i++)
			((ns1__ListBucketResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListBucketResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListBucketResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListBucketResult %p -> %p\n", q, p));
	*(ns1__ListBucketResult*)p = *(ns1__ListBucketResult*)q;
}

void ns1__PrefixEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__PrefixEntry::Prefix);
	/* transient soap skipped */
}

void ns1__PrefixEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__PrefixEntry::Prefix, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PrefixEntry::Prefix);
	/* transient soap skipped */
}

int ns1__PrefixEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PrefixEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PrefixEntry(struct soap *soap, const char *tag, int id, const ns1__PrefixEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PrefixEntry), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Prefix", -1, &(a->ns1__PrefixEntry::Prefix), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PrefixEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PrefixEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PrefixEntry * SOAP_FMAC4 soap_in_ns1__PrefixEntry(struct soap *soap, const char *tag, ns1__PrefixEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PrefixEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PrefixEntry, sizeof(ns1__PrefixEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PrefixEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PrefixEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Prefix1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Prefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Prefix", &(a->ns1__PrefixEntry::Prefix), "xsd:string"))
				{	soap_flag_Prefix1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PrefixEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PrefixEntry, 0, sizeof(ns1__PrefixEntry), 0, soap_copy_ns1__PrefixEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Prefix1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PrefixEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PrefixEntry);
	if (this->soap_out(soap, tag?tag:"ns1:PrefixEntry", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PrefixEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PrefixEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PrefixEntry * SOAP_FMAC4 soap_get_ns1__PrefixEntry(struct soap *soap, ns1__PrefixEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PrefixEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PrefixEntry * SOAP_FMAC2 soap_instantiate_ns1__PrefixEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PrefixEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PrefixEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PrefixEntry);
		if (size)
			*size = sizeof(ns1__PrefixEntry);
		((ns1__PrefixEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PrefixEntry[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PrefixEntry);
		for (int i = 0; i < n; i++)
			((ns1__PrefixEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PrefixEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PrefixEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PrefixEntry %p -> %p\n", q, p));
	*(ns1__PrefixEntry*)p = *(ns1__PrefixEntry*)q;
}

void ns1__ListEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ListEntry::Key);
	soap_default_time(soap, &this->ns1__ListEntry::LastModified);
	soap_default_std__string(soap, &this->ns1__ListEntry::ETag);
	soap_default_LONG64(soap, &this->ns1__ListEntry::Size);
	this->ns1__ListEntry::Owner = NULL;
	soap_default_ns1__StorageClass(soap, &this->ns1__ListEntry::StorageClass);
	/* transient soap skipped */
}

void ns1__ListEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ListEntry::Key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListEntry::Key);
	soap_embedded(soap, &this->ns1__ListEntry::LastModified, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns1__ListEntry::ETag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ListEntry::ETag);
	soap_embedded(soap, &this->ns1__ListEntry::Size, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CanonicalUser(soap, &this->ns1__ListEntry::Owner);
	soap_embedded(soap, &this->ns1__ListEntry::StorageClass, SOAP_TYPE_ns1__StorageClass);
	/* transient soap skipped */
}

int ns1__ListEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ListEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ListEntry(struct soap *soap, const char *tag, int id, const ns1__ListEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ListEntry), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Key", -1, &(a->ns1__ListEntry::Key), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LastModified", -1, &(a->ns1__ListEntry::LastModified), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ETag", -1, &(a->ns1__ListEntry::ETag), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "ns1:Size", -1, &(a->ns1__ListEntry::Size), ""))
		return soap->error;
	if (soap_out_PointerTons1__CanonicalUser(soap, "ns1:Owner", -1, &(a->ns1__ListEntry::Owner), ""))
		return soap->error;
	if (soap_out_ns1__StorageClass(soap, "ns1:StorageClass", -1, &(a->ns1__ListEntry::StorageClass), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ListEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ListEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ListEntry * SOAP_FMAC4 soap_in_ns1__ListEntry(struct soap *soap, const char *tag, ns1__ListEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ListEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ListEntry, sizeof(ns1__ListEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ListEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ListEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_LastModified1 = 1;
	size_t soap_flag_ETag1 = 1;
	size_t soap_flag_Size1 = 1;
	size_t soap_flag_Owner1 = 1;
	size_t soap_flag_StorageClass1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Key", &(a->ns1__ListEntry::Key), "xsd:string"))
				{	soap_flag_Key1--;
					continue;
				}
			if (soap_flag_LastModified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LastModified", &(a->ns1__ListEntry::LastModified), "xsd:dateTime"))
				{	soap_flag_LastModified1--;
					continue;
				}
			if (soap_flag_ETag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ETag", &(a->ns1__ListEntry::ETag), "xsd:string"))
				{	soap_flag_ETag1--;
					continue;
				}
			if (soap_flag_Size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "ns1:Size", &(a->ns1__ListEntry::Size), "xsd:long"))
				{	soap_flag_Size1--;
					continue;
				}
			if (soap_flag_Owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CanonicalUser(soap, "ns1:Owner", &(a->ns1__ListEntry::Owner), "ns1:CanonicalUser"))
				{	soap_flag_Owner1--;
					continue;
				}
			if (soap_flag_StorageClass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StorageClass(soap, "ns1:StorageClass", &(a->ns1__ListEntry::StorageClass), "ns1:StorageClass"))
				{	soap_flag_StorageClass1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ListEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ListEntry, 0, sizeof(ns1__ListEntry), 0, soap_copy_ns1__ListEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Key1 > 0 || soap_flag_LastModified1 > 0 || soap_flag_ETag1 > 0 || soap_flag_Size1 > 0 || soap_flag_StorageClass1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ListEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ListEntry);
	if (this->soap_out(soap, tag?tag:"ns1:ListEntry", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ListEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ListEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ListEntry * SOAP_FMAC4 soap_get_ns1__ListEntry(struct soap *soap, ns1__ListEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ListEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ListEntry * SOAP_FMAC2 soap_instantiate_ns1__ListEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ListEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ListEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListEntry);
		if (size)
			*size = sizeof(ns1__ListEntry);
		((ns1__ListEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ListEntry[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ListEntry);
		for (int i = 0; i < n; i++)
			((ns1__ListEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ListEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ListEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ListEntry %p -> %p\n", q, p));
	*(ns1__ListEntry*)p = *(ns1__ListEntry*)q;
}

void ns1__PutObjectResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__PutObjectResult::ETag);
	soap_default_time(soap, &this->ns1__PutObjectResult::LastModified);
	/* transient soap skipped */
}

void ns1__PutObjectResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__PutObjectResult::ETag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__PutObjectResult::ETag);
	soap_embedded(soap, &this->ns1__PutObjectResult::LastModified, SOAP_TYPE_time);
	/* transient soap skipped */
}

int ns1__PutObjectResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PutObjectResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PutObjectResult(struct soap *soap, const char *tag, int id, const ns1__PutObjectResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PutObjectResult), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ETag", -1, &(a->ns1__PutObjectResult::ETag), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LastModified", -1, &(a->ns1__PutObjectResult::LastModified), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PutObjectResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PutObjectResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PutObjectResult * SOAP_FMAC4 soap_in_ns1__PutObjectResult(struct soap *soap, const char *tag, ns1__PutObjectResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PutObjectResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PutObjectResult, sizeof(ns1__PutObjectResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PutObjectResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PutObjectResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ETag1 = 1;
	size_t soap_flag_LastModified1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ETag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ETag", &(a->ns1__PutObjectResult::ETag), "xsd:string"))
				{	soap_flag_ETag1--;
					continue;
				}
			if (soap_flag_LastModified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LastModified", &(a->ns1__PutObjectResult::LastModified), "xsd:dateTime"))
				{	soap_flag_LastModified1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PutObjectResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PutObjectResult, 0, sizeof(ns1__PutObjectResult), 0, soap_copy_ns1__PutObjectResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ETag1 > 0 || soap_flag_LastModified1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PutObjectResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PutObjectResult);
	if (this->soap_out(soap, tag?tag:"ns1:PutObjectResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PutObjectResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PutObjectResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PutObjectResult * SOAP_FMAC4 soap_get_ns1__PutObjectResult(struct soap *soap, ns1__PutObjectResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PutObjectResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PutObjectResult * SOAP_FMAC2 soap_instantiate_ns1__PutObjectResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PutObjectResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PutObjectResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PutObjectResult);
		if (size)
			*size = sizeof(ns1__PutObjectResult);
		((ns1__PutObjectResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PutObjectResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PutObjectResult);
		for (int i = 0; i < n; i++)
			((ns1__PutObjectResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PutObjectResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PutObjectResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PutObjectResult %p -> %p\n", q, p));
	*(ns1__PutObjectResult*)p = *(ns1__PutObjectResult*)q;
}

void ns1__GetObjectResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->ns1__GetObjectResult::Metadata);
	this->ns1__GetObjectResult::Data = NULL;
	soap_default_time(soap, &this->ns1__GetObjectResult::LastModified);
	soap_default_std__string(soap, &this->ns1__GetObjectResult::ETag);
	this->ns1__Result::Status = NULL;
	/* transient soap skipped */
}

void ns1__GetObjectResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, &this->ns1__GetObjectResult::Metadata);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__GetObjectResult::Data);
	soap_embedded(soap, &this->ns1__GetObjectResult::LastModified, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns1__GetObjectResult::ETag, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__GetObjectResult::ETag);
	soap_serialize_PointerTons1__Status(soap, &this->ns1__Result::Status);
	/* transient soap skipped */
}

int ns1__GetObjectResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetObjectResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetObjectResult(struct soap *soap, const char *tag, int id, const ns1__GetObjectResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetObjectResult), "ns1:GetObjectResult"))
		return soap->error;
	if (a->ns1__Result::Status)
	{	if (soap_out_PointerTons1__Status(soap, "ns1:Status", -1, &a->ns1__Result::Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Status"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", -1, &(a->ns1__GetObjectResult::Metadata), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns1:Data", -1, &(a->ns1__GetObjectResult::Data), ""))
		return soap->error;
	if (soap_out_time(soap, "ns1:LastModified", -1, &(a->ns1__GetObjectResult::LastModified), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:ETag", -1, &(a->ns1__GetObjectResult::ETag), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__GetObjectResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GetObjectResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetObjectResult * SOAP_FMAC4 soap_in_ns1__GetObjectResult(struct soap *soap, const char *tag, ns1__GetObjectResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetObjectResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetObjectResult, sizeof(ns1__GetObjectResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GetObjectResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GetObjectResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Status2 = 1;
	size_t soap_flag_Data1 = 1;
	size_t soap_flag_LastModified1 = 1;
	size_t soap_flag_ETag1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "ns1:Status", &(a->ns1__Result::Status), "ns1:Status"))
				{	soap_flag_Status2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, "ns1:Metadata", &(a->ns1__GetObjectResult::Metadata), "ns1:MetadataEntry"))
					continue;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns1:Data", &(a->ns1__GetObjectResult::Data), "xsd:base64Binary"))
				{	soap_flag_Data1--;
					continue;
				}
			if (soap_flag_LastModified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns1:LastModified", &(a->ns1__GetObjectResult::LastModified), "xsd:dateTime"))
				{	soap_flag_LastModified1--;
					continue;
				}
			if (soap_flag_ETag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ETag", &(a->ns1__GetObjectResult::ETag), "xsd:string"))
				{	soap_flag_ETag1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetObjectResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetObjectResult, 0, sizeof(ns1__GetObjectResult), 0, soap_copy_ns1__GetObjectResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status2 > 0 || soap_flag_LastModified1 > 0 || soap_flag_ETag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__GetObjectResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GetObjectResult);
	if (this->soap_out(soap, tag?tag:"ns1:GetObjectResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetObjectResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetObjectResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetObjectResult * SOAP_FMAC4 soap_get_ns1__GetObjectResult(struct soap *soap, ns1__GetObjectResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetObjectResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__GetObjectResult * SOAP_FMAC2 soap_instantiate_ns1__GetObjectResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetObjectResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetObjectResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__GetObjectResult);
		if (size)
			*size = sizeof(ns1__GetObjectResult);
		((ns1__GetObjectResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__GetObjectResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GetObjectResult);
		for (int i = 0; i < n; i++)
			((ns1__GetObjectResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GetObjectResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetObjectResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GetObjectResult %p -> %p\n", q, p));
	*(ns1__GetObjectResult*)p = *(ns1__GetObjectResult*)q;
}

void ns1__AccessControlPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AccessControlPolicy::Owner = NULL;
	this->ns1__AccessControlPolicy::AccessControlList = NULL;
	/* transient soap skipped */
}

void ns1__AccessControlPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CanonicalUser(soap, &this->ns1__AccessControlPolicy::Owner);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->ns1__AccessControlPolicy::AccessControlList);
	/* transient soap skipped */
}

int ns1__AccessControlPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessControlPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessControlPolicy(struct soap *soap, const char *tag, int id, const ns1__AccessControlPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessControlPolicy), type))
		return soap->error;
	if (a->ns1__AccessControlPolicy::Owner)
	{	if (soap_out_PointerTons1__CanonicalUser(soap, "ns1:Owner", -1, &a->ns1__AccessControlPolicy::Owner, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Owner"))
		return soap->error;
	if (a->ns1__AccessControlPolicy::AccessControlList)
	{	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", -1, &a->ns1__AccessControlPolicy::AccessControlList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:AccessControlList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AccessControlPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessControlPolicy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessControlPolicy * SOAP_FMAC4 soap_in_ns1__AccessControlPolicy(struct soap *soap, const char *tag, ns1__AccessControlPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AccessControlPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessControlPolicy, sizeof(ns1__AccessControlPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AccessControlPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AccessControlPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Owner1 = 1;
	size_t soap_flag_AccessControlList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CanonicalUser(soap, "ns1:Owner", &(a->ns1__AccessControlPolicy::Owner), "ns1:CanonicalUser"))
				{	soap_flag_Owner1--;
					continue;
				}
			if (soap_flag_AccessControlList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:AccessControlList", &(a->ns1__AccessControlPolicy::AccessControlList), "ns1:AccessControlList"))
				{	soap_flag_AccessControlList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AccessControlPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessControlPolicy, 0, sizeof(ns1__AccessControlPolicy), 0, soap_copy_ns1__AccessControlPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Owner1 > 0 || soap_flag_AccessControlList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AccessControlPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AccessControlPolicy);
	if (this->soap_out(soap, tag?tag:"ns1:AccessControlPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AccessControlPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessControlPolicy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessControlPolicy * SOAP_FMAC4 soap_get_ns1__AccessControlPolicy(struct soap *soap, ns1__AccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AccessControlPolicy * SOAP_FMAC2 soap_instantiate_ns1__AccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AccessControlPolicy);
		if (size)
			*size = sizeof(ns1__AccessControlPolicy);
		((ns1__AccessControlPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AccessControlPolicy);
		for (int i = 0; i < n; i++)
			((ns1__AccessControlPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AccessControlPolicy %p -> %p\n", q, p));
	*(ns1__AccessControlPolicy*)p = *(ns1__AccessControlPolicy*)q;
}

void ns1__LocationConstraint::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__LocationConstraint::__item);
	/* transient soap skipped */
}

void ns1__LocationConstraint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__LocationConstraint::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__LocationConstraint::__item);
	/* transient soap skipped */
}

int ns1__LocationConstraint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LocationConstraint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LocationConstraint(struct soap *soap, const char *tag, int id, const ns1__LocationConstraint *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &a->ns1__LocationConstraint::__item, "");
}

void *ns1__LocationConstraint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LocationConstraint(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LocationConstraint * SOAP_FMAC4 soap_in_ns1__LocationConstraint(struct soap *soap, const char *tag, ns1__LocationConstraint *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns1__LocationConstraint *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LocationConstraint, sizeof(ns1__LocationConstraint), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LocationConstraint)
			return (ns1__LocationConstraint *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(a->ns1__LocationConstraint::__item), "ns1:LocationConstraint"))
		return NULL;
	return a;
}

int ns1__LocationConstraint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LocationConstraint);
	if (this->soap_out(soap, tag?tag:"ns1:LocationConstraint", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LocationConstraint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LocationConstraint(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LocationConstraint * SOAP_FMAC4 soap_get_ns1__LocationConstraint(struct soap *soap, ns1__LocationConstraint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LocationConstraint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__LocationConstraint * SOAP_FMAC2 soap_instantiate_ns1__LocationConstraint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LocationConstraint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LocationConstraint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__LocationConstraint);
		if (size)
			*size = sizeof(ns1__LocationConstraint);
		((ns1__LocationConstraint*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__LocationConstraint[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LocationConstraint);
		for (int i = 0; i < n; i++)
			((ns1__LocationConstraint*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LocationConstraint*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LocationConstraint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LocationConstraint %p -> %p\n", q, p));
	*(ns1__LocationConstraint*)p = *(ns1__LocationConstraint*)q;
}

void ns1__CreateBucketConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CreateBucketConfiguration::LocationConstraint = NULL;
	/* transient soap skipped */
}

void ns1__CreateBucketConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__LocationConstraint(soap, &this->ns1__CreateBucketConfiguration::LocationConstraint);
	/* transient soap skipped */
}

int ns1__CreateBucketConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CreateBucketConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreateBucketConfiguration(struct soap *soap, const char *tag, int id, const ns1__CreateBucketConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreateBucketConfiguration), type))
		return soap->error;
	if (a->ns1__CreateBucketConfiguration::LocationConstraint)
	{	if (soap_out_PointerTons1__LocationConstraint(soap, "ns1:LocationConstraint", -1, &a->ns1__CreateBucketConfiguration::LocationConstraint, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:LocationConstraint"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CreateBucketConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CreateBucketConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CreateBucketConfiguration * SOAP_FMAC4 soap_in_ns1__CreateBucketConfiguration(struct soap *soap, const char *tag, ns1__CreateBucketConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CreateBucketConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreateBucketConfiguration, sizeof(ns1__CreateBucketConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CreateBucketConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CreateBucketConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LocationConstraint1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LocationConstraint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LocationConstraint(soap, "ns1:LocationConstraint", &(a->ns1__CreateBucketConfiguration::LocationConstraint), "ns1:LocationConstraint"))
				{	soap_flag_LocationConstraint1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CreateBucketConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreateBucketConfiguration, 0, sizeof(ns1__CreateBucketConfiguration), 0, soap_copy_ns1__CreateBucketConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocationConstraint1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CreateBucketConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CreateBucketConfiguration);
	if (this->soap_out(soap, tag?tag:"ns1:CreateBucketConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CreateBucketConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CreateBucketConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CreateBucketConfiguration * SOAP_FMAC4 soap_get_ns1__CreateBucketConfiguration(struct soap *soap, ns1__CreateBucketConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreateBucketConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CreateBucketConfiguration * SOAP_FMAC2 soap_instantiate_ns1__CreateBucketConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CreateBucketConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CreateBucketConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CreateBucketConfiguration);
		if (size)
			*size = sizeof(ns1__CreateBucketConfiguration);
		((ns1__CreateBucketConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CreateBucketConfiguration[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CreateBucketConfiguration);
		for (int i = 0; i < n; i++)
			((ns1__CreateBucketConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CreateBucketConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CreateBucketConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CreateBucketConfiguration %p -> %p\n", q, p));
	*(ns1__CreateBucketConfiguration*)p = *(ns1__CreateBucketConfiguration*)q;
}

void ns1__AccessControlList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Grant(soap, &this->ns1__AccessControlList::Grant);
	/* transient soap skipped */
}

void ns1__AccessControlList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Grant(soap, &this->ns1__AccessControlList::Grant);
	/* transient soap skipped */
}

int ns1__AccessControlList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccessControlList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessControlList(struct soap *soap, const char *tag, int id, const ns1__AccessControlList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessControlList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Grant(soap, "ns1:Grant", -1, &(a->ns1__AccessControlList::Grant), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AccessControlList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccessControlList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccessControlList * SOAP_FMAC4 soap_in_ns1__AccessControlList(struct soap *soap, const char *tag, ns1__AccessControlList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AccessControlList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessControlList, sizeof(ns1__AccessControlList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AccessControlList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AccessControlList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Grant(soap, "ns1:Grant", &(a->ns1__AccessControlList::Grant), "ns1:Grant"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AccessControlList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessControlList, 0, sizeof(ns1__AccessControlList), 0, soap_copy_ns1__AccessControlList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__AccessControlList::Grant.size() > 100))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AccessControlList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AccessControlList);
	if (this->soap_out(soap, tag?tag:"ns1:AccessControlList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AccessControlList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccessControlList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccessControlList * SOAP_FMAC4 soap_get_ns1__AccessControlList(struct soap *soap, ns1__AccessControlList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessControlList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AccessControlList * SOAP_FMAC2 soap_instantiate_ns1__AccessControlList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccessControlList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccessControlList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AccessControlList);
		if (size)
			*size = sizeof(ns1__AccessControlList);
		((ns1__AccessControlList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AccessControlList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AccessControlList);
		for (int i = 0; i < n; i++)
			((ns1__AccessControlList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AccessControlList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AccessControlList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AccessControlList %p -> %p\n", q, p));
	*(ns1__AccessControlList*)p = *(ns1__AccessControlList*)q;
}

void ns1__Grant::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Grant::Grantee = NULL;
	soap_default_ns1__Permission(soap, &this->ns1__Grant::Permission);
	/* transient soap skipped */
}

void ns1__Grant::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Grantee(soap, &this->ns1__Grant::Grantee);
	/* transient soap skipped */
}

int ns1__Grant::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Grant(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Grant(struct soap *soap, const char *tag, int id, const ns1__Grant *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Grant), type))
		return soap->error;
	if (a->ns1__Grant::Grantee)
	{	if (soap_out_PointerTons1__Grantee(soap, "ns1:Grantee", -1, &a->ns1__Grant::Grantee, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Grantee"))
		return soap->error;
	if (soap_out_ns1__Permission(soap, "ns1:Permission", -1, &(a->ns1__Grant::Permission), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Grant::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Grant(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Grant * SOAP_FMAC4 soap_in_ns1__Grant(struct soap *soap, const char *tag, ns1__Grant *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Grant *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Grant, sizeof(ns1__Grant), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Grant)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Grant *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Grantee1 = 1;
	size_t soap_flag_Permission1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Grantee1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Grantee(soap, "ns1:Grantee", &(a->ns1__Grant::Grantee), "ns1:Grantee"))
				{	soap_flag_Grantee1--;
					continue;
				}
			if (soap_flag_Permission1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__Permission(soap, "ns1:Permission", &(a->ns1__Grant::Permission), "ns1:Permission"))
				{	soap_flag_Permission1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Grant *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Grant, 0, sizeof(ns1__Grant), 0, soap_copy_ns1__Grant);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Grantee1 > 0 || soap_flag_Permission1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Grant::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Grant);
	if (this->soap_out(soap, tag?tag:"ns1:Grant", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Grant::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Grant(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Grant * SOAP_FMAC4 soap_get_ns1__Grant(struct soap *soap, ns1__Grant *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Grant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Grant * SOAP_FMAC2 soap_instantiate_ns1__Grant(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Grant(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Grant, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Grant);
		if (size)
			*size = sizeof(ns1__Grant);
		((ns1__Grant*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Grant[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Grant);
		for (int i = 0; i < n; i++)
			((ns1__Grant*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Grant*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Grant(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Grant %p -> %p\n", q, p));
	*(ns1__Grant*)p = *(ns1__Grant*)q;
}

void ns1__Group::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Group::URI);
	/* transient soap skipped */
}

void ns1__Group::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Group::URI, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Group::URI);
	/* transient soap skipped */
}

int ns1__Group::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Group(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Group(struct soap *soap, const char *tag, int id, const ns1__Group *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Group), "ns1:Group"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "ns1:URI", -1, &(a->ns1__Group::URI), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Group::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Group(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Group * SOAP_FMAC4 soap_in_ns1__Group(struct soap *soap, const char *tag, ns1__Group *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Group *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Group, sizeof(ns1__Group), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Group)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Group *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_URI1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:URI", &(a->ns1__Group::URI), "xsd:string"))
				{	soap_flag_URI1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Group *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Group, 0, sizeof(ns1__Group), 0, soap_copy_ns1__Group);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Group::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Group);
	if (this->soap_out(soap, tag?tag:"ns1:Group", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Group::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Group(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Group * SOAP_FMAC4 soap_get_ns1__Group(struct soap *soap, ns1__Group *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Group(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Group * SOAP_FMAC2 soap_instantiate_ns1__Group(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Group(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Group, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Group);
		if (size)
			*size = sizeof(ns1__Group);
		((ns1__Group*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Group[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Group);
		for (int i = 0; i < n; i++)
			((ns1__Group*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Group*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Group(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Group %p -> %p\n", q, p));
	*(ns1__Group*)p = *(ns1__Group*)q;
}

void ns1__CanonicalUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__CanonicalUser::ID);
	this->ns1__CanonicalUser::DisplayName = NULL;
	/* transient soap skipped */
}

void ns1__CanonicalUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CanonicalUser::ID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CanonicalUser::ID);
	soap_serialize_PointerTostd__string(soap, &this->ns1__CanonicalUser::DisplayName);
	/* transient soap skipped */
}

int ns1__CanonicalUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CanonicalUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CanonicalUser(struct soap *soap, const char *tag, int id, const ns1__CanonicalUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CanonicalUser), "ns1:CanonicalUser"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "ns1:ID", -1, &(a->ns1__CanonicalUser::ID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DisplayName", -1, &(a->ns1__CanonicalUser::DisplayName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CanonicalUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CanonicalUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CanonicalUser * SOAP_FMAC4 soap_in_ns1__CanonicalUser(struct soap *soap, const char *tag, ns1__CanonicalUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CanonicalUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CanonicalUser, sizeof(ns1__CanonicalUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CanonicalUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CanonicalUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	size_t soap_flag_DisplayName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:ID", &(a->ns1__CanonicalUser::ID), "xsd:string"))
				{	soap_flag_ID1--;
					continue;
				}
			if (soap_flag_DisplayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:DisplayName", &(a->ns1__CanonicalUser::DisplayName), "xsd:string"))
				{	soap_flag_DisplayName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CanonicalUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CanonicalUser, 0, sizeof(ns1__CanonicalUser), 0, soap_copy_ns1__CanonicalUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CanonicalUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CanonicalUser);
	if (this->soap_out(soap, tag?tag:"ns1:CanonicalUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CanonicalUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CanonicalUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CanonicalUser * SOAP_FMAC4 soap_get_ns1__CanonicalUser(struct soap *soap, ns1__CanonicalUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CanonicalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CanonicalUser * SOAP_FMAC2 soap_instantiate_ns1__CanonicalUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CanonicalUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CanonicalUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CanonicalUser);
		if (size)
			*size = sizeof(ns1__CanonicalUser);
		((ns1__CanonicalUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CanonicalUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CanonicalUser);
		for (int i = 0; i < n; i++)
			((ns1__CanonicalUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CanonicalUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CanonicalUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CanonicalUser %p -> %p\n", q, p));
	*(ns1__CanonicalUser*)p = *(ns1__CanonicalUser*)q;
}

void ns1__AmazonCustomerByEmail::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__AmazonCustomerByEmail::EmailAddress);
	/* transient soap skipped */
}

void ns1__AmazonCustomerByEmail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__AmazonCustomerByEmail::EmailAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AmazonCustomerByEmail::EmailAddress);
	/* transient soap skipped */
}

int ns1__AmazonCustomerByEmail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AmazonCustomerByEmail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AmazonCustomerByEmail(struct soap *soap, const char *tag, int id, const ns1__AmazonCustomerByEmail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AmazonCustomerByEmail), "ns1:AmazonCustomerByEmail"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "ns1:EmailAddress", -1, &(a->ns1__AmazonCustomerByEmail::EmailAddress), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AmazonCustomerByEmail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AmazonCustomerByEmail(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AmazonCustomerByEmail * SOAP_FMAC4 soap_in_ns1__AmazonCustomerByEmail(struct soap *soap, const char *tag, ns1__AmazonCustomerByEmail *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AmazonCustomerByEmail *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AmazonCustomerByEmail, sizeof(ns1__AmazonCustomerByEmail), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AmazonCustomerByEmail)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AmazonCustomerByEmail *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EmailAddress1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_EmailAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:EmailAddress", &(a->ns1__AmazonCustomerByEmail::EmailAddress), "xsd:string"))
				{	soap_flag_EmailAddress1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AmazonCustomerByEmail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AmazonCustomerByEmail, 0, sizeof(ns1__AmazonCustomerByEmail), 0, soap_copy_ns1__AmazonCustomerByEmail);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EmailAddress1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AmazonCustomerByEmail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AmazonCustomerByEmail);
	if (this->soap_out(soap, tag?tag:"ns1:AmazonCustomerByEmail", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AmazonCustomerByEmail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AmazonCustomerByEmail(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AmazonCustomerByEmail * SOAP_FMAC4 soap_get_ns1__AmazonCustomerByEmail(struct soap *soap, ns1__AmazonCustomerByEmail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AmazonCustomerByEmail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AmazonCustomerByEmail * SOAP_FMAC2 soap_instantiate_ns1__AmazonCustomerByEmail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AmazonCustomerByEmail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AmazonCustomerByEmail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AmazonCustomerByEmail);
		if (size)
			*size = sizeof(ns1__AmazonCustomerByEmail);
		((ns1__AmazonCustomerByEmail*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AmazonCustomerByEmail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AmazonCustomerByEmail);
		for (int i = 0; i < n; i++)
			((ns1__AmazonCustomerByEmail*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AmazonCustomerByEmail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AmazonCustomerByEmail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AmazonCustomerByEmail %p -> %p\n", q, p));
	*(ns1__AmazonCustomerByEmail*)p = *(ns1__AmazonCustomerByEmail*)q;
}

void ns1__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__User(struct soap *soap, const char *tag, int id, const ns1__User *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__User), "ns1:User"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__User::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__User(soap, tag, this, type);
}

SOAP_FMAC3 ns1__User * SOAP_FMAC4 soap_in_ns1__User(struct soap *soap, const char *tag, ns1__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__User *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__User, sizeof(ns1__User), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__User)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__User *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__User, 0, sizeof(ns1__User), 0, soap_copy_ns1__User);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__User);
	if (this->soap_out(soap, tag?tag:"ns1:User", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__User(soap, this, tag, type);
}

SOAP_FMAC3 ns1__User * SOAP_FMAC4 soap_get_ns1__User(struct soap *soap, ns1__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__User * SOAP_FMAC2 soap_instantiate_ns1__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__User(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__User, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:AmazonCustomerByEmail"))
	{	cp->type = SOAP_TYPE_ns1__AmazonCustomerByEmail;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__AmazonCustomerByEmail);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__AmazonCustomerByEmail);
			((ns1__AmazonCustomerByEmail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__AmazonCustomerByEmail[n]);
			if (size)
				*size = n * sizeof(ns1__AmazonCustomerByEmail);
			for (int i = 0; i < n; i++)
				((ns1__AmazonCustomerByEmail*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__AmazonCustomerByEmail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CanonicalUser"))
	{	cp->type = SOAP_TYPE_ns1__CanonicalUser;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__CanonicalUser);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__CanonicalUser);
			((ns1__CanonicalUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__CanonicalUser[n]);
			if (size)
				*size = n * sizeof(ns1__CanonicalUser);
			for (int i = 0; i < n; i++)
				((ns1__CanonicalUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__CanonicalUser*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__User);
		if (size)
			*size = sizeof(ns1__User);
		((ns1__User*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__User[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__User);
		for (int i = 0; i < n; i++)
			((ns1__User*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__User*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__User(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__User %p -> %p\n", q, p));
	*(ns1__User*)p = *(ns1__User*)q;
}

void ns1__Grantee::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__Grantee::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__Grantee::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Grantee(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Grantee(struct soap *soap, const char *tag, int id, const ns1__Grantee *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Grantee), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Grantee::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Grantee(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Grantee * SOAP_FMAC4 soap_in_ns1__Grantee(struct soap *soap, const char *tag, ns1__Grantee *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Grantee *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Grantee, sizeof(ns1__Grantee), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Grantee)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Grantee *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Grantee *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Grantee, 0, sizeof(ns1__Grantee), 0, soap_copy_ns1__Grantee);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__Grantee::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Grantee);
	if (this->soap_out(soap, tag?tag:"ns1:Grantee", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Grantee::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Grantee(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Grantee * SOAP_FMAC4 soap_get_ns1__Grantee(struct soap *soap, ns1__Grantee *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Grantee(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Grantee * SOAP_FMAC2 soap_instantiate_ns1__Grantee(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Grantee(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Grantee, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:User"))
	{	cp->type = SOAP_TYPE_ns1__User;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__User);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__User);
			((ns1__User*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__User[n]);
			if (size)
				*size = n * sizeof(ns1__User);
			for (int i = 0; i < n; i++)
				((ns1__User*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__User*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:Group"))
	{	cp->type = SOAP_TYPE_ns1__Group;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__Group);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__Group);
			((ns1__Group*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__Group[n]);
			if (size)
				*size = n * sizeof(ns1__Group);
			for (int i = 0; i < n; i++)
				((ns1__Group*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__Group*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:AmazonCustomerByEmail"))
	{	cp->type = SOAP_TYPE_ns1__AmazonCustomerByEmail;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__AmazonCustomerByEmail);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__AmazonCustomerByEmail);
			((ns1__AmazonCustomerByEmail*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__AmazonCustomerByEmail[n]);
			if (size)
				*size = n * sizeof(ns1__AmazonCustomerByEmail);
			for (int i = 0; i < n; i++)
				((ns1__AmazonCustomerByEmail*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__AmazonCustomerByEmail*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:CanonicalUser"))
	{	cp->type = SOAP_TYPE_ns1__CanonicalUser;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__CanonicalUser);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__CanonicalUser);
			((ns1__CanonicalUser*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__CanonicalUser[n]);
			if (size)
				*size = n * sizeof(ns1__CanonicalUser);
			for (int i = 0; i < n; i++)
				((ns1__CanonicalUser*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__CanonicalUser*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Grantee);
		if (size)
			*size = sizeof(ns1__Grantee);
		((ns1__Grantee*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Grantee[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Grantee);
		for (int i = 0; i < n; i++)
			((ns1__Grantee*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Grantee*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Grantee(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Grantee %p -> %p\n", q, p));
	*(ns1__Grantee*)p = *(ns1__Grantee*)q;
}

void ns1__LoggingSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__LoggingSettings::TargetBucket);
	soap_default_std__string(soap, &this->ns1__LoggingSettings::TargetPrefix);
	this->ns1__LoggingSettings::TargetGrants = NULL;
	/* transient soap skipped */
}

void ns1__LoggingSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__LoggingSettings::TargetBucket, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__LoggingSettings::TargetBucket);
	soap_embedded(soap, &this->ns1__LoggingSettings::TargetPrefix, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__LoggingSettings::TargetPrefix);
	soap_serialize_PointerTons1__AccessControlList(soap, &this->ns1__LoggingSettings::TargetGrants);
	/* transient soap skipped */
}

int ns1__LoggingSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LoggingSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LoggingSettings(struct soap *soap, const char *tag, int id, const ns1__LoggingSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LoggingSettings), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:TargetBucket", -1, &(a->ns1__LoggingSettings::TargetBucket), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:TargetPrefix", -1, &(a->ns1__LoggingSettings::TargetPrefix), ""))
		return soap->error;
	if (soap_out_PointerTons1__AccessControlList(soap, "ns1:TargetGrants", -1, &(a->ns1__LoggingSettings::TargetGrants), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__LoggingSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LoggingSettings(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LoggingSettings * SOAP_FMAC4 soap_in_ns1__LoggingSettings(struct soap *soap, const char *tag, ns1__LoggingSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LoggingSettings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LoggingSettings, sizeof(ns1__LoggingSettings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LoggingSettings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LoggingSettings *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TargetBucket1 = 1;
	size_t soap_flag_TargetPrefix1 = 1;
	size_t soap_flag_TargetGrants1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TargetBucket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:TargetBucket", &(a->ns1__LoggingSettings::TargetBucket), "xsd:string"))
				{	soap_flag_TargetBucket1--;
					continue;
				}
			if (soap_flag_TargetPrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:TargetPrefix", &(a->ns1__LoggingSettings::TargetPrefix), "xsd:string"))
				{	soap_flag_TargetPrefix1--;
					continue;
				}
			if (soap_flag_TargetGrants1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccessControlList(soap, "ns1:TargetGrants", &(a->ns1__LoggingSettings::TargetGrants), "ns1:AccessControlList"))
				{	soap_flag_TargetGrants1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LoggingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LoggingSettings, 0, sizeof(ns1__LoggingSettings), 0, soap_copy_ns1__LoggingSettings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TargetBucket1 > 0 || soap_flag_TargetPrefix1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__LoggingSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LoggingSettings);
	if (this->soap_out(soap, tag?tag:"ns1:LoggingSettings", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LoggingSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LoggingSettings(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LoggingSettings * SOAP_FMAC4 soap_get_ns1__LoggingSettings(struct soap *soap, ns1__LoggingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LoggingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__LoggingSettings * SOAP_FMAC2 soap_instantiate_ns1__LoggingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LoggingSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LoggingSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__LoggingSettings);
		if (size)
			*size = sizeof(ns1__LoggingSettings);
		((ns1__LoggingSettings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__LoggingSettings[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LoggingSettings);
		for (int i = 0; i < n; i++)
			((ns1__LoggingSettings*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LoggingSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LoggingSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LoggingSettings %p -> %p\n", q, p));
	*(ns1__LoggingSettings*)p = *(ns1__LoggingSettings*)q;
}

void ns1__BucketLoggingStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__BucketLoggingStatus::LoggingEnabled = NULL;
	/* transient soap skipped */
}

void ns1__BucketLoggingStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__LoggingSettings(soap, &this->ns1__BucketLoggingStatus::LoggingEnabled);
	/* transient soap skipped */
}

int ns1__BucketLoggingStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BucketLoggingStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BucketLoggingStatus(struct soap *soap, const char *tag, int id, const ns1__BucketLoggingStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BucketLoggingStatus), type))
		return soap->error;
	if (soap_out_PointerTons1__LoggingSettings(soap, "ns1:LoggingEnabled", -1, &(a->ns1__BucketLoggingStatus::LoggingEnabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__BucketLoggingStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BucketLoggingStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BucketLoggingStatus * SOAP_FMAC4 soap_in_ns1__BucketLoggingStatus(struct soap *soap, const char *tag, ns1__BucketLoggingStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BucketLoggingStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BucketLoggingStatus, sizeof(ns1__BucketLoggingStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BucketLoggingStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BucketLoggingStatus *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LoggingEnabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoggingEnabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LoggingSettings(soap, "ns1:LoggingEnabled", &(a->ns1__BucketLoggingStatus::LoggingEnabled), "ns1:LoggingSettings"))
				{	soap_flag_LoggingEnabled1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BucketLoggingStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BucketLoggingStatus, 0, sizeof(ns1__BucketLoggingStatus), 0, soap_copy_ns1__BucketLoggingStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__BucketLoggingStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BucketLoggingStatus);
	if (this->soap_out(soap, tag?tag:"ns1:BucketLoggingStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BucketLoggingStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BucketLoggingStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BucketLoggingStatus * SOAP_FMAC4 soap_get_ns1__BucketLoggingStatus(struct soap *soap, ns1__BucketLoggingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__BucketLoggingStatus * SOAP_FMAC2 soap_instantiate_ns1__BucketLoggingStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BucketLoggingStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BucketLoggingStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__BucketLoggingStatus);
		if (size)
			*size = sizeof(ns1__BucketLoggingStatus);
		((ns1__BucketLoggingStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__BucketLoggingStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BucketLoggingStatus);
		for (int i = 0; i < n; i++)
			((ns1__BucketLoggingStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BucketLoggingStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BucketLoggingStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BucketLoggingStatus %p -> %p\n", q, p));
	*(ns1__BucketLoggingStatus*)p = *(ns1__BucketLoggingStatus*)q;
}

void ns1__CreateBucketResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__CreateBucketResult::BucketName);
	/* transient soap skipped */
}

void ns1__CreateBucketResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CreateBucketResult::BucketName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__CreateBucketResult::BucketName);
	/* transient soap skipped */
}

int ns1__CreateBucketResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CreateBucketResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CreateBucketResult(struct soap *soap, const char *tag, int id, const ns1__CreateBucketResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CreateBucketResult), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:BucketName", -1, &(a->ns1__CreateBucketResult::BucketName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CreateBucketResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CreateBucketResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CreateBucketResult * SOAP_FMAC4 soap_in_ns1__CreateBucketResult(struct soap *soap, const char *tag, ns1__CreateBucketResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CreateBucketResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CreateBucketResult, sizeof(ns1__CreateBucketResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CreateBucketResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CreateBucketResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_BucketName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BucketName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:BucketName", &(a->ns1__CreateBucketResult::BucketName), "xsd:string"))
				{	soap_flag_BucketName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CreateBucketResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CreateBucketResult, 0, sizeof(ns1__CreateBucketResult), 0, soap_copy_ns1__CreateBucketResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BucketName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CreateBucketResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CreateBucketResult);
	if (this->soap_out(soap, tag?tag:"ns1:CreateBucketResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CreateBucketResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CreateBucketResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CreateBucketResult * SOAP_FMAC4 soap_get_ns1__CreateBucketResult(struct soap *soap, ns1__CreateBucketResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CreateBucketResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CreateBucketResult * SOAP_FMAC2 soap_instantiate_ns1__CreateBucketResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CreateBucketResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CreateBucketResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CreateBucketResult);
		if (size)
			*size = sizeof(ns1__CreateBucketResult);
		((ns1__CreateBucketResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__CreateBucketResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CreateBucketResult);
		for (int i = 0; i < n; i++)
			((ns1__CreateBucketResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CreateBucketResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CreateBucketResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CreateBucketResult %p -> %p\n", q, p));
	*(ns1__CreateBucketResult*)p = *(ns1__CreateBucketResult*)q;
}

void ns1__Result::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Result::Status = NULL;
	/* transient soap skipped */
}

void ns1__Result::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Status(soap, &this->ns1__Result::Status);
	/* transient soap skipped */
}

int ns1__Result::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Result(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Result(struct soap *soap, const char *tag, int id, const ns1__Result *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Result), type))
		return soap->error;
	if (a->ns1__Result::Status)
	{	if (soap_out_PointerTons1__Status(soap, "ns1:Status", -1, &a->ns1__Result::Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ns1:Status"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Result::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Result(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Result * SOAP_FMAC4 soap_in_ns1__Result(struct soap *soap, const char *tag, ns1__Result *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Result *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Result, sizeof(ns1__Result), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Result)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Result *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "ns1:Status", &(a->ns1__Result::Status), "ns1:Status"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Result, 0, sizeof(ns1__Result), 0, soap_copy_ns1__Result);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Result::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Result);
	if (this->soap_out(soap, tag?tag:"ns1:Result", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Result::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Result(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Result * SOAP_FMAC4 soap_get_ns1__Result(struct soap *soap, ns1__Result *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Result * SOAP_FMAC2 soap_instantiate_ns1__Result(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Result(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Result, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:GetObjectResult"))
	{	cp->type = SOAP_TYPE_ns1__GetObjectResult;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__GetObjectResult);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__GetObjectResult);
			((ns1__GetObjectResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__GetObjectResult[n]);
			if (size)
				*size = n * sizeof(ns1__GetObjectResult);
			for (int i = 0; i < n; i++)
				((ns1__GetObjectResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__GetObjectResult*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Result);
		if (size)
			*size = sizeof(ns1__Result);
		((ns1__Result*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Result[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Result);
		for (int i = 0; i < n; i++)
			((ns1__Result*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Result*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Result(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Result %p -> %p\n", q, p));
	*(ns1__Result*)p = *(ns1__Result*)q;
}

void ns1__Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Status::Code);
	soap_default_std__string(soap, &this->ns1__Status::Description);
	/* transient soap skipped */
}

void ns1__Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Status::Code, SOAP_TYPE_int);
	soap_embedded(soap, &this->ns1__Status::Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Status::Description);
	/* transient soap skipped */
}

int ns1__Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Status(struct soap *soap, const char *tag, int id, const ns1__Status *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Status), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:Code", -1, &(a->ns1__Status::Code), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Description", -1, &(a->ns1__Status::Description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Status(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_in_ns1__Status(struct soap *soap, const char *tag, ns1__Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Status *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Status)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Status *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Code1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:Code", &(a->ns1__Status::Code), "xsd:int"))
				{	soap_flag_Code1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Description", &(a->ns1__Status::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Status, 0, sizeof(ns1__Status), 0, soap_copy_ns1__Status);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Code1 > 0 || soap_flag_Description1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Status);
	if (this->soap_out(soap, tag?tag:"ns1:Status", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Status(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_get_ns1__Status(struct soap *soap, ns1__Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Status * SOAP_FMAC2 soap_instantiate_ns1__Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Status, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Status);
		if (size)
			*size = sizeof(ns1__Status);
		((ns1__Status*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Status[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Status);
		for (int i = 0; i < n; i++)
			((ns1__Status*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Status*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Status(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Status %p -> %p\n", q, p));
	*(ns1__Status*)p = *(ns1__Status*)q;
}

void ns1__MetadataEntry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__MetadataEntry::Name);
	soap_default_std__string(soap, &this->ns1__MetadataEntry::Value);
	/* transient soap skipped */
}

void ns1__MetadataEntry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__MetadataEntry::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MetadataEntry::Name);
	soap_embedded(soap, &this->ns1__MetadataEntry::Value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MetadataEntry::Value);
	/* transient soap skipped */
}

int ns1__MetadataEntry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MetadataEntry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MetadataEntry(struct soap *soap, const char *tag, int id, const ns1__MetadataEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MetadataEntry), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Name", -1, &(a->ns1__MetadataEntry::Name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:Value", -1, &(a->ns1__MetadataEntry::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__MetadataEntry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MetadataEntry(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MetadataEntry * SOAP_FMAC4 soap_in_ns1__MetadataEntry(struct soap *soap, const char *tag, ns1__MetadataEntry *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MetadataEntry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MetadataEntry, sizeof(ns1__MetadataEntry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MetadataEntry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MetadataEntry *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Name", &(a->ns1__MetadataEntry::Name), "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:Value", &(a->ns1__MetadataEntry::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MetadataEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MetadataEntry, 0, sizeof(ns1__MetadataEntry), 0, soap_copy_ns1__MetadataEntry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__MetadataEntry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MetadataEntry);
	if (this->soap_out(soap, tag?tag:"ns1:MetadataEntry", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MetadataEntry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MetadataEntry(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MetadataEntry * SOAP_FMAC4 soap_get_ns1__MetadataEntry(struct soap *soap, ns1__MetadataEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MetadataEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__MetadataEntry * SOAP_FMAC2 soap_instantiate_ns1__MetadataEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MetadataEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MetadataEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__MetadataEntry);
		if (size)
			*size = sizeof(ns1__MetadataEntry);
		((ns1__MetadataEntry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__MetadataEntry[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MetadataEntry);
		for (int i = 0; i < n; i++)
			((ns1__MetadataEntry*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MetadataEntry*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MetadataEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MetadataEntry %p -> %p\n", q, p));
	*(ns1__MetadataEntry*)p = *(ns1__MetadataEntry*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CopyObject(struct soap *soap, struct __ns1__CopyObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CopyObject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CopyObject(struct soap *soap, const struct __ns1__CopyObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CopyObject(soap, &a->ns1__CopyObject);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CopyObject(struct soap *soap, const char *tag, int id, const struct __ns1__CopyObject *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CopyObject(soap, "ns1:CopyObject", -1, &a->ns1__CopyObject, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CopyObject * SOAP_FMAC4 soap_in___ns1__CopyObject(struct soap *soap, const char *tag, struct __ns1__CopyObject *a, const char *type)
{
	size_t soap_flag_ns1__CopyObject = 1;
	short soap_flag;
	a = (struct __ns1__CopyObject *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CopyObject, sizeof(struct __ns1__CopyObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CopyObject(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CopyObject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CopyObject(soap, "ns1:CopyObject", &a->ns1__CopyObject, ""))
				{	soap_flag_ns1__CopyObject--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CopyObject(struct soap *soap, const struct __ns1__CopyObject *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CopyObject(soap, tag?tag:"-ns1:CopyObject", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CopyObject * SOAP_FMAC4 soap_get___ns1__CopyObject(struct soap *soap, struct __ns1__CopyObject *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CopyObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__CopyObject * SOAP_FMAC2 soap_instantiate___ns1__CopyObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CopyObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CopyObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CopyObject);
		if (size)
			*size = sizeof(struct __ns1__CopyObject);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CopyObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CopyObject);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CopyObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CopyObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CopyObject %p -> %p\n", q, p));
	*(struct __ns1__CopyObject*)p = *(struct __ns1__CopyObject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBucketLoggingStatus(struct soap *soap, struct __ns1__GetBucketLoggingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetBucketLoggingStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBucketLoggingStatus(struct soap *soap, const struct __ns1__GetBucketLoggingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetBucketLoggingStatus(soap, &a->ns1__GetBucketLoggingStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetBucketLoggingStatus(struct soap *soap, const char *tag, int id, const struct __ns1__GetBucketLoggingStatus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetBucketLoggingStatus(soap, "ns1:GetBucketLoggingStatus", -1, &a->ns1__GetBucketLoggingStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBucketLoggingStatus * SOAP_FMAC4 soap_in___ns1__GetBucketLoggingStatus(struct soap *soap, const char *tag, struct __ns1__GetBucketLoggingStatus *a, const char *type)
{
	size_t soap_flag_ns1__GetBucketLoggingStatus = 1;
	short soap_flag;
	a = (struct __ns1__GetBucketLoggingStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBucketLoggingStatus, sizeof(struct __ns1__GetBucketLoggingStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetBucketLoggingStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetBucketLoggingStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetBucketLoggingStatus(soap, "ns1:GetBucketLoggingStatus", &a->ns1__GetBucketLoggingStatus, ""))
				{	soap_flag_ns1__GetBucketLoggingStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBucketLoggingStatus(struct soap *soap, const struct __ns1__GetBucketLoggingStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetBucketLoggingStatus(soap, tag?tag:"-ns1:GetBucketLoggingStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBucketLoggingStatus * SOAP_FMAC4 soap_get___ns1__GetBucketLoggingStatus(struct soap *soap, struct __ns1__GetBucketLoggingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetBucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBucketLoggingStatus * SOAP_FMAC2 soap_instantiate___ns1__GetBucketLoggingStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBucketLoggingStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBucketLoggingStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBucketLoggingStatus);
		if (size)
			*size = sizeof(struct __ns1__GetBucketLoggingStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBucketLoggingStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetBucketLoggingStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBucketLoggingStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBucketLoggingStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBucketLoggingStatus %p -> %p\n", q, p));
	*(struct __ns1__GetBucketLoggingStatus*)p = *(struct __ns1__GetBucketLoggingStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetBucketLoggingStatus(struct soap *soap, struct __ns1__SetBucketLoggingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetBucketLoggingStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetBucketLoggingStatus(struct soap *soap, const struct __ns1__SetBucketLoggingStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetBucketLoggingStatus(soap, &a->ns1__SetBucketLoggingStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetBucketLoggingStatus(struct soap *soap, const char *tag, int id, const struct __ns1__SetBucketLoggingStatus *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetBucketLoggingStatus(soap, "ns1:SetBucketLoggingStatus", -1, &a->ns1__SetBucketLoggingStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetBucketLoggingStatus * SOAP_FMAC4 soap_in___ns1__SetBucketLoggingStatus(struct soap *soap, const char *tag, struct __ns1__SetBucketLoggingStatus *a, const char *type)
{
	size_t soap_flag_ns1__SetBucketLoggingStatus = 1;
	short soap_flag;
	a = (struct __ns1__SetBucketLoggingStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetBucketLoggingStatus, sizeof(struct __ns1__SetBucketLoggingStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetBucketLoggingStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetBucketLoggingStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetBucketLoggingStatus(soap, "ns1:SetBucketLoggingStatus", &a->ns1__SetBucketLoggingStatus, ""))
				{	soap_flag_ns1__SetBucketLoggingStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetBucketLoggingStatus(struct soap *soap, const struct __ns1__SetBucketLoggingStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetBucketLoggingStatus(soap, tag?tag:"-ns1:SetBucketLoggingStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetBucketLoggingStatus * SOAP_FMAC4 soap_get___ns1__SetBucketLoggingStatus(struct soap *soap, struct __ns1__SetBucketLoggingStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetBucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetBucketLoggingStatus * SOAP_FMAC2 soap_instantiate___ns1__SetBucketLoggingStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetBucketLoggingStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetBucketLoggingStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetBucketLoggingStatus);
		if (size)
			*size = sizeof(struct __ns1__SetBucketLoggingStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetBucketLoggingStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__SetBucketLoggingStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__SetBucketLoggingStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetBucketLoggingStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetBucketLoggingStatus %p -> %p\n", q, p));
	*(struct __ns1__SetBucketLoggingStatus*)p = *(struct __ns1__SetBucketLoggingStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ListAllMyBuckets(struct soap *soap, struct __ns1__ListAllMyBuckets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ListAllMyBuckets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ListAllMyBuckets(struct soap *soap, const struct __ns1__ListAllMyBuckets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ListAllMyBuckets(soap, &a->ns1__ListAllMyBuckets);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ListAllMyBuckets(struct soap *soap, const char *tag, int id, const struct __ns1__ListAllMyBuckets *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ListAllMyBuckets(soap, "ns1:ListAllMyBuckets", -1, &a->ns1__ListAllMyBuckets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ListAllMyBuckets * SOAP_FMAC4 soap_in___ns1__ListAllMyBuckets(struct soap *soap, const char *tag, struct __ns1__ListAllMyBuckets *a, const char *type)
{
	size_t soap_flag_ns1__ListAllMyBuckets = 1;
	short soap_flag;
	a = (struct __ns1__ListAllMyBuckets *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ListAllMyBuckets, sizeof(struct __ns1__ListAllMyBuckets), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ListAllMyBuckets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ListAllMyBuckets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ListAllMyBuckets(soap, "ns1:ListAllMyBuckets", &a->ns1__ListAllMyBuckets, ""))
				{	soap_flag_ns1__ListAllMyBuckets--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ListAllMyBuckets(struct soap *soap, const struct __ns1__ListAllMyBuckets *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ListAllMyBuckets(soap, tag?tag:"-ns1:ListAllMyBuckets", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ListAllMyBuckets * SOAP_FMAC4 soap_get___ns1__ListAllMyBuckets(struct soap *soap, struct __ns1__ListAllMyBuckets *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ListAllMyBuckets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ListAllMyBuckets * SOAP_FMAC2 soap_instantiate___ns1__ListAllMyBuckets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ListAllMyBuckets(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ListAllMyBuckets, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ListAllMyBuckets);
		if (size)
			*size = sizeof(struct __ns1__ListAllMyBuckets);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ListAllMyBuckets[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__ListAllMyBuckets);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__ListAllMyBuckets*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ListAllMyBuckets(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ListAllMyBuckets %p -> %p\n", q, p));
	*(struct __ns1__ListAllMyBuckets*)p = *(struct __ns1__ListAllMyBuckets*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ListBucket(struct soap *soap, struct __ns1__ListBucket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ListBucket = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ListBucket(struct soap *soap, const struct __ns1__ListBucket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__ListBucket(soap, &a->ns1__ListBucket);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ListBucket(struct soap *soap, const char *tag, int id, const struct __ns1__ListBucket *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__ListBucket(soap, "ns1:ListBucket", -1, &a->ns1__ListBucket, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ListBucket * SOAP_FMAC4 soap_in___ns1__ListBucket(struct soap *soap, const char *tag, struct __ns1__ListBucket *a, const char *type)
{
	size_t soap_flag_ns1__ListBucket = 1;
	short soap_flag;
	a = (struct __ns1__ListBucket *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ListBucket, sizeof(struct __ns1__ListBucket), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ListBucket(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ListBucket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ListBucket(soap, "ns1:ListBucket", &a->ns1__ListBucket, ""))
				{	soap_flag_ns1__ListBucket--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ListBucket(struct soap *soap, const struct __ns1__ListBucket *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__ListBucket(soap, tag?tag:"-ns1:ListBucket", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ListBucket * SOAP_FMAC4 soap_get___ns1__ListBucket(struct soap *soap, struct __ns1__ListBucket *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ListBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__ListBucket * SOAP_FMAC2 soap_instantiate___ns1__ListBucket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ListBucket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__ListBucket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ListBucket);
		if (size)
			*size = sizeof(struct __ns1__ListBucket);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__ListBucket[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__ListBucket);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__ListBucket*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__ListBucket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__ListBucket %p -> %p\n", q, p));
	*(struct __ns1__ListBucket*)p = *(struct __ns1__ListBucket*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DeleteObject(struct soap *soap, struct __ns1__DeleteObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteObject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DeleteObject(struct soap *soap, const struct __ns1__DeleteObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteObject(soap, &a->ns1__DeleteObject);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DeleteObject(struct soap *soap, const char *tag, int id, const struct __ns1__DeleteObject *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__DeleteObject(soap, "ns1:DeleteObject", -1, &a->ns1__DeleteObject, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteObject * SOAP_FMAC4 soap_in___ns1__DeleteObject(struct soap *soap, const char *tag, struct __ns1__DeleteObject *a, const char *type)
{
	size_t soap_flag_ns1__DeleteObject = 1;
	short soap_flag;
	a = (struct __ns1__DeleteObject *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DeleteObject, sizeof(struct __ns1__DeleteObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DeleteObject(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteObject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteObject(soap, "ns1:DeleteObject", &a->ns1__DeleteObject, ""))
				{	soap_flag_ns1__DeleteObject--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DeleteObject(struct soap *soap, const struct __ns1__DeleteObject *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DeleteObject(soap, tag?tag:"-ns1:DeleteObject", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteObject * SOAP_FMAC4 soap_get___ns1__DeleteObject(struct soap *soap, struct __ns1__DeleteObject *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DeleteObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__DeleteObject * SOAP_FMAC2 soap_instantiate___ns1__DeleteObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DeleteObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DeleteObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DeleteObject);
		if (size)
			*size = sizeof(struct __ns1__DeleteObject);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DeleteObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__DeleteObject);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__DeleteObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DeleteObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DeleteObject %p -> %p\n", q, p));
	*(struct __ns1__DeleteObject*)p = *(struct __ns1__DeleteObject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PutObjectInline(struct soap *soap, struct __ns1__PutObjectInline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PutObjectInline = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PutObjectInline(struct soap *soap, const struct __ns1__PutObjectInline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PutObjectInline(soap, &a->ns1__PutObjectInline);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PutObjectInline(struct soap *soap, const char *tag, int id, const struct __ns1__PutObjectInline *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__PutObjectInline(soap, "ns1:PutObjectInline", -1, &a->ns1__PutObjectInline, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PutObjectInline * SOAP_FMAC4 soap_in___ns1__PutObjectInline(struct soap *soap, const char *tag, struct __ns1__PutObjectInline *a, const char *type)
{
	size_t soap_flag_ns1__PutObjectInline = 1;
	short soap_flag;
	a = (struct __ns1__PutObjectInline *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__PutObjectInline, sizeof(struct __ns1__PutObjectInline), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PutObjectInline(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PutObjectInline && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PutObjectInline(soap, "ns1:PutObjectInline", &a->ns1__PutObjectInline, ""))
				{	soap_flag_ns1__PutObjectInline--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PutObjectInline(struct soap *soap, const struct __ns1__PutObjectInline *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__PutObjectInline(soap, tag?tag:"-ns1:PutObjectInline", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PutObjectInline * SOAP_FMAC4 soap_get___ns1__PutObjectInline(struct soap *soap, struct __ns1__PutObjectInline *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PutObjectInline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__PutObjectInline * SOAP_FMAC2 soap_instantiate___ns1__PutObjectInline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PutObjectInline(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__PutObjectInline, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__PutObjectInline);
		if (size)
			*size = sizeof(struct __ns1__PutObjectInline);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__PutObjectInline[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__PutObjectInline);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__PutObjectInline*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__PutObjectInline(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__PutObjectInline %p -> %p\n", q, p));
	*(struct __ns1__PutObjectInline*)p = *(struct __ns1__PutObjectInline*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__PutObject(struct soap *soap, struct __ns1__PutObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__PutObject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__PutObject(struct soap *soap, const struct __ns1__PutObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__PutObject(soap, &a->ns1__PutObject);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__PutObject(struct soap *soap, const char *tag, int id, const struct __ns1__PutObject *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__PutObject(soap, "ns1:PutObject", -1, &a->ns1__PutObject, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PutObject * SOAP_FMAC4 soap_in___ns1__PutObject(struct soap *soap, const char *tag, struct __ns1__PutObject *a, const char *type)
{
	size_t soap_flag_ns1__PutObject = 1;
	short soap_flag;
	a = (struct __ns1__PutObject *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__PutObject, sizeof(struct __ns1__PutObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__PutObject(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__PutObject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__PutObject(soap, "ns1:PutObject", &a->ns1__PutObject, ""))
				{	soap_flag_ns1__PutObject--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__PutObject(struct soap *soap, const struct __ns1__PutObject *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__PutObject(soap, tag?tag:"-ns1:PutObject", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__PutObject * SOAP_FMAC4 soap_get___ns1__PutObject(struct soap *soap, struct __ns1__PutObject *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__PutObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__PutObject * SOAP_FMAC2 soap_instantiate___ns1__PutObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__PutObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__PutObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__PutObject);
		if (size)
			*size = sizeof(struct __ns1__PutObject);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__PutObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__PutObject);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__PutObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__PutObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__PutObject %p -> %p\n", q, p));
	*(struct __ns1__PutObject*)p = *(struct __ns1__PutObject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetObjectExtended(struct soap *soap, struct __ns1__GetObjectExtended *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetObjectExtended = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetObjectExtended(struct soap *soap, const struct __ns1__GetObjectExtended *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetObjectExtended(soap, &a->ns1__GetObjectExtended);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetObjectExtended(struct soap *soap, const char *tag, int id, const struct __ns1__GetObjectExtended *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetObjectExtended(soap, "ns1:GetObjectExtended", -1, &a->ns1__GetObjectExtended, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObjectExtended * SOAP_FMAC4 soap_in___ns1__GetObjectExtended(struct soap *soap, const char *tag, struct __ns1__GetObjectExtended *a, const char *type)
{
	size_t soap_flag_ns1__GetObjectExtended = 1;
	short soap_flag;
	a = (struct __ns1__GetObjectExtended *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetObjectExtended, sizeof(struct __ns1__GetObjectExtended), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetObjectExtended(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetObjectExtended && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetObjectExtended(soap, "ns1:GetObjectExtended", &a->ns1__GetObjectExtended, ""))
				{	soap_flag_ns1__GetObjectExtended--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetObjectExtended(struct soap *soap, const struct __ns1__GetObjectExtended *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetObjectExtended(soap, tag?tag:"-ns1:GetObjectExtended", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObjectExtended * SOAP_FMAC4 soap_get___ns1__GetObjectExtended(struct soap *soap, struct __ns1__GetObjectExtended *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetObjectExtended(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetObjectExtended * SOAP_FMAC2 soap_instantiate___ns1__GetObjectExtended(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetObjectExtended(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetObjectExtended, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetObjectExtended);
		if (size)
			*size = sizeof(struct __ns1__GetObjectExtended);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetObjectExtended[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetObjectExtended);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetObjectExtended*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetObjectExtended(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetObjectExtended %p -> %p\n", q, p));
	*(struct __ns1__GetObjectExtended*)p = *(struct __ns1__GetObjectExtended*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetObject(struct soap *soap, struct __ns1__GetObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetObject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetObject(struct soap *soap, const struct __ns1__GetObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetObject(soap, &a->ns1__GetObject);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetObject(struct soap *soap, const char *tag, int id, const struct __ns1__GetObject *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetObject(soap, "ns1:GetObject", -1, &a->ns1__GetObject, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObject * SOAP_FMAC4 soap_in___ns1__GetObject(struct soap *soap, const char *tag, struct __ns1__GetObject *a, const char *type)
{
	size_t soap_flag_ns1__GetObject = 1;
	short soap_flag;
	a = (struct __ns1__GetObject *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetObject, sizeof(struct __ns1__GetObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetObject(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetObject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetObject(soap, "ns1:GetObject", &a->ns1__GetObject, ""))
				{	soap_flag_ns1__GetObject--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetObject(struct soap *soap, const struct __ns1__GetObject *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetObject(soap, tag?tag:"-ns1:GetObject", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObject * SOAP_FMAC4 soap_get___ns1__GetObject(struct soap *soap, struct __ns1__GetObject *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetObject * SOAP_FMAC2 soap_instantiate___ns1__GetObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetObject);
		if (size)
			*size = sizeof(struct __ns1__GetObject);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetObject[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetObject);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetObject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetObject %p -> %p\n", q, p));
	*(struct __ns1__GetObject*)p = *(struct __ns1__GetObject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetBucketAccessControlPolicy(struct soap *soap, struct __ns1__SetBucketAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetBucketAccessControlPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetBucketAccessControlPolicy(struct soap *soap, const struct __ns1__SetBucketAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetBucketAccessControlPolicy(soap, &a->ns1__SetBucketAccessControlPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetBucketAccessControlPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__SetBucketAccessControlPolicy *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetBucketAccessControlPolicy(soap, "ns1:SetBucketAccessControlPolicy", -1, &a->ns1__SetBucketAccessControlPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetBucketAccessControlPolicy * SOAP_FMAC4 soap_in___ns1__SetBucketAccessControlPolicy(struct soap *soap, const char *tag, struct __ns1__SetBucketAccessControlPolicy *a, const char *type)
{
	size_t soap_flag_ns1__SetBucketAccessControlPolicy = 1;
	short soap_flag;
	a = (struct __ns1__SetBucketAccessControlPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetBucketAccessControlPolicy, sizeof(struct __ns1__SetBucketAccessControlPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetBucketAccessControlPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetBucketAccessControlPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetBucketAccessControlPolicy(soap, "ns1:SetBucketAccessControlPolicy", &a->ns1__SetBucketAccessControlPolicy, ""))
				{	soap_flag_ns1__SetBucketAccessControlPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetBucketAccessControlPolicy(struct soap *soap, const struct __ns1__SetBucketAccessControlPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetBucketAccessControlPolicy(soap, tag?tag:"-ns1:SetBucketAccessControlPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetBucketAccessControlPolicy * SOAP_FMAC4 soap_get___ns1__SetBucketAccessControlPolicy(struct soap *soap, struct __ns1__SetBucketAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetBucketAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetBucketAccessControlPolicy * SOAP_FMAC2 soap_instantiate___ns1__SetBucketAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetBucketAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetBucketAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetBucketAccessControlPolicy);
		if (size)
			*size = sizeof(struct __ns1__SetBucketAccessControlPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetBucketAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__SetBucketAccessControlPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__SetBucketAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetBucketAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetBucketAccessControlPolicy %p -> %p\n", q, p));
	*(struct __ns1__SetBucketAccessControlPolicy*)p = *(struct __ns1__SetBucketAccessControlPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetObjectAccessControlPolicy(struct soap *soap, struct __ns1__SetObjectAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetObjectAccessControlPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetObjectAccessControlPolicy(struct soap *soap, const struct __ns1__SetObjectAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SetObjectAccessControlPolicy(soap, &a->ns1__SetObjectAccessControlPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetObjectAccessControlPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__SetObjectAccessControlPolicy *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__SetObjectAccessControlPolicy(soap, "ns1:SetObjectAccessControlPolicy", -1, &a->ns1__SetObjectAccessControlPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetObjectAccessControlPolicy * SOAP_FMAC4 soap_in___ns1__SetObjectAccessControlPolicy(struct soap *soap, const char *tag, struct __ns1__SetObjectAccessControlPolicy *a, const char *type)
{
	size_t soap_flag_ns1__SetObjectAccessControlPolicy = 1;
	short soap_flag;
	a = (struct __ns1__SetObjectAccessControlPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetObjectAccessControlPolicy, sizeof(struct __ns1__SetObjectAccessControlPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetObjectAccessControlPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetObjectAccessControlPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SetObjectAccessControlPolicy(soap, "ns1:SetObjectAccessControlPolicy", &a->ns1__SetObjectAccessControlPolicy, ""))
				{	soap_flag_ns1__SetObjectAccessControlPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetObjectAccessControlPolicy(struct soap *soap, const struct __ns1__SetObjectAccessControlPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SetObjectAccessControlPolicy(soap, tag?tag:"-ns1:SetObjectAccessControlPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetObjectAccessControlPolicy * SOAP_FMAC4 soap_get___ns1__SetObjectAccessControlPolicy(struct soap *soap, struct __ns1__SetObjectAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetObjectAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SetObjectAccessControlPolicy * SOAP_FMAC2 soap_instantiate___ns1__SetObjectAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetObjectAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SetObjectAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetObjectAccessControlPolicy);
		if (size)
			*size = sizeof(struct __ns1__SetObjectAccessControlPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__SetObjectAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__SetObjectAccessControlPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__SetObjectAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SetObjectAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SetObjectAccessControlPolicy %p -> %p\n", q, p));
	*(struct __ns1__SetObjectAccessControlPolicy*)p = *(struct __ns1__SetObjectAccessControlPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetBucketAccessControlPolicy(struct soap *soap, struct __ns1__GetBucketAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetBucketAccessControlPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetBucketAccessControlPolicy(struct soap *soap, const struct __ns1__GetBucketAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetBucketAccessControlPolicy(soap, &a->ns1__GetBucketAccessControlPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetBucketAccessControlPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__GetBucketAccessControlPolicy *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetBucketAccessControlPolicy(soap, "ns1:GetBucketAccessControlPolicy", -1, &a->ns1__GetBucketAccessControlPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBucketAccessControlPolicy * SOAP_FMAC4 soap_in___ns1__GetBucketAccessControlPolicy(struct soap *soap, const char *tag, struct __ns1__GetBucketAccessControlPolicy *a, const char *type)
{
	size_t soap_flag_ns1__GetBucketAccessControlPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetBucketAccessControlPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetBucketAccessControlPolicy, sizeof(struct __ns1__GetBucketAccessControlPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetBucketAccessControlPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetBucketAccessControlPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetBucketAccessControlPolicy(soap, "ns1:GetBucketAccessControlPolicy", &a->ns1__GetBucketAccessControlPolicy, ""))
				{	soap_flag_ns1__GetBucketAccessControlPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetBucketAccessControlPolicy(struct soap *soap, const struct __ns1__GetBucketAccessControlPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetBucketAccessControlPolicy(soap, tag?tag:"-ns1:GetBucketAccessControlPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetBucketAccessControlPolicy * SOAP_FMAC4 soap_get___ns1__GetBucketAccessControlPolicy(struct soap *soap, struct __ns1__GetBucketAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetBucketAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetBucketAccessControlPolicy * SOAP_FMAC2 soap_instantiate___ns1__GetBucketAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetBucketAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetBucketAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBucketAccessControlPolicy);
		if (size)
			*size = sizeof(struct __ns1__GetBucketAccessControlPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetBucketAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetBucketAccessControlPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetBucketAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetBucketAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetBucketAccessControlPolicy %p -> %p\n", q, p));
	*(struct __ns1__GetBucketAccessControlPolicy*)p = *(struct __ns1__GetBucketAccessControlPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetObjectAccessControlPolicy(struct soap *soap, struct __ns1__GetObjectAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetObjectAccessControlPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetObjectAccessControlPolicy(struct soap *soap, const struct __ns1__GetObjectAccessControlPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetObjectAccessControlPolicy(soap, &a->ns1__GetObjectAccessControlPolicy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetObjectAccessControlPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__GetObjectAccessControlPolicy *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetObjectAccessControlPolicy(soap, "ns1:GetObjectAccessControlPolicy", -1, &a->ns1__GetObjectAccessControlPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObjectAccessControlPolicy * SOAP_FMAC4 soap_in___ns1__GetObjectAccessControlPolicy(struct soap *soap, const char *tag, struct __ns1__GetObjectAccessControlPolicy *a, const char *type)
{
	size_t soap_flag_ns1__GetObjectAccessControlPolicy = 1;
	short soap_flag;
	a = (struct __ns1__GetObjectAccessControlPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetObjectAccessControlPolicy, sizeof(struct __ns1__GetObjectAccessControlPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetObjectAccessControlPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetObjectAccessControlPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetObjectAccessControlPolicy(soap, "ns1:GetObjectAccessControlPolicy", &a->ns1__GetObjectAccessControlPolicy, ""))
				{	soap_flag_ns1__GetObjectAccessControlPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetObjectAccessControlPolicy(struct soap *soap, const struct __ns1__GetObjectAccessControlPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetObjectAccessControlPolicy(soap, tag?tag:"-ns1:GetObjectAccessControlPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetObjectAccessControlPolicy * SOAP_FMAC4 soap_get___ns1__GetObjectAccessControlPolicy(struct soap *soap, struct __ns1__GetObjectAccessControlPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetObjectAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetObjectAccessControlPolicy * SOAP_FMAC2 soap_instantiate___ns1__GetObjectAccessControlPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetObjectAccessControlPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetObjectAccessControlPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetObjectAccessControlPolicy);
		if (size)
			*size = sizeof(struct __ns1__GetObjectAccessControlPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetObjectAccessControlPolicy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetObjectAccessControlPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetObjectAccessControlPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetObjectAccessControlPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetObjectAccessControlPolicy %p -> %p\n", q, p));
	*(struct __ns1__GetObjectAccessControlPolicy*)p = *(struct __ns1__GetObjectAccessControlPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DeleteBucket(struct soap *soap, struct __ns1__DeleteBucket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DeleteBucket = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DeleteBucket(struct soap *soap, const struct __ns1__DeleteBucket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__DeleteBucket(soap, &a->ns1__DeleteBucket);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DeleteBucket(struct soap *soap, const char *tag, int id, const struct __ns1__DeleteBucket *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__DeleteBucket(soap, "ns1:DeleteBucket", -1, &a->ns1__DeleteBucket, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteBucket * SOAP_FMAC4 soap_in___ns1__DeleteBucket(struct soap *soap, const char *tag, struct __ns1__DeleteBucket *a, const char *type)
{
	size_t soap_flag_ns1__DeleteBucket = 1;
	short soap_flag;
	a = (struct __ns1__DeleteBucket *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DeleteBucket, sizeof(struct __ns1__DeleteBucket), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DeleteBucket(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DeleteBucket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DeleteBucket(soap, "ns1:DeleteBucket", &a->ns1__DeleteBucket, ""))
				{	soap_flag_ns1__DeleteBucket--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DeleteBucket(struct soap *soap, const struct __ns1__DeleteBucket *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__DeleteBucket(soap, tag?tag:"-ns1:DeleteBucket", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DeleteBucket * SOAP_FMAC4 soap_get___ns1__DeleteBucket(struct soap *soap, struct __ns1__DeleteBucket *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DeleteBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__DeleteBucket * SOAP_FMAC2 soap_instantiate___ns1__DeleteBucket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DeleteBucket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__DeleteBucket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DeleteBucket);
		if (size)
			*size = sizeof(struct __ns1__DeleteBucket);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__DeleteBucket[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__DeleteBucket);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__DeleteBucket*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__DeleteBucket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__DeleteBucket %p -> %p\n", q, p));
	*(struct __ns1__DeleteBucket*)p = *(struct __ns1__DeleteBucket*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CreateBucket(struct soap *soap, struct __ns1__CreateBucket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CreateBucket = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CreateBucket(struct soap *soap, const struct __ns1__CreateBucket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CreateBucket(soap, &a->ns1__CreateBucket);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CreateBucket(struct soap *soap, const char *tag, int id, const struct __ns1__CreateBucket *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CreateBucket(soap, "ns1:CreateBucket", -1, &a->ns1__CreateBucket, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CreateBucket * SOAP_FMAC4 soap_in___ns1__CreateBucket(struct soap *soap, const char *tag, struct __ns1__CreateBucket *a, const char *type)
{
	size_t soap_flag_ns1__CreateBucket = 1;
	short soap_flag;
	a = (struct __ns1__CreateBucket *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CreateBucket, sizeof(struct __ns1__CreateBucket), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CreateBucket(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CreateBucket && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CreateBucket(soap, "ns1:CreateBucket", &a->ns1__CreateBucket, ""))
				{	soap_flag_ns1__CreateBucket--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CreateBucket(struct soap *soap, const struct __ns1__CreateBucket *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CreateBucket(soap, tag?tag:"-ns1:CreateBucket", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CreateBucket * SOAP_FMAC4 soap_get___ns1__CreateBucket(struct soap *soap, struct __ns1__CreateBucket *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CreateBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__CreateBucket * SOAP_FMAC2 soap_instantiate___ns1__CreateBucket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CreateBucket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CreateBucket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CreateBucket);
		if (size)
			*size = sizeof(struct __ns1__CreateBucket);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CreateBucket[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__CreateBucket);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__CreateBucket*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CreateBucket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CreateBucket %p -> %p\n", q, p));
	*(struct __ns1__CreateBucket*)p = *(struct __ns1__CreateBucket*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CopyObjectResponse(struct soap *soap, _ns1__CopyObjectResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CopyObjectResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CopyObjectResponse(struct soap *soap, const char *tag, int id, _ns1__CopyObjectResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CopyObjectResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CopyObjectResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CopyObjectResponse(struct soap *soap, const char *tag, _ns1__CopyObjectResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CopyObjectResponse **)soap_malloc(soap, sizeof(_ns1__CopyObjectResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CopyObjectResponse *)soap_instantiate__ns1__CopyObjectResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CopyObjectResponse ** p = (_ns1__CopyObjectResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CopyObjectResponse, sizeof(_ns1__CopyObjectResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CopyObjectResponse(struct soap *soap, _ns1__CopyObjectResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CopyObjectResponse);
	if (soap_out_PointerTo_ns1__CopyObjectResponse(soap, tag?tag:"ns1:CopyObjectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CopyObjectResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CopyObjectResponse(struct soap *soap, _ns1__CopyObjectResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CopyObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CopyObject(struct soap *soap, _ns1__CopyObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CopyObject))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CopyObject(struct soap *soap, const char *tag, int id, _ns1__CopyObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CopyObject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CopyObject ** SOAP_FMAC4 soap_in_PointerTo_ns1__CopyObject(struct soap *soap, const char *tag, _ns1__CopyObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CopyObject **)soap_malloc(soap, sizeof(_ns1__CopyObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CopyObject *)soap_instantiate__ns1__CopyObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CopyObject ** p = (_ns1__CopyObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CopyObject, sizeof(_ns1__CopyObject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CopyObject(struct soap *soap, _ns1__CopyObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CopyObject);
	if (soap_out_PointerTo_ns1__CopyObject(soap, tag?tag:"ns1:CopyObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CopyObject ** SOAP_FMAC4 soap_get_PointerTo_ns1__CopyObject(struct soap *soap, _ns1__CopyObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CopyObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBucketLoggingStatusResponse(struct soap *soap, _ns1__GetBucketLoggingStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBucketLoggingStatusResponse(struct soap *soap, const char *tag, int id, _ns1__GetBucketLoggingStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBucketLoggingStatusResponse(struct soap *soap, const char *tag, _ns1__GetBucketLoggingStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBucketLoggingStatusResponse **)soap_malloc(soap, sizeof(_ns1__GetBucketLoggingStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBucketLoggingStatusResponse *)soap_instantiate__ns1__GetBucketLoggingStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBucketLoggingStatusResponse ** p = (_ns1__GetBucketLoggingStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBucketLoggingStatusResponse, sizeof(_ns1__GetBucketLoggingStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBucketLoggingStatusResponse(struct soap *soap, _ns1__GetBucketLoggingStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatusResponse);
	if (soap_out_PointerTo_ns1__GetBucketLoggingStatusResponse(soap, tag?tag:"ns1:GetBucketLoggingStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBucketLoggingStatusResponse(struct soap *soap, _ns1__GetBucketLoggingStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBucketLoggingStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBucketLoggingStatus(struct soap *soap, _ns1__GetBucketLoggingStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBucketLoggingStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBucketLoggingStatus(struct soap *soap, const char *tag, int id, _ns1__GetBucketLoggingStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBucketLoggingStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBucketLoggingStatus(struct soap *soap, const char *tag, _ns1__GetBucketLoggingStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBucketLoggingStatus **)soap_malloc(soap, sizeof(_ns1__GetBucketLoggingStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBucketLoggingStatus *)soap_instantiate__ns1__GetBucketLoggingStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBucketLoggingStatus ** p = (_ns1__GetBucketLoggingStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBucketLoggingStatus, sizeof(_ns1__GetBucketLoggingStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBucketLoggingStatus(struct soap *soap, _ns1__GetBucketLoggingStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBucketLoggingStatus);
	if (soap_out_PointerTo_ns1__GetBucketLoggingStatus(soap, tag?tag:"ns1:GetBucketLoggingStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBucketLoggingStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBucketLoggingStatus(struct soap *soap, _ns1__GetBucketLoggingStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetBucketLoggingStatusResponse(struct soap *soap, _ns1__SetBucketLoggingStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetBucketLoggingStatusResponse(struct soap *soap, const char *tag, int id, _ns1__SetBucketLoggingStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetBucketLoggingStatusResponse(struct soap *soap, const char *tag, _ns1__SetBucketLoggingStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetBucketLoggingStatusResponse **)soap_malloc(soap, sizeof(_ns1__SetBucketLoggingStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetBucketLoggingStatusResponse *)soap_instantiate__ns1__SetBucketLoggingStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetBucketLoggingStatusResponse ** p = (_ns1__SetBucketLoggingStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetBucketLoggingStatusResponse, sizeof(_ns1__SetBucketLoggingStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetBucketLoggingStatusResponse(struct soap *soap, _ns1__SetBucketLoggingStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatusResponse);
	if (soap_out_PointerTo_ns1__SetBucketLoggingStatusResponse(soap, tag?tag:"ns1:SetBucketLoggingStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetBucketLoggingStatusResponse(struct soap *soap, _ns1__SetBucketLoggingStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetBucketLoggingStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetBucketLoggingStatus(struct soap *soap, _ns1__SetBucketLoggingStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetBucketLoggingStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetBucketLoggingStatus(struct soap *soap, const char *tag, int id, _ns1__SetBucketLoggingStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetBucketLoggingStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetBucketLoggingStatus(struct soap *soap, const char *tag, _ns1__SetBucketLoggingStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetBucketLoggingStatus **)soap_malloc(soap, sizeof(_ns1__SetBucketLoggingStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetBucketLoggingStatus *)soap_instantiate__ns1__SetBucketLoggingStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetBucketLoggingStatus ** p = (_ns1__SetBucketLoggingStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetBucketLoggingStatus, sizeof(_ns1__SetBucketLoggingStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetBucketLoggingStatus(struct soap *soap, _ns1__SetBucketLoggingStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetBucketLoggingStatus);
	if (soap_out_PointerTo_ns1__SetBucketLoggingStatus(soap, tag?tag:"ns1:SetBucketLoggingStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetBucketLoggingStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetBucketLoggingStatus(struct soap *soap, _ns1__SetBucketLoggingStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetBucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ListAllMyBucketsResponse(struct soap *soap, _ns1__ListAllMyBucketsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ListAllMyBucketsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ListAllMyBucketsResponse(struct soap *soap, const char *tag, int id, _ns1__ListAllMyBucketsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ListAllMyBucketsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ListAllMyBucketsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ListAllMyBucketsResponse(struct soap *soap, const char *tag, _ns1__ListAllMyBucketsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ListAllMyBucketsResponse **)soap_malloc(soap, sizeof(_ns1__ListAllMyBucketsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ListAllMyBucketsResponse *)soap_instantiate__ns1__ListAllMyBucketsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ListAllMyBucketsResponse ** p = (_ns1__ListAllMyBucketsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ListAllMyBucketsResponse, sizeof(_ns1__ListAllMyBucketsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ListAllMyBucketsResponse(struct soap *soap, _ns1__ListAllMyBucketsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ListAllMyBucketsResponse);
	if (soap_out_PointerTo_ns1__ListAllMyBucketsResponse(soap, tag?tag:"ns1:ListAllMyBucketsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ListAllMyBucketsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ListAllMyBucketsResponse(struct soap *soap, _ns1__ListAllMyBucketsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ListAllMyBucketsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ListAllMyBuckets(struct soap *soap, _ns1__ListAllMyBuckets *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ListAllMyBuckets))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ListAllMyBuckets(struct soap *soap, const char *tag, int id, _ns1__ListAllMyBuckets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ListAllMyBuckets);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ListAllMyBuckets ** SOAP_FMAC4 soap_in_PointerTo_ns1__ListAllMyBuckets(struct soap *soap, const char *tag, _ns1__ListAllMyBuckets **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ListAllMyBuckets **)soap_malloc(soap, sizeof(_ns1__ListAllMyBuckets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ListAllMyBuckets *)soap_instantiate__ns1__ListAllMyBuckets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ListAllMyBuckets ** p = (_ns1__ListAllMyBuckets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ListAllMyBuckets, sizeof(_ns1__ListAllMyBuckets), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ListAllMyBuckets(struct soap *soap, _ns1__ListAllMyBuckets *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ListAllMyBuckets);
	if (soap_out_PointerTo_ns1__ListAllMyBuckets(soap, tag?tag:"ns1:ListAllMyBuckets", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ListAllMyBuckets ** SOAP_FMAC4 soap_get_PointerTo_ns1__ListAllMyBuckets(struct soap *soap, _ns1__ListAllMyBuckets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ListAllMyBuckets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ListBucketResponse(struct soap *soap, _ns1__ListBucketResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ListBucketResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ListBucketResponse(struct soap *soap, const char *tag, int id, _ns1__ListBucketResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ListBucketResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ListBucketResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ListBucketResponse(struct soap *soap, const char *tag, _ns1__ListBucketResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ListBucketResponse **)soap_malloc(soap, sizeof(_ns1__ListBucketResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ListBucketResponse *)soap_instantiate__ns1__ListBucketResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ListBucketResponse ** p = (_ns1__ListBucketResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ListBucketResponse, sizeof(_ns1__ListBucketResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ListBucketResponse(struct soap *soap, _ns1__ListBucketResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ListBucketResponse);
	if (soap_out_PointerTo_ns1__ListBucketResponse(soap, tag?tag:"ns1:ListBucketResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ListBucketResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ListBucketResponse(struct soap *soap, _ns1__ListBucketResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ListBucketResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ListBucket(struct soap *soap, _ns1__ListBucket *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ListBucket))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ListBucket(struct soap *soap, const char *tag, int id, _ns1__ListBucket *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ListBucket);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ListBucket ** SOAP_FMAC4 soap_in_PointerTo_ns1__ListBucket(struct soap *soap, const char *tag, _ns1__ListBucket **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ListBucket **)soap_malloc(soap, sizeof(_ns1__ListBucket *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ListBucket *)soap_instantiate__ns1__ListBucket(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__ListBucket ** p = (_ns1__ListBucket **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ListBucket, sizeof(_ns1__ListBucket), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ListBucket(struct soap *soap, _ns1__ListBucket *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ListBucket);
	if (soap_out_PointerTo_ns1__ListBucket(soap, tag?tag:"ns1:ListBucket", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ListBucket ** SOAP_FMAC4 soap_get_PointerTo_ns1__ListBucket(struct soap *soap, _ns1__ListBucket **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ListBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteObjectResponse(struct soap *soap, _ns1__DeleteObjectResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteObjectResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteObjectResponse(struct soap *soap, const char *tag, int id, _ns1__DeleteObjectResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteObjectResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteObjectResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteObjectResponse(struct soap *soap, const char *tag, _ns1__DeleteObjectResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteObjectResponse **)soap_malloc(soap, sizeof(_ns1__DeleteObjectResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteObjectResponse *)soap_instantiate__ns1__DeleteObjectResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteObjectResponse ** p = (_ns1__DeleteObjectResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteObjectResponse, sizeof(_ns1__DeleteObjectResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteObjectResponse(struct soap *soap, _ns1__DeleteObjectResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteObjectResponse);
	if (soap_out_PointerTo_ns1__DeleteObjectResponse(soap, tag?tag:"ns1:DeleteObjectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteObjectResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteObjectResponse(struct soap *soap, _ns1__DeleteObjectResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteObject(struct soap *soap, _ns1__DeleteObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteObject))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteObject(struct soap *soap, const char *tag, int id, _ns1__DeleteObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteObject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteObject ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteObject(struct soap *soap, const char *tag, _ns1__DeleteObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteObject **)soap_malloc(soap, sizeof(_ns1__DeleteObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteObject *)soap_instantiate__ns1__DeleteObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteObject ** p = (_ns1__DeleteObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteObject, sizeof(_ns1__DeleteObject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteObject(struct soap *soap, _ns1__DeleteObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteObject);
	if (soap_out_PointerTo_ns1__DeleteObject(soap, tag?tag:"ns1:DeleteObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteObject ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteObject(struct soap *soap, _ns1__DeleteObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PutObjectInlineResponse(struct soap *soap, _ns1__PutObjectInlineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PutObjectInlineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PutObjectInlineResponse(struct soap *soap, const char *tag, int id, _ns1__PutObjectInlineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PutObjectInlineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PutObjectInlineResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PutObjectInlineResponse(struct soap *soap, const char *tag, _ns1__PutObjectInlineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PutObjectInlineResponse **)soap_malloc(soap, sizeof(_ns1__PutObjectInlineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PutObjectInlineResponse *)soap_instantiate__ns1__PutObjectInlineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PutObjectInlineResponse ** p = (_ns1__PutObjectInlineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PutObjectInlineResponse, sizeof(_ns1__PutObjectInlineResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PutObjectInlineResponse(struct soap *soap, _ns1__PutObjectInlineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PutObjectInlineResponse);
	if (soap_out_PointerTo_ns1__PutObjectInlineResponse(soap, tag?tag:"ns1:PutObjectInlineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PutObjectInlineResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PutObjectInlineResponse(struct soap *soap, _ns1__PutObjectInlineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PutObjectInlineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PutObjectInline(struct soap *soap, _ns1__PutObjectInline *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PutObjectInline))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PutObjectInline(struct soap *soap, const char *tag, int id, _ns1__PutObjectInline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PutObjectInline);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PutObjectInline ** SOAP_FMAC4 soap_in_PointerTo_ns1__PutObjectInline(struct soap *soap, const char *tag, _ns1__PutObjectInline **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PutObjectInline **)soap_malloc(soap, sizeof(_ns1__PutObjectInline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PutObjectInline *)soap_instantiate__ns1__PutObjectInline(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PutObjectInline ** p = (_ns1__PutObjectInline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PutObjectInline, sizeof(_ns1__PutObjectInline), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PutObjectInline(struct soap *soap, _ns1__PutObjectInline *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PutObjectInline);
	if (soap_out_PointerTo_ns1__PutObjectInline(soap, tag?tag:"ns1:PutObjectInline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PutObjectInline ** SOAP_FMAC4 soap_get_PointerTo_ns1__PutObjectInline(struct soap *soap, _ns1__PutObjectInline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PutObjectInline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PutObjectResponse(struct soap *soap, _ns1__PutObjectResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PutObjectResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PutObjectResponse(struct soap *soap, const char *tag, int id, _ns1__PutObjectResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PutObjectResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PutObjectResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__PutObjectResponse(struct soap *soap, const char *tag, _ns1__PutObjectResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PutObjectResponse **)soap_malloc(soap, sizeof(_ns1__PutObjectResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PutObjectResponse *)soap_instantiate__ns1__PutObjectResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PutObjectResponse ** p = (_ns1__PutObjectResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PutObjectResponse, sizeof(_ns1__PutObjectResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PutObjectResponse(struct soap *soap, _ns1__PutObjectResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PutObjectResponse);
	if (soap_out_PointerTo_ns1__PutObjectResponse(soap, tag?tag:"ns1:PutObjectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PutObjectResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__PutObjectResponse(struct soap *soap, _ns1__PutObjectResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PutObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__PutObject(struct soap *soap, _ns1__PutObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__PutObject))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__PutObject(struct soap *soap, const char *tag, int id, _ns1__PutObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__PutObject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__PutObject ** SOAP_FMAC4 soap_in_PointerTo_ns1__PutObject(struct soap *soap, const char *tag, _ns1__PutObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__PutObject **)soap_malloc(soap, sizeof(_ns1__PutObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__PutObject *)soap_instantiate__ns1__PutObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__PutObject ** p = (_ns1__PutObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__PutObject, sizeof(_ns1__PutObject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__PutObject(struct soap *soap, _ns1__PutObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__PutObject);
	if (soap_out_PointerTo_ns1__PutObject(soap, tag?tag:"ns1:PutObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__PutObject ** SOAP_FMAC4 soap_get_PointerTo_ns1__PutObject(struct soap *soap, _ns1__PutObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__PutObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetObjectExtendedResponse(struct soap *soap, _ns1__GetObjectExtendedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetObjectExtendedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetObjectExtendedResponse(struct soap *soap, const char *tag, int id, _ns1__GetObjectExtendedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetObjectExtendedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetObjectExtendedResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetObjectExtendedResponse(struct soap *soap, const char *tag, _ns1__GetObjectExtendedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetObjectExtendedResponse **)soap_malloc(soap, sizeof(_ns1__GetObjectExtendedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetObjectExtendedResponse *)soap_instantiate__ns1__GetObjectExtendedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetObjectExtendedResponse ** p = (_ns1__GetObjectExtendedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetObjectExtendedResponse, sizeof(_ns1__GetObjectExtendedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetObjectExtendedResponse(struct soap *soap, _ns1__GetObjectExtendedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetObjectExtendedResponse);
	if (soap_out_PointerTo_ns1__GetObjectExtendedResponse(soap, tag?tag:"ns1:GetObjectExtendedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetObjectExtendedResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetObjectExtendedResponse(struct soap *soap, _ns1__GetObjectExtendedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetObjectExtendedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetObjectExtended(struct soap *soap, _ns1__GetObjectExtended *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetObjectExtended))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetObjectExtended(struct soap *soap, const char *tag, int id, _ns1__GetObjectExtended *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetObjectExtended);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetObjectExtended ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetObjectExtended(struct soap *soap, const char *tag, _ns1__GetObjectExtended **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetObjectExtended **)soap_malloc(soap, sizeof(_ns1__GetObjectExtended *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetObjectExtended *)soap_instantiate__ns1__GetObjectExtended(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetObjectExtended ** p = (_ns1__GetObjectExtended **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetObjectExtended, sizeof(_ns1__GetObjectExtended), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetObjectExtended(struct soap *soap, _ns1__GetObjectExtended *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetObjectExtended);
	if (soap_out_PointerTo_ns1__GetObjectExtended(soap, tag?tag:"ns1:GetObjectExtended", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetObjectExtended ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetObjectExtended(struct soap *soap, _ns1__GetObjectExtended **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetObjectExtended(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetObjectResponse(struct soap *soap, _ns1__GetObjectResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetObjectResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetObjectResponse(struct soap *soap, const char *tag, int id, _ns1__GetObjectResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetObjectResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetObjectResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetObjectResponse(struct soap *soap, const char *tag, _ns1__GetObjectResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetObjectResponse **)soap_malloc(soap, sizeof(_ns1__GetObjectResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetObjectResponse *)soap_instantiate__ns1__GetObjectResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetObjectResponse ** p = (_ns1__GetObjectResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetObjectResponse, sizeof(_ns1__GetObjectResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetObjectResponse(struct soap *soap, _ns1__GetObjectResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetObjectResponse);
	if (soap_out_PointerTo_ns1__GetObjectResponse(soap, tag?tag:"ns1:GetObjectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetObjectResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetObjectResponse(struct soap *soap, _ns1__GetObjectResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetObject(struct soap *soap, _ns1__GetObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetObject))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetObject(struct soap *soap, const char *tag, int id, _ns1__GetObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetObject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetObject ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetObject(struct soap *soap, const char *tag, _ns1__GetObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetObject **)soap_malloc(soap, sizeof(_ns1__GetObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetObject *)soap_instantiate__ns1__GetObject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetObject ** p = (_ns1__GetObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetObject, sizeof(_ns1__GetObject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetObject(struct soap *soap, _ns1__GetObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetObject);
	if (soap_out_PointerTo_ns1__GetObject(soap, tag?tag:"ns1:GetObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetObject ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetObject(struct soap *soap, _ns1__GetObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__SetBucketAccessControlPolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__SetBucketAccessControlPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__SetBucketAccessControlPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetBucketAccessControlPolicyResponse **)soap_malloc(soap, sizeof(_ns1__SetBucketAccessControlPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetBucketAccessControlPolicyResponse *)soap_instantiate__ns1__SetBucketAccessControlPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetBucketAccessControlPolicyResponse ** p = (_ns1__SetBucketAccessControlPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetBucketAccessControlPolicyResponse, sizeof(_ns1__SetBucketAccessControlPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__SetBucketAccessControlPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicyResponse);
	if (soap_out_PointerTo_ns1__SetBucketAccessControlPolicyResponse(soap, tag?tag:"ns1:SetBucketAccessControlPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__SetBucketAccessControlPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetBucketAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetBucketAccessControlPolicy(struct soap *soap, _ns1__SetBucketAccessControlPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetBucketAccessControlPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetBucketAccessControlPolicy(struct soap *soap, const char *tag, int id, _ns1__SetBucketAccessControlPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetBucketAccessControlPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetBucketAccessControlPolicy(struct soap *soap, const char *tag, _ns1__SetBucketAccessControlPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetBucketAccessControlPolicy **)soap_malloc(soap, sizeof(_ns1__SetBucketAccessControlPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetBucketAccessControlPolicy *)soap_instantiate__ns1__SetBucketAccessControlPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetBucketAccessControlPolicy ** p = (_ns1__SetBucketAccessControlPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetBucketAccessControlPolicy, sizeof(_ns1__SetBucketAccessControlPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetBucketAccessControlPolicy(struct soap *soap, _ns1__SetBucketAccessControlPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetBucketAccessControlPolicy);
	if (soap_out_PointerTo_ns1__SetBucketAccessControlPolicy(soap, tag?tag:"ns1:SetBucketAccessControlPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetBucketAccessControlPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetBucketAccessControlPolicy(struct soap *soap, _ns1__SetBucketAccessControlPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetBucketAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__SetObjectAccessControlPolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__SetObjectAccessControlPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__SetObjectAccessControlPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetObjectAccessControlPolicyResponse **)soap_malloc(soap, sizeof(_ns1__SetObjectAccessControlPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetObjectAccessControlPolicyResponse *)soap_instantiate__ns1__SetObjectAccessControlPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetObjectAccessControlPolicyResponse ** p = (_ns1__SetObjectAccessControlPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetObjectAccessControlPolicyResponse, sizeof(_ns1__SetObjectAccessControlPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__SetObjectAccessControlPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicyResponse);
	if (soap_out_PointerTo_ns1__SetObjectAccessControlPolicyResponse(soap, tag?tag:"ns1:SetObjectAccessControlPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__SetObjectAccessControlPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetObjectAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetObjectAccessControlPolicy(struct soap *soap, _ns1__SetObjectAccessControlPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetObjectAccessControlPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetObjectAccessControlPolicy(struct soap *soap, const char *tag, int id, _ns1__SetObjectAccessControlPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetObjectAccessControlPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetObjectAccessControlPolicy(struct soap *soap, const char *tag, _ns1__SetObjectAccessControlPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetObjectAccessControlPolicy **)soap_malloc(soap, sizeof(_ns1__SetObjectAccessControlPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetObjectAccessControlPolicy *)soap_instantiate__ns1__SetObjectAccessControlPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SetObjectAccessControlPolicy ** p = (_ns1__SetObjectAccessControlPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetObjectAccessControlPolicy, sizeof(_ns1__SetObjectAccessControlPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetObjectAccessControlPolicy(struct soap *soap, _ns1__SetObjectAccessControlPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SetObjectAccessControlPolicy);
	if (soap_out_PointerTo_ns1__SetObjectAccessControlPolicy(soap, tag?tag:"ns1:SetObjectAccessControlPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetObjectAccessControlPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetObjectAccessControlPolicy(struct soap *soap, _ns1__SetObjectAccessControlPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetObjectAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__GetBucketAccessControlPolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__GetBucketAccessControlPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__GetBucketAccessControlPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBucketAccessControlPolicyResponse **)soap_malloc(soap, sizeof(_ns1__GetBucketAccessControlPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBucketAccessControlPolicyResponse *)soap_instantiate__ns1__GetBucketAccessControlPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBucketAccessControlPolicyResponse ** p = (_ns1__GetBucketAccessControlPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBucketAccessControlPolicyResponse, sizeof(_ns1__GetBucketAccessControlPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__GetBucketAccessControlPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicyResponse);
	if (soap_out_PointerTo_ns1__GetBucketAccessControlPolicyResponse(soap, tag?tag:"ns1:GetBucketAccessControlPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBucketAccessControlPolicyResponse(struct soap *soap, _ns1__GetBucketAccessControlPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBucketAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetBucketAccessControlPolicy(struct soap *soap, _ns1__GetBucketAccessControlPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetBucketAccessControlPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetBucketAccessControlPolicy(struct soap *soap, const char *tag, int id, _ns1__GetBucketAccessControlPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetBucketAccessControlPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetBucketAccessControlPolicy(struct soap *soap, const char *tag, _ns1__GetBucketAccessControlPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetBucketAccessControlPolicy **)soap_malloc(soap, sizeof(_ns1__GetBucketAccessControlPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetBucketAccessControlPolicy *)soap_instantiate__ns1__GetBucketAccessControlPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetBucketAccessControlPolicy ** p = (_ns1__GetBucketAccessControlPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetBucketAccessControlPolicy, sizeof(_ns1__GetBucketAccessControlPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetBucketAccessControlPolicy(struct soap *soap, _ns1__GetBucketAccessControlPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetBucketAccessControlPolicy);
	if (soap_out_PointerTo_ns1__GetBucketAccessControlPolicy(soap, tag?tag:"ns1:GetBucketAccessControlPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetBucketAccessControlPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetBucketAccessControlPolicy(struct soap *soap, _ns1__GetBucketAccessControlPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetBucketAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__GetObjectAccessControlPolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, int id, _ns1__GetObjectAccessControlPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, const char *tag, _ns1__GetObjectAccessControlPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetObjectAccessControlPolicyResponse **)soap_malloc(soap, sizeof(_ns1__GetObjectAccessControlPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetObjectAccessControlPolicyResponse *)soap_instantiate__ns1__GetObjectAccessControlPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetObjectAccessControlPolicyResponse ** p = (_ns1__GetObjectAccessControlPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetObjectAccessControlPolicyResponse, sizeof(_ns1__GetObjectAccessControlPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__GetObjectAccessControlPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicyResponse);
	if (soap_out_PointerTo_ns1__GetObjectAccessControlPolicyResponse(soap, tag?tag:"ns1:GetObjectAccessControlPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetObjectAccessControlPolicyResponse(struct soap *soap, _ns1__GetObjectAccessControlPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetObjectAccessControlPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetObjectAccessControlPolicy(struct soap *soap, _ns1__GetObjectAccessControlPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetObjectAccessControlPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetObjectAccessControlPolicy(struct soap *soap, const char *tag, int id, _ns1__GetObjectAccessControlPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetObjectAccessControlPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicy ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetObjectAccessControlPolicy(struct soap *soap, const char *tag, _ns1__GetObjectAccessControlPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetObjectAccessControlPolicy **)soap_malloc(soap, sizeof(_ns1__GetObjectAccessControlPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetObjectAccessControlPolicy *)soap_instantiate__ns1__GetObjectAccessControlPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetObjectAccessControlPolicy ** p = (_ns1__GetObjectAccessControlPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetObjectAccessControlPolicy, sizeof(_ns1__GetObjectAccessControlPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetObjectAccessControlPolicy(struct soap *soap, _ns1__GetObjectAccessControlPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetObjectAccessControlPolicy);
	if (soap_out_PointerTo_ns1__GetObjectAccessControlPolicy(soap, tag?tag:"ns1:GetObjectAccessControlPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetObjectAccessControlPolicy ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetObjectAccessControlPolicy(struct soap *soap, _ns1__GetObjectAccessControlPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetObjectAccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteBucketResponse(struct soap *soap, _ns1__DeleteBucketResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteBucketResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteBucketResponse(struct soap *soap, const char *tag, int id, _ns1__DeleteBucketResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteBucketResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteBucketResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteBucketResponse(struct soap *soap, const char *tag, _ns1__DeleteBucketResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteBucketResponse **)soap_malloc(soap, sizeof(_ns1__DeleteBucketResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteBucketResponse *)soap_instantiate__ns1__DeleteBucketResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteBucketResponse ** p = (_ns1__DeleteBucketResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteBucketResponse, sizeof(_ns1__DeleteBucketResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteBucketResponse(struct soap *soap, _ns1__DeleteBucketResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteBucketResponse);
	if (soap_out_PointerTo_ns1__DeleteBucketResponse(soap, tag?tag:"ns1:DeleteBucketResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteBucketResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteBucketResponse(struct soap *soap, _ns1__DeleteBucketResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteBucketResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteBucket(struct soap *soap, _ns1__DeleteBucket *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteBucket))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteBucket(struct soap *soap, const char *tag, int id, _ns1__DeleteBucket *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteBucket);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__DeleteBucket ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteBucket(struct soap *soap, const char *tag, _ns1__DeleteBucket **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DeleteBucket **)soap_malloc(soap, sizeof(_ns1__DeleteBucket *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DeleteBucket *)soap_instantiate__ns1__DeleteBucket(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__DeleteBucket ** p = (_ns1__DeleteBucket **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteBucket, sizeof(_ns1__DeleteBucket), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteBucket(struct soap *soap, _ns1__DeleteBucket *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteBucket);
	if (soap_out_PointerTo_ns1__DeleteBucket(soap, tag?tag:"ns1:DeleteBucket", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DeleteBucket ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteBucket(struct soap *soap, _ns1__DeleteBucket **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateBucketResponse(struct soap *soap, _ns1__CreateBucketResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateBucketResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateBucketResponse(struct soap *soap, const char *tag, int id, _ns1__CreateBucketResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateBucketResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateBucketResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateBucketResponse(struct soap *soap, const char *tag, _ns1__CreateBucketResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateBucketResponse **)soap_malloc(soap, sizeof(_ns1__CreateBucketResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateBucketResponse *)soap_instantiate__ns1__CreateBucketResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CreateBucketResponse ** p = (_ns1__CreateBucketResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateBucketResponse, sizeof(_ns1__CreateBucketResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateBucketResponse(struct soap *soap, _ns1__CreateBucketResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CreateBucketResponse);
	if (soap_out_PointerTo_ns1__CreateBucketResponse(soap, tag?tag:"ns1:CreateBucketResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateBucketResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateBucketResponse(struct soap *soap, _ns1__CreateBucketResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateBucketResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateBucket(struct soap *soap, _ns1__CreateBucket *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateBucket))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateBucket(struct soap *soap, const char *tag, int id, _ns1__CreateBucket *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateBucket);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CreateBucket ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateBucket(struct soap *soap, const char *tag, _ns1__CreateBucket **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CreateBucket **)soap_malloc(soap, sizeof(_ns1__CreateBucket *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CreateBucket *)soap_instantiate__ns1__CreateBucket(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CreateBucket ** p = (_ns1__CreateBucket **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateBucket, sizeof(_ns1__CreateBucket), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateBucket(struct soap *soap, _ns1__CreateBucket *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CreateBucket);
	if (soap_out_PointerTo_ns1__CreateBucket(soap, tag?tag:"ns1:CreateBucket", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CreateBucket ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateBucket(struct soap *soap, _ns1__CreateBucket **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateBucket(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CopyObjectResult(struct soap *soap, ns1__CopyObjectResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CopyObjectResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CopyObjectResult(struct soap *soap, const char *tag, int id, ns1__CopyObjectResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CopyObjectResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CopyObjectResult ** SOAP_FMAC4 soap_in_PointerTons1__CopyObjectResult(struct soap *soap, const char *tag, ns1__CopyObjectResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CopyObjectResult **)soap_malloc(soap, sizeof(ns1__CopyObjectResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CopyObjectResult *)soap_instantiate_ns1__CopyObjectResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CopyObjectResult ** p = (ns1__CopyObjectResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CopyObjectResult, sizeof(ns1__CopyObjectResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CopyObjectResult(struct soap *soap, ns1__CopyObjectResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CopyObjectResult);
	if (soap_out_PointerTons1__CopyObjectResult(soap, tag?tag:"ns1:CopyObjectResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CopyObjectResult ** SOAP_FMAC4 soap_get_PointerTons1__CopyObjectResult(struct soap *soap, ns1__CopyObjectResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CopyObjectResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MetadataDirective(struct soap *soap, enum ns1__MetadataDirective *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__MetadataDirective);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MetadataDirective(struct soap *soap, const char *tag, int id, enum ns1__MetadataDirective *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MetadataDirective);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__MetadataDirective(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__MetadataDirective ** SOAP_FMAC4 soap_in_PointerTons1__MetadataDirective(struct soap *soap, const char *tag, enum ns1__MetadataDirective **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__MetadataDirective **)soap_malloc(soap, sizeof(enum ns1__MetadataDirective *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__MetadataDirective(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__MetadataDirective **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MetadataDirective, sizeof(enum ns1__MetadataDirective), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MetadataDirective(struct soap *soap, enum ns1__MetadataDirective *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MetadataDirective);
	if (soap_out_PointerTons1__MetadataDirective(soap, tag?tag:"ns1:MetadataDirective", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__MetadataDirective ** SOAP_FMAC4 soap_get_PointerTons1__MetadataDirective(struct soap *soap, enum ns1__MetadataDirective **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MetadataDirective(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListAllMyBucketsResult(struct soap *soap, ns1__ListAllMyBucketsResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListAllMyBucketsResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListAllMyBucketsResult(struct soap *soap, const char *tag, int id, ns1__ListAllMyBucketsResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListAllMyBucketsResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsResult ** SOAP_FMAC4 soap_in_PointerTons1__ListAllMyBucketsResult(struct soap *soap, const char *tag, ns1__ListAllMyBucketsResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListAllMyBucketsResult **)soap_malloc(soap, sizeof(ns1__ListAllMyBucketsResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListAllMyBucketsResult *)soap_instantiate_ns1__ListAllMyBucketsResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListAllMyBucketsResult ** p = (ns1__ListAllMyBucketsResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListAllMyBucketsResult, sizeof(ns1__ListAllMyBucketsResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListAllMyBucketsResult(struct soap *soap, ns1__ListAllMyBucketsResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListAllMyBucketsResult);
	if (soap_out_PointerTons1__ListAllMyBucketsResult(soap, tag?tag:"ns1:ListAllMyBucketsResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ListAllMyBucketsResult ** SOAP_FMAC4 soap_get_PointerTons1__ListAllMyBucketsResult(struct soap *soap, ns1__ListAllMyBucketsResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListAllMyBucketsResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListBucketResult(struct soap *soap, ns1__ListBucketResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListBucketResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListBucketResult(struct soap *soap, const char *tag, int id, ns1__ListBucketResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListBucketResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListBucketResult ** SOAP_FMAC4 soap_in_PointerTons1__ListBucketResult(struct soap *soap, const char *tag, ns1__ListBucketResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListBucketResult **)soap_malloc(soap, sizeof(ns1__ListBucketResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListBucketResult *)soap_instantiate_ns1__ListBucketResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListBucketResult ** p = (ns1__ListBucketResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListBucketResult, sizeof(ns1__ListBucketResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListBucketResult(struct soap *soap, ns1__ListBucketResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListBucketResult);
	if (soap_out_PointerTons1__ListBucketResult(soap, tag?tag:"ns1:ListBucketResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ListBucketResult ** SOAP_FMAC4 soap_get_PointerTons1__ListBucketResult(struct soap *soap, ns1__ListBucketResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListBucketResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PutObjectResult(struct soap *soap, ns1__PutObjectResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PutObjectResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PutObjectResult(struct soap *soap, const char *tag, int id, ns1__PutObjectResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PutObjectResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PutObjectResult ** SOAP_FMAC4 soap_in_PointerTons1__PutObjectResult(struct soap *soap, const char *tag, ns1__PutObjectResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PutObjectResult **)soap_malloc(soap, sizeof(ns1__PutObjectResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PutObjectResult *)soap_instantiate_ns1__PutObjectResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PutObjectResult ** p = (ns1__PutObjectResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PutObjectResult, sizeof(ns1__PutObjectResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PutObjectResult(struct soap *soap, ns1__PutObjectResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PutObjectResult);
	if (soap_out_PointerTons1__PutObjectResult(soap, tag?tag:"ns1:PutObjectResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PutObjectResult ** SOAP_FMAC4 soap_get_PointerTons1__PutObjectResult(struct soap *soap, ns1__PutObjectResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PutObjectResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StorageClass(struct soap *soap, enum ns1__StorageClass *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__StorageClass);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StorageClass(struct soap *soap, const char *tag, int id, enum ns1__StorageClass *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StorageClass);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__StorageClass(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__StorageClass ** SOAP_FMAC4 soap_in_PointerTons1__StorageClass(struct soap *soap, const char *tag, enum ns1__StorageClass **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__StorageClass **)soap_malloc(soap, sizeof(enum ns1__StorageClass *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__StorageClass(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__StorageClass **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StorageClass, sizeof(enum ns1__StorageClass), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StorageClass(struct soap *soap, enum ns1__StorageClass *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StorageClass);
	if (soap_out_PointerTons1__StorageClass(soap, tag?tag:"ns1:StorageClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__StorageClass ** SOAP_FMAC4 soap_get_PointerTons1__StorageClass(struct soap *soap, enum ns1__StorageClass **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StorageClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetObjectResult(struct soap *soap, ns1__GetObjectResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetObjectResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetObjectResult(struct soap *soap, const char *tag, int id, ns1__GetObjectResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetObjectResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GetObjectResult ** SOAP_FMAC4 soap_in_PointerTons1__GetObjectResult(struct soap *soap, const char *tag, ns1__GetObjectResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetObjectResult **)soap_malloc(soap, sizeof(ns1__GetObjectResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetObjectResult *)soap_instantiate_ns1__GetObjectResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__GetObjectResult ** p = (ns1__GetObjectResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetObjectResult, sizeof(ns1__GetObjectResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetObjectResult(struct soap *soap, ns1__GetObjectResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GetObjectResult);
	if (soap_out_PointerTons1__GetObjectResult(soap, tag?tag:"ns1:GetObjectResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetObjectResult ** SOAP_FMAC4 soap_get_PointerTons1__GetObjectResult(struct soap *soap, ns1__GetObjectResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetObjectResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessControlPolicy(struct soap *soap, ns1__AccessControlPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessControlPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessControlPolicy(struct soap *soap, const char *tag, int id, ns1__AccessControlPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccessControlPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AccessControlPolicy ** SOAP_FMAC4 soap_in_PointerTons1__AccessControlPolicy(struct soap *soap, const char *tag, ns1__AccessControlPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AccessControlPolicy **)soap_malloc(soap, sizeof(ns1__AccessControlPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AccessControlPolicy *)soap_instantiate_ns1__AccessControlPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AccessControlPolicy ** p = (ns1__AccessControlPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccessControlPolicy, sizeof(ns1__AccessControlPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessControlPolicy(struct soap *soap, ns1__AccessControlPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AccessControlPolicy);
	if (soap_out_PointerTons1__AccessControlPolicy(soap, tag?tag:"ns1:AccessControlPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AccessControlPolicy ** SOAP_FMAC4 soap_get_PointerTons1__AccessControlPolicy(struct soap *soap, ns1__AccessControlPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessControlPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BucketLoggingStatus(struct soap *soap, ns1__BucketLoggingStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BucketLoggingStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BucketLoggingStatus(struct soap *soap, const char *tag, int id, ns1__BucketLoggingStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BucketLoggingStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BucketLoggingStatus ** SOAP_FMAC4 soap_in_PointerTons1__BucketLoggingStatus(struct soap *soap, const char *tag, ns1__BucketLoggingStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BucketLoggingStatus **)soap_malloc(soap, sizeof(ns1__BucketLoggingStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BucketLoggingStatus *)soap_instantiate_ns1__BucketLoggingStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__BucketLoggingStatus ** p = (ns1__BucketLoggingStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BucketLoggingStatus, sizeof(ns1__BucketLoggingStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BucketLoggingStatus(struct soap *soap, ns1__BucketLoggingStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BucketLoggingStatus);
	if (soap_out_PointerTons1__BucketLoggingStatus(soap, tag?tag:"ns1:BucketLoggingStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__BucketLoggingStatus ** SOAP_FMAC4 soap_get_PointerTons1__BucketLoggingStatus(struct soap *soap, ns1__BucketLoggingStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BucketLoggingStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CreateBucketResult(struct soap *soap, ns1__CreateBucketResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CreateBucketResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CreateBucketResult(struct soap *soap, const char *tag, int id, ns1__CreateBucketResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CreateBucketResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CreateBucketResult ** SOAP_FMAC4 soap_in_PointerTons1__CreateBucketResult(struct soap *soap, const char *tag, ns1__CreateBucketResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CreateBucketResult **)soap_malloc(soap, sizeof(ns1__CreateBucketResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CreateBucketResult *)soap_instantiate_ns1__CreateBucketResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CreateBucketResult ** p = (ns1__CreateBucketResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CreateBucketResult, sizeof(ns1__CreateBucketResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CreateBucketResult(struct soap *soap, ns1__CreateBucketResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CreateBucketResult);
	if (soap_out_PointerTons1__CreateBucketResult(soap, tag?tag:"ns1:CreateBucketResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CreateBucketResult ** SOAP_FMAC4 soap_get_PointerTons1__CreateBucketResult(struct soap *soap, ns1__CreateBucketResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CreateBucketResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListAllMyBucketsEntry(struct soap *soap, ns1__ListAllMyBucketsEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListAllMyBucketsEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListAllMyBucketsEntry(struct soap *soap, const char *tag, int id, ns1__ListAllMyBucketsEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListAllMyBucketsEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsEntry ** SOAP_FMAC4 soap_in_PointerTons1__ListAllMyBucketsEntry(struct soap *soap, const char *tag, ns1__ListAllMyBucketsEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListAllMyBucketsEntry **)soap_malloc(soap, sizeof(ns1__ListAllMyBucketsEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListAllMyBucketsEntry *)soap_instantiate_ns1__ListAllMyBucketsEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListAllMyBucketsEntry ** p = (ns1__ListAllMyBucketsEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListAllMyBucketsEntry, sizeof(ns1__ListAllMyBucketsEntry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListAllMyBucketsEntry(struct soap *soap, ns1__ListAllMyBucketsEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListAllMyBucketsEntry);
	if (soap_out_PointerTons1__ListAllMyBucketsEntry(soap, tag?tag:"ns1:ListAllMyBucketsEntry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ListAllMyBucketsEntry ** SOAP_FMAC4 soap_get_PointerTons1__ListAllMyBucketsEntry(struct soap *soap, ns1__ListAllMyBucketsEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListAllMyBucketsEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListAllMyBucketsList(struct soap *soap, ns1__ListAllMyBucketsList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListAllMyBucketsList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListAllMyBucketsList(struct soap *soap, const char *tag, int id, ns1__ListAllMyBucketsList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListAllMyBucketsList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListAllMyBucketsList ** SOAP_FMAC4 soap_in_PointerTons1__ListAllMyBucketsList(struct soap *soap, const char *tag, ns1__ListAllMyBucketsList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListAllMyBucketsList **)soap_malloc(soap, sizeof(ns1__ListAllMyBucketsList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListAllMyBucketsList *)soap_instantiate_ns1__ListAllMyBucketsList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListAllMyBucketsList ** p = (ns1__ListAllMyBucketsList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListAllMyBucketsList, sizeof(ns1__ListAllMyBucketsList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListAllMyBucketsList(struct soap *soap, ns1__ListAllMyBucketsList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListAllMyBucketsList);
	if (soap_out_PointerTons1__ListAllMyBucketsList(soap, tag?tag:"ns1:ListAllMyBucketsList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ListAllMyBucketsList ** SOAP_FMAC4 soap_get_PointerTons1__ListAllMyBucketsList(struct soap *soap, ns1__ListAllMyBucketsList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListAllMyBucketsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PrefixEntry(struct soap *soap, ns1__PrefixEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PrefixEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PrefixEntry(struct soap *soap, const char *tag, int id, ns1__PrefixEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PrefixEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PrefixEntry ** SOAP_FMAC4 soap_in_PointerTons1__PrefixEntry(struct soap *soap, const char *tag, ns1__PrefixEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PrefixEntry **)soap_malloc(soap, sizeof(ns1__PrefixEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PrefixEntry *)soap_instantiate_ns1__PrefixEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PrefixEntry ** p = (ns1__PrefixEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PrefixEntry, sizeof(ns1__PrefixEntry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PrefixEntry(struct soap *soap, ns1__PrefixEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PrefixEntry);
	if (soap_out_PointerTons1__PrefixEntry(soap, tag?tag:"ns1:PrefixEntry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PrefixEntry ** SOAP_FMAC4 soap_get_PointerTons1__PrefixEntry(struct soap *soap, ns1__PrefixEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PrefixEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ListEntry(struct soap *soap, ns1__ListEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ListEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ListEntry(struct soap *soap, const char *tag, int id, ns1__ListEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ListEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ListEntry ** SOAP_FMAC4 soap_in_PointerTons1__ListEntry(struct soap *soap, const char *tag, ns1__ListEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ListEntry **)soap_malloc(soap, sizeof(ns1__ListEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ListEntry *)soap_instantiate_ns1__ListEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ListEntry ** p = (ns1__ListEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ListEntry, sizeof(ns1__ListEntry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ListEntry(struct soap *soap, ns1__ListEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ListEntry);
	if (soap_out_PointerTons1__ListEntry(soap, tag?tag:"ns1:ListEntry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ListEntry ** SOAP_FMAC4 soap_get_PointerTons1__ListEntry(struct soap *soap, ns1__ListEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ListEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MetadataEntry(struct soap *soap, ns1__MetadataEntry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MetadataEntry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MetadataEntry(struct soap *soap, const char *tag, int id, ns1__MetadataEntry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MetadataEntry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MetadataEntry ** SOAP_FMAC4 soap_in_PointerTons1__MetadataEntry(struct soap *soap, const char *tag, ns1__MetadataEntry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MetadataEntry **)soap_malloc(soap, sizeof(ns1__MetadataEntry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MetadataEntry *)soap_instantiate_ns1__MetadataEntry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MetadataEntry ** p = (ns1__MetadataEntry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MetadataEntry, sizeof(ns1__MetadataEntry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MetadataEntry(struct soap *soap, ns1__MetadataEntry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MetadataEntry);
	if (soap_out_PointerTons1__MetadataEntry(soap, tag?tag:"ns1:MetadataEntry", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MetadataEntry ** SOAP_FMAC4 soap_get_PointerTons1__MetadataEntry(struct soap *soap, ns1__MetadataEntry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MetadataEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CanonicalUser(struct soap *soap, ns1__CanonicalUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CanonicalUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CanonicalUser(struct soap *soap, const char *tag, int id, ns1__CanonicalUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CanonicalUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CanonicalUser ** SOAP_FMAC4 soap_in_PointerTons1__CanonicalUser(struct soap *soap, const char *tag, ns1__CanonicalUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CanonicalUser **)soap_malloc(soap, sizeof(ns1__CanonicalUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CanonicalUser *)soap_instantiate_ns1__CanonicalUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CanonicalUser ** p = (ns1__CanonicalUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CanonicalUser, sizeof(ns1__CanonicalUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CanonicalUser(struct soap *soap, ns1__CanonicalUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CanonicalUser);
	if (soap_out_PointerTons1__CanonicalUser(soap, tag?tag:"ns1:CanonicalUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CanonicalUser ** SOAP_FMAC4 soap_get_PointerTons1__CanonicalUser(struct soap *soap, ns1__CanonicalUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CanonicalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LocationConstraint(struct soap *soap, ns1__LocationConstraint *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LocationConstraint))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LocationConstraint(struct soap *soap, const char *tag, int id, ns1__LocationConstraint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LocationConstraint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LocationConstraint ** SOAP_FMAC4 soap_in_PointerTons1__LocationConstraint(struct soap *soap, const char *tag, ns1__LocationConstraint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LocationConstraint **)soap_malloc(soap, sizeof(ns1__LocationConstraint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LocationConstraint *)soap_instantiate_ns1__LocationConstraint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__LocationConstraint ** p = (ns1__LocationConstraint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LocationConstraint, sizeof(ns1__LocationConstraint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LocationConstraint(struct soap *soap, ns1__LocationConstraint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LocationConstraint);
	if (soap_out_PointerTons1__LocationConstraint(soap, tag?tag:"ns1:LocationConstraint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LocationConstraint ** SOAP_FMAC4 soap_get_PointerTons1__LocationConstraint(struct soap *soap, ns1__LocationConstraint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LocationConstraint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Grant(struct soap *soap, ns1__Grant *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Grant))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Grant(struct soap *soap, const char *tag, int id, ns1__Grant *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Grant);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Grant ** SOAP_FMAC4 soap_in_PointerTons1__Grant(struct soap *soap, const char *tag, ns1__Grant **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Grant **)soap_malloc(soap, sizeof(ns1__Grant *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Grant *)soap_instantiate_ns1__Grant(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Grant ** p = (ns1__Grant **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Grant, sizeof(ns1__Grant), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Grant(struct soap *soap, ns1__Grant *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Grant);
	if (soap_out_PointerTons1__Grant(soap, tag?tag:"ns1:Grant", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Grant ** SOAP_FMAC4 soap_get_PointerTons1__Grant(struct soap *soap, ns1__Grant **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Grant(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Grantee(struct soap *soap, ns1__Grantee *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Grantee))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Grantee(struct soap *soap, const char *tag, int id, ns1__Grantee *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Grantee);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Grantee ** SOAP_FMAC4 soap_in_PointerTons1__Grantee(struct soap *soap, const char *tag, ns1__Grantee **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Grantee **)soap_malloc(soap, sizeof(ns1__Grantee *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Grantee *)soap_instantiate_ns1__Grantee(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Grantee ** p = (ns1__Grantee **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Grantee, sizeof(ns1__Grantee), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__Grantee **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__User, sizeof(ns1__User), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__Grantee **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Group, sizeof(ns1__Group), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__Grantee **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AmazonCustomerByEmail, sizeof(ns1__AmazonCustomerByEmail), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__Grantee **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CanonicalUser, sizeof(ns1__CanonicalUser), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Grantee(struct soap *soap, ns1__Grantee *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Grantee);
	if (soap_out_PointerTons1__Grantee(soap, tag?tag:"ns1:Grantee", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Grantee ** SOAP_FMAC4 soap_get_PointerTons1__Grantee(struct soap *soap, ns1__Grantee **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Grantee(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccessControlList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccessControlList(struct soap *soap, const char *tag, int id, ns1__AccessControlList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccessControlList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AccessControlList ** SOAP_FMAC4 soap_in_PointerTons1__AccessControlList(struct soap *soap, const char *tag, ns1__AccessControlList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AccessControlList **)soap_malloc(soap, sizeof(ns1__AccessControlList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AccessControlList *)soap_instantiate_ns1__AccessControlList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AccessControlList ** p = (ns1__AccessControlList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccessControlList, sizeof(ns1__AccessControlList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AccessControlList);
	if (soap_out_PointerTons1__AccessControlList(soap, tag?tag:"ns1:AccessControlList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AccessControlList ** SOAP_FMAC4 soap_get_PointerTons1__AccessControlList(struct soap *soap, ns1__AccessControlList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccessControlList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LoggingSettings(struct soap *soap, ns1__LoggingSettings *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LoggingSettings))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LoggingSettings(struct soap *soap, const char *tag, int id, ns1__LoggingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LoggingSettings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LoggingSettings ** SOAP_FMAC4 soap_in_PointerTons1__LoggingSettings(struct soap *soap, const char *tag, ns1__LoggingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LoggingSettings **)soap_malloc(soap, sizeof(ns1__LoggingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LoggingSettings *)soap_instantiate_ns1__LoggingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__LoggingSettings ** p = (ns1__LoggingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LoggingSettings, sizeof(ns1__LoggingSettings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LoggingSettings(struct soap *soap, ns1__LoggingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LoggingSettings);
	if (soap_out_PointerTons1__LoggingSettings(soap, tag?tag:"ns1:LoggingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LoggingSettings ** SOAP_FMAC4 soap_get_PointerTons1__LoggingSettings(struct soap *soap, ns1__LoggingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LoggingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Status(struct soap *soap, ns1__Status *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Status))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Status(struct soap *soap, const char *tag, int id, ns1__Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Status);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_in_PointerTons1__Status(struct soap *soap, const char *tag, ns1__Status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Status **)soap_malloc(soap, sizeof(ns1__Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Status *)soap_instantiate_ns1__Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Status ** p = (ns1__Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Status(struct soap *soap, ns1__Status *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Status);
	if (soap_out_PointerTons1__Status(soap, tag?tag:"ns1:Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_get_PointerTons1__Status(struct soap *soap, ns1__Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(struct soap *soap, std::vector<ns1__ListAllMyBucketsEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(struct soap *soap, const std::vector<ns1__ListAllMyBucketsEntry * >*a)
{
	for (std::vector<ns1__ListAllMyBucketsEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ListAllMyBucketsEntry(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__ListAllMyBucketsEntry * >*a, const char *type)
{
	for (std::vector<ns1__ListAllMyBucketsEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ListAllMyBucketsEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ListAllMyBucketsEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(struct soap *soap, const char *tag, std::vector<ns1__ListAllMyBucketsEntry * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(soap, -1)))
		return NULL;
	ns1__ListAllMyBucketsEntry *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ListAllMyBucketsEntry, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry, sizeof(ns1__ListAllMyBucketsEntry), 1))
				break;
			if (!soap_in_PointerTons1__ListAllMyBucketsEntry(soap, tag, NULL, "ns1:ListAllMyBucketsEntry"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__ListAllMyBucketsEntry(soap, tag, &n, "ns1:ListAllMyBucketsEntry"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ListAllMyBucketsEntry * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ListAllMyBucketsEntry * >);
		if (size)
			*size = sizeof(std::vector<ns1__ListAllMyBucketsEntry * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ListAllMyBucketsEntry * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ListAllMyBucketsEntry * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ListAllMyBucketsEntry * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ListAllMyBucketsEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ListAllMyBucketsEntry * > %p -> %p\n", q, p));
	*(std::vector<ns1__ListAllMyBucketsEntry * >*)p = *(std::vector<ns1__ListAllMyBucketsEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__PrefixEntry(struct soap *soap, std::vector<ns1__PrefixEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__PrefixEntry(struct soap *soap, const std::vector<ns1__PrefixEntry * >*a)
{
	for (std::vector<ns1__PrefixEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__PrefixEntry(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__PrefixEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__PrefixEntry * >*a, const char *type)
{
	for (std::vector<ns1__PrefixEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__PrefixEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__PrefixEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__PrefixEntry(struct soap *soap, const char *tag, std::vector<ns1__PrefixEntry * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__PrefixEntry(soap, -1)))
		return NULL;
	ns1__PrefixEntry *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__PrefixEntry, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PrefixEntry, sizeof(ns1__PrefixEntry), 1))
				break;
			if (!soap_in_PointerTons1__PrefixEntry(soap, tag, NULL, "ns1:PrefixEntry"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__PrefixEntry(soap, tag, &n, "ns1:PrefixEntry"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__PrefixEntry * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__PrefixEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__PrefixEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PrefixEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__PrefixEntry * >);
		if (size)
			*size = sizeof(std::vector<ns1__PrefixEntry * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__PrefixEntry * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__PrefixEntry * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__PrefixEntry * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__PrefixEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__PrefixEntry * > %p -> %p\n", q, p));
	*(std::vector<ns1__PrefixEntry * >*)p = *(std::vector<ns1__PrefixEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ListEntry(struct soap *soap, std::vector<ns1__ListEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ListEntry(struct soap *soap, const std::vector<ns1__ListEntry * >*a)
{
	for (std::vector<ns1__ListEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ListEntry(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ListEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__ListEntry * >*a, const char *type)
{
	for (std::vector<ns1__ListEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ListEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ListEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ListEntry(struct soap *soap, const char *tag, std::vector<ns1__ListEntry * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ListEntry(soap, -1)))
		return NULL;
	ns1__ListEntry *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ListEntry, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListEntry, sizeof(ns1__ListEntry), 1))
				break;
			if (!soap_in_PointerTons1__ListEntry(soap, tag, NULL, "ns1:ListEntry"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__ListEntry(soap, tag, &n, "ns1:ListEntry"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__ListEntry * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__ListEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ListEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ListEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ListEntry * >);
		if (size)
			*size = sizeof(std::vector<ns1__ListEntry * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__ListEntry * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ListEntry * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ListEntry * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ListEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ListEntry * > %p -> %p\n", q, p));
	*(std::vector<ns1__ListEntry * >*)p = *(std::vector<ns1__ListEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__MetadataEntry(struct soap *soap, std::vector<ns1__MetadataEntry * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__MetadataEntry(struct soap *soap, const std::vector<ns1__MetadataEntry * >*a)
{
	for (std::vector<ns1__MetadataEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__MetadataEntry(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__MetadataEntry(struct soap *soap, const char *tag, int id, const std::vector<ns1__MetadataEntry * >*a, const char *type)
{
	for (std::vector<ns1__MetadataEntry * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__MetadataEntry(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__MetadataEntry * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__MetadataEntry(struct soap *soap, const char *tag, std::vector<ns1__MetadataEntry * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__MetadataEntry(soap, -1)))
		return NULL;
	ns1__MetadataEntry *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__MetadataEntry, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MetadataEntry, sizeof(ns1__MetadataEntry), 1))
				break;
			if (!soap_in_PointerTons1__MetadataEntry(soap, tag, NULL, "ns1:MetadataEntry"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__MetadataEntry(soap, tag, &n, "ns1:MetadataEntry"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__MetadataEntry * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__MetadataEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__MetadataEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MetadataEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__MetadataEntry * >);
		if (size)
			*size = sizeof(std::vector<ns1__MetadataEntry * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__MetadataEntry * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__MetadataEntry * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__MetadataEntry * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__MetadataEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__MetadataEntry * > %p -> %p\n", q, p));
	*(std::vector<ns1__MetadataEntry * >*)p = *(std::vector<ns1__MetadataEntry * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Grant(struct soap *soap, std::vector<ns1__Grant * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Grant(struct soap *soap, const std::vector<ns1__Grant * >*a)
{
	for (std::vector<ns1__Grant * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Grant(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Grant(struct soap *soap, const char *tag, int id, const std::vector<ns1__Grant * >*a, const char *type)
{
	for (std::vector<ns1__Grant * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Grant(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Grant * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Grant(struct soap *soap, const char *tag, std::vector<ns1__Grant * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Grant(soap, -1)))
		return NULL;
	ns1__Grant *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Grant, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Grant, sizeof(ns1__Grant), 1))
				break;
			if (!soap_in_PointerTons1__Grant(soap, tag, NULL, "ns1:Grant"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Grant(soap, tag, &n, "ns1:Grant"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Grant * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Grant(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Grant(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Grant, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Grant * >);
		if (size)
			*size = sizeof(std::vector<ns1__Grant * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Grant * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Grant * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Grant * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Grant(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Grant * > %p -> %p\n", q, p));
	*(std::vector<ns1__Grant * >*)p = *(std::vector<ns1__Grant * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
